(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

// a simple wrapper around a single arraybuffer

module.exports = Buffer;

function Buffer(buffer) {
    if (!buffer) {
        this.array = new ArrayBuffer(this.defaultLength);
        this.length = this.defaultLength;
        this.setupViews();

    } else {
        // we only recreate buffers after receiving them from workers for binding to gl,
        // so we only need these 2 properties
        this.array = buffer.array;
        this.pos = buffer.pos;
    }
}

Buffer.prototype = {
    pos: 0,
    itemSize: 4, // bytes in one item
    defaultLength: 8192, // initial buffer size
    arrayType: 'ARRAY_BUFFER', // gl buffer type

    get index() {
        return this.pos / this.itemSize;
    },

    setupViews: function() {
        // set up views for each type to add data of different types to the same buffer
        this.ubytes = new Uint8Array(this.array);
        this.bytes = new Int8Array(this.array);
        this.ushorts = new Uint16Array(this.array);
        this.shorts = new Int16Array(this.array);
    },

    // binds the buffer to a webgl context
    bind: function(gl) {
        var type = gl[this.arrayType];
        if (!this.buffer) {
            this.buffer = gl.createBuffer();
            gl.bindBuffer(type, this.buffer);
            gl.bufferData(type, new DataView(this.array, 0, this.pos), gl.STATIC_DRAW);

            // dump array buffer once it's bound to gl
            this.array = null;
        } else {
            gl.bindBuffer(type, this.buffer);
        }
    },

    destroy: function(gl) {
        if (this.buffer) {
            gl.deleteBuffer(this.buffer);
        }
    },

    // increase the buffer size by 50% if a new item doesn't fit
    resize: function() {
        if (this.length < this.pos + this.itemSize) {

            while (this.length < this.pos + this.itemSize) {
                // increase the length by 50% but keep it even
                this.length = Math.round(this.length * 1.5 / 2) * 2;
            }

            // array buffers can't be resized, so we create a new one and reset all bytes there
            this.array = new ArrayBuffer(this.length);

            var ubytes = new Uint8Array(this.array);
            ubytes.set(this.ubytes);

            this.setupViews();
        }
    }
};

},{}],2:[function(require,module,exports){
'use strict';

var LineVertexBuffer = require('./linevertexbuffer.js');
var LineElementBuffer = require('./lineelementbuffer.js');
var FillVertexBuffer = require('./fillvertexbuffer.js');
var FillElementBuffer = require('./fillelementsbuffer.js');
var OutlineElementBuffer = require('./outlineelementsbuffer.js');
var GlyphVertexBuffer = require('./glyphvertexbuffer.js');
var IconVertexBuffer = require('./iconvertexbuffer.js');

module.exports = function(bufferset) {
    bufferset = bufferset || {};
    return {
        glyphVertex: new GlyphVertexBuffer(bufferset.glyphVertex),
        iconVertex: new IconVertexBuffer(bufferset.iconVertex),
        fillVertex: new FillVertexBuffer(bufferset.fillVertex),
        fillElement: new FillElementBuffer(bufferset.fillElement),
        outlineElement: new OutlineElementBuffer(bufferset.outlineElement),
        lineVertex: new LineVertexBuffer(bufferset.lineVertex),
        lineElement: new LineElementBuffer(bufferset.lineElement)
    };
};

},{"./fillelementsbuffer.js":3,"./fillvertexbuffer.js":4,"./glyphvertexbuffer.js":5,"./iconvertexbuffer.js":6,"./lineelementbuffer.js":7,"./linevertexbuffer.js":8,"./outlineelementsbuffer.js":9}],3:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = FillElementsBuffer;

function FillElementsBuffer(buffer) {
    Buffer.call(this, buffer);
}

FillElementsBuffer.prototype = Object.create(Buffer.prototype);

FillElementsBuffer.prototype.itemSize = 6; // bytes per triangle (3 * unsigned short == 6 bytes)
FillElementsBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';

FillElementsBuffer.prototype.add = function(a, b, c) {
    var pos2 = this.pos / 2;

    this.resize();

    this.ushorts[pos2 + 0] = a;
    this.ushorts[pos2 + 1] = b;
    this.ushorts[pos2 + 2] = c;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],4:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = FillVertexBuffer;

function FillVertexBuffer(buffer) {
    Buffer.call(this, buffer);
}

FillVertexBuffer.prototype = Object.create(Buffer.prototype);

FillVertexBuffer.prototype.itemSize = 4; // bytes per vertex (2 * short == 4 bytes)

FillVertexBuffer.prototype.add = function(x, y) {
    var pos2 = this.pos / 2;

    this.resize();

    this.shorts[pos2 + 0] = x;
    this.shorts[pos2 + 1] = y;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],5:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = GlyphVertexBuffer;

function GlyphVertexBuffer(buffer) {
    Buffer.call(this, buffer);
}

GlyphVertexBuffer.prototype = Object.create(Buffer.prototype);

GlyphVertexBuffer.prototype.defaultLength = 2048 * 16;
GlyphVertexBuffer.prototype.itemSize = 16;

// Converts the 0..2pi to an int16 range
GlyphVertexBuffer.angleFactor = 128 / Math.PI;

GlyphVertexBuffer.prototype.add = function(x, y, ox, oy, tx, ty, angle, minzoom, range, maxzoom, labelminzoom) {
    var pos = this.pos,
        pos2 = pos / 2,
        angleFactor = GlyphVertexBuffer.angleFactor;

    this.resize();

    this.shorts[pos2 + 0] = x;
    this.shorts[pos2 + 1] = y;
    this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
    this.shorts[pos2 + 3] = Math.round(oy * 64);

    this.ubytes[pos + 8] = Math.floor((labelminzoom || 0) * 10);
    this.ubytes[pos + 9] = Math.floor((minzoom || 0) * 10); // 1/10 zoom levels: z16 == 160.
    this.ubytes[pos + 10] = Math.floor(Math.min(maxzoom || 25, 25) * 10); // 1/10 zoom levels: z16 == 160.
    this.ubytes[pos + 11] = Math.round(angle * angleFactor) % 256;
    this.ubytes[pos + 12] = Math.max(Math.round(range[0] * angleFactor), 0) % 256;
    this.ubytes[pos + 13] = Math.min(Math.round(range[1] * angleFactor), 255) % 256;

    this.ubytes[pos + 14] = Math.floor(tx / 4);
    this.ubytes[pos + 15] = Math.floor(ty / 4);

    this.pos += this.itemSize;
};

GlyphVertexBuffer.prototype.bind = function(gl, shader) {
    Buffer.prototype.bind.call(this, gl);

    var stride = this.itemSize;

    gl.vertexAttribPointer(shader.a_pos,    2, gl.SHORT, false, stride, 0);
    gl.vertexAttribPointer(shader.a_offset, 2, gl.SHORT, false, stride, 4);

    gl.vertexAttribPointer(shader.a_labelminzoom, 1, gl.UNSIGNED_BYTE, false, stride, 8);
    gl.vertexAttribPointer(shader.a_minzoom,      1, gl.UNSIGNED_BYTE, false, stride, 9);
    gl.vertexAttribPointer(shader.a_maxzoom,      1, gl.UNSIGNED_BYTE, false, stride, 10);
    gl.vertexAttribPointer(shader.a_angle,        1, gl.UNSIGNED_BYTE, false, stride, 11);
    gl.vertexAttribPointer(shader.a_rangeend,     1, gl.UNSIGNED_BYTE, false, stride, 12);
    gl.vertexAttribPointer(shader.a_rangestart,   1, gl.UNSIGNED_BYTE, false, stride, 13);

    gl.vertexAttribPointer(shader.a_tex, 2, gl.UNSIGNED_BYTE, false, stride, 14);
};

},{"./buffer.js":1}],6:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = GlyphVertexBuffer;

function GlyphVertexBuffer(buffer) {
    Buffer.call(this, buffer);
}

GlyphVertexBuffer.prototype = Object.create(Buffer.prototype);

GlyphVertexBuffer.prototype.defaultLength = 2048 * 20;
GlyphVertexBuffer.prototype.itemSize = 20;

// Converts the 0..2pi to an int16 range
GlyphVertexBuffer.angleFactor = 128 / Math.PI;

GlyphVertexBuffer.prototype.add = function(x, y, ox, oy, tx, ty, angle, minzoom, range, maxzoom, labelminzoom) {
    var pos = this.pos,
        pos2 = pos / 2,
        angleFactor = GlyphVertexBuffer.angleFactor;

    this.resize();

    this.shorts[pos2 + 0] = x;
    this.shorts[pos2 + 1] = y;
    this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
    this.shorts[pos2 + 3] = Math.round(oy * 64);

    this.ubytes[pos + 8] = Math.floor((labelminzoom || 0) * 10);
    this.ubytes[pos + 9] = Math.floor((minzoom || 0) * 10); // 1/10 zoom levels: z16 == 160.
    this.ubytes[pos + 10] = Math.floor(Math.min(maxzoom || 25, 25) * 10); // 1/10 zoom levels: z16 == 160.
    this.ubytes[pos + 11] = Math.round(angle * angleFactor) % 256;
    this.ubytes[pos + 12] = Math.max(Math.round(range[0] * angleFactor), 0) % 256;
    this.ubytes[pos + 13] = Math.min(Math.round(range[1] * angleFactor), 255) % 256;

    this.shorts[pos2 + 8] = tx;
    this.shorts[pos2 + 9] = ty;

    this.pos += this.itemSize;
};

GlyphVertexBuffer.prototype.bind = function(gl, shader) {
    Buffer.prototype.bind.call(this, gl);

    var stride = this.itemSize;

    gl.vertexAttribPointer(shader.a_pos,    2, gl.SHORT, false, stride, 0);
    gl.vertexAttribPointer(shader.a_offset, 2, gl.SHORT, false, stride, 4);

    gl.vertexAttribPointer(shader.a_labelminzoom, 1, gl.UNSIGNED_BYTE, false, stride, 8);
    gl.vertexAttribPointer(shader.a_minzoom,      1, gl.UNSIGNED_BYTE, false, stride, 9);
    gl.vertexAttribPointer(shader.a_maxzoom,      1, gl.UNSIGNED_BYTE, false, stride, 10);
    gl.vertexAttribPointer(shader.a_angle,        1, gl.UNSIGNED_BYTE, false, stride, 11);
    gl.vertexAttribPointer(shader.a_rangeend,     1, gl.UNSIGNED_BYTE, false, stride, 12);
    gl.vertexAttribPointer(shader.a_rangestart,   1, gl.UNSIGNED_BYTE, false, stride, 13);

    gl.vertexAttribPointer(shader.a_tex, 2, gl.SHORT, false, stride, 16);
};

},{"./buffer.js":1}],7:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = LineElementBuffer;

function LineElementBuffer(buffer) {
    Buffer.call(this, buffer);
}

LineElementBuffer.prototype = Object.create(Buffer.prototype);

LineElementBuffer.prototype.itemSize = 6; // bytes per triangle (3 * unsigned short == 6 bytes)
LineElementBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';

LineElementBuffer.prototype.add = function(a, b, c) {
    var pos2 = this.pos / 2;

    this.resize();

    this.ushorts[pos2 + 0] = a;
    this.ushorts[pos2 + 1] = b;
    this.ushorts[pos2 + 2] = c;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],8:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = LineVertexBuffer;

function LineVertexBuffer(buffer) {
    Buffer.call(this, buffer);
}

// scale the extrusion vector so that the normal length is this value.
// contains the "texture" normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
LineVertexBuffer.extrudeScale = 63;

LineVertexBuffer.prototype = Object.create(Buffer.prototype);

LineVertexBuffer.prototype.itemSize = 8; // bytes per vertex (2 * short + 1 * short + 2 * byte = 8 bytes)
LineVertexBuffer.prototype.defaultLength = 32768;

// add a vertex to this buffer;
// x, y - vertex position
// ex, ey - extrude normal
// tx, ty - texture normal

LineVertexBuffer.prototype.add = function(point, extrude, tx, ty, linesofar) {
    var pos = this.pos,
        pos2 = pos / 2,
        index = this.index,
        extrudeScale = LineVertexBuffer.extrudeScale;

    this.resize();

    this.shorts[pos2 + 0] = (Math.floor(point.x) * 2) | tx;
    this.shorts[pos2 + 1] = (Math.floor(point.y) * 2) | ty;
    this.shorts[pos2 + 2] = Math.round(linesofar || 0);
    this.bytes[pos + 6] = Math.round(extrudeScale * extrude.x);
    this.bytes[pos + 7] = Math.round(extrudeScale * extrude.y);

    this.pos += this.itemSize;
    return index;
};

},{"./buffer.js":1}],9:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = OutlineElementsBuffer;

function OutlineElementsBuffer(buffer) {
    Buffer.call(this, buffer);
}

OutlineElementsBuffer.prototype = Object.create(Buffer.prototype);

OutlineElementsBuffer.prototype.itemSize = 4; // bytes per line (2 * unsigned short == 4 bytes)
OutlineElementsBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';

OutlineElementsBuffer.prototype.add = function(a, b) {
    var pos2 = this.pos / 2;

    this.resize();

    this.ushorts[pos2 + 0] = a;
    this.ushorts[pos2 + 1] = b;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],10:[function(require,module,exports){
'use strict';

module.exports = createBucket;

var LineBucket = require('./linebucket.js');
var FillBucket = require('./fillbucket.js');
var SymbolBucket = require('./symbolbucket.js');
var RasterBucket = require('./rasterbucket.js');
var RenderProperties = require('../style/renderproperties.js');

function createBucket(layer, buffers, collision, indices) {

    if (!RenderProperties[layer.type]) {
        //console.warn('unknown bucket type');
        return;
    }

    var info = new RenderProperties[layer.type](layer.render);

    var BucketClass =
        layer.type === 'line' ? LineBucket :
        layer.type === 'fill' ? FillBucket :
        layer.type === 'symbol' ? SymbolBucket :
        layer.type === 'raster' ? RasterBucket : null;

    var bucket = new BucketClass(info, buffers, collision, indices);
    bucket.type = layer.type;
    bucket.interactive = layer.interactive;
    bucket.minZoom = layer['min-zoom'];
    bucket.maxZoom = layer['max-zoom'];

    return bucket;
}

},{"../style/renderproperties.js":52,"./fillbucket.js":13,"./linebucket.js":14,"./rasterbucket.js":15,"./symbolbucket.js":16}],11:[function(require,module,exports){
'use strict';

module.exports = ElementGroups;

function ElementGroups(vertexBuffer, elementBuffer, secondElementBuffer) {

    this.vertexBuffer = vertexBuffer;
    this.elementBuffer = elementBuffer;
    this.secondElementBuffer = secondElementBuffer;
    this.groups = [];
}

ElementGroups.prototype.makeRoomFor = function(numVertices) {
    if (!this.current || this.current.vertexLength + numVertices > 65535) {
        this.current = new ElementGroup(this.vertexBuffer.index,
                this.elementBuffer && this.elementBuffer.index,
                this.secondElementBuffer && this.secondElementBuffer.index);
        this.groups.push(this.current);
    }
};

function ElementGroup(vertexStartIndex, elementStartIndex, secondElementStartIndex)  {
    // the offset into the vertex buffer of the first vertex in this group
    this.vertexStartIndex = vertexStartIndex;
    this.elementStartIndex = elementStartIndex;
    this.secondElementStartIndex = secondElementStartIndex;
    this.elementLength = 0;
    this.vertexLength = 0;
    this.secondElementLength = 0;
}

},{}],12:[function(require,module,exports){
'use strict';

var rbush = require('rbush'),
    Point = require('point-geometry');

module.exports = FeatureTree;

function FeatureTree(getGeometry, getType) {

    this.getGeometry = getGeometry;
    this.getType = getType;

    this.rtree = rbush(9);
    this.toBeInserted = [];
}

FeatureTree.prototype.insert = function(bbox, bucket_name, feature) {
    bbox.bucket = bucket_name;
    bbox.feature = feature;
    this.toBeInserted.push(bbox);
};

// bulk insert into tree
FeatureTree.prototype._load = function() {
    this.rtree.load(this.toBeInserted);
    this.toBeInserted = [];
};

// Finds features in this tile at a particular position.
FeatureTree.prototype.query = function(args, callback) {

    if (this.toBeInserted.length) this._load();

    var radius = args.params && args.params.radius || 0;
    radius *= 4096 / args.scale;

    var x = args.x,
        y = args.y;

    var matching = this.rtree.search([ x - radius, y - radius, x + radius, y + radius ]);

    if (args.params.buckets) {
        this.queryBuckets(matching, x, y, radius, args.params, callback);
    } else {
        this.queryFeatures(matching, x, y, radius, args.params, callback);
    }
};

FeatureTree.prototype.queryFeatures = function(matching, x, y, radius, params, callback) {
    var result = [];
    for (var i = 0; i < matching.length; i++) {
        var feature = matching[i].feature;
        var type = this.getType(feature);
        var geometry = this.getGeometry(feature);


        if (params.bucket && matching[i].bucket !== params.bucket) continue;
        if (params.type && type !== params.type) continue;

        if (geometryContainsPoint(geometry, type, new Point(x, y), radius)) {
            var props = {
                _bucket: matching[i].bucket,
                _type: type
            };

            if (params.geometry) {
                props._geometry = geometry;
            }

            for (var key in feature) {
                if (feature.hasOwnProperty(key) && key[0] !== '_') {
                    props[key] = feature[key];
                }
            }
            result.push(props);
        }
    }

    callback(null, result);
};

// Lists all buckets that at the position.
FeatureTree.prototype.queryBuckets = function(matching, x, y, radius, params, callback) {
    var buckets = [];
    for (var i = 0; i < matching.length; i++) {
        if (buckets.indexOf(matching[i].bucket) >= 0) continue;

        var feature = matching[i].feature;
        var type = this.getType(feature);
        var geometry = this.getGeometry(feature);
        if (geometryContainsPoint(geometry, type, new Point(x, y), radius)) {
            buckets.push(matching[i].bucket);
        }
    }

    callback(null, buckets);
};


function geometryContainsPoint(rings, type, p, radius) {
    if (type === 'Point') {
        return pointContainsPoint(rings, p, radius);
    } else if (type === 'LineString') {
        return lineContainsPoint(rings, p, radius);
    } else if (type === 'Polygon') {
        return polyContainsPoint(rings, p) ? true : lineContainsPoint(rings, p, radius);
    } else {
        return false;
    }
}

// Code from http://stackoverflow.com/a/1501725/331379.
function distToSegmentSquared(p, v, w) {
    var l2 = v.distSqr(w);
    if (l2 === 0) return p.distSqr(v);
    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    if (t < 0) return p.distSqr(v);
    if (t > 1) return p.distSqr(w);
    return p.distSqr(w.sub(v)._mult(t)._add(v));
}

function lineContainsPoint(rings, p, radius) {
    var r = radius * radius;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
        for (var j = 1; j < ring.length; j++) {
            // Find line segments that have a distance <= radius^2 to p
            // In that case, we treat the line as "containing point p".
            var v = ring[j-1], w = ring[j];
            if (distToSegmentSquared(p, v, w) < r) return true;
        }
    }
    return false;
}

// point in polygon ray casting algorithm
function polyContainsPoint(rings, p) {
    var c = false,
        ring, p1, p2;

    for (var k = 0; k < rings.length; k++) {
        ring = rings[k];
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            if (((p1.y > p.y) != (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
    }
    return c;
}

function pointContainsPoint(rings, p, radius) {
    var r = radius * radius;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
        for (var j = 0; j < ring.length; j++) {
            if (ring[j].distSqr(p) <= r) return true;
        }
    }
    return false;
}



},{"point-geometry":95,"rbush":97}],13:[function(require,module,exports){
'use strict';

var ElementGroups = require('./elementgroups.js');

module.exports = FillBucket;

function FillBucket(info, buffers, placement, elementGroups) {
    this.info = info;
    this.buffers = buffers;
    this.elementGroups = elementGroups || new ElementGroups(buffers.fillVertex, buffers.fillElement, buffers.outlineElement);
}

FillBucket.prototype.addFeatures = function() {
    var features = this.features;
    for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        this.addFeature(feature.loadGeometry());
    }
};

FillBucket.prototype.addFeature = function(lines) {
    for (var i = 0; i < lines.length; i++) {
        this.addFill(lines[i]);
    }
};

FillBucket.prototype.addFill = function(vertices) {
    if (vertices.length < 3) {
        //console.warn('a fill must have at least three vertices');
        return;
    }

    // Calculate the total number of vertices we're going to produce so that we
    // can resize the buffer beforehand, or detect whether the current line
    // won't fit into the buffer anymore.
    // In order to be able to use the vertex buffer for drawing the antialiased
    // outlines, we separate all polygon vertices with a degenerate (out-of-
    // viewplane) vertex.

    var len = vertices.length;

    // Check whether this geometry buffer can hold all the required vertices.
    this.elementGroups.makeRoomFor(len + 1);
    var elementGroup = this.elementGroups.current;

    var fillVertex = this.buffers.fillVertex;
    var fillElement = this.buffers.fillElement;
    var outlineElement = this.buffers.outlineElement;

    // Start all lines with a degenerate vertex
    elementGroup.vertexLength++;

    // We're generating triangle fans, so we always start with the first coordinate in this polygon.
    var firstIndex = fillVertex.index - elementGroup.vertexStartIndex,
        prevIndex, currentIndex, currentVertex;

    for (var i = 0; i < vertices.length; i++) {
        currentIndex = fillVertex.index - elementGroup.vertexStartIndex;
        currentVertex = vertices[i];

        fillVertex.add(currentVertex.x, currentVertex.y);
        elementGroup.vertexLength++;

        // Only add triangles that have distinct vertices.
        if (i >= 2 && (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
            fillElement.add(firstIndex, prevIndex, currentIndex);
            elementGroup.elementLength++;
        }

        if (i >= 1) {
            outlineElement.add(prevIndex, currentIndex);
            elementGroup.secondElementLength++;
        }

        prevIndex = currentIndex;
    }
};

FillBucket.prototype.hasData = function() {
    return !!this.elementGroups.current;
};

},{"./elementgroups.js":11}],14:[function(require,module,exports){
'use strict';

var ElementGroups = require('./elementgroups.js');

module.exports = LineBucket;

function LineBucket(info, buffers, placement, elementGroups) {
    this.info = info;
    this.buffers = buffers;
    this.elementGroups = elementGroups || new ElementGroups(buffers.lineVertex, buffers.lineElement);
}

LineBucket.prototype.addFeatures = function() {
    var features = this.features;
    for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        this.addFeature(feature.loadGeometry());
    }
};

LineBucket.prototype.addFeature = function(lines) {
    var info = this.info;
    for (var i = 0; i < lines.length; i++) {
        this.addLine(lines[i], info['line-join'], info['line-cap'],
                info['line-miter-limit'], info['line-round-limit']);
    }
};

LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {
    if (vertices.length < 2) {
        //console.warn('a line must have at least two vertices');
        return;
    }

    if (join === 'bevel') miterLimit = 1.05;

    var len = vertices.length,
        firstVertex = vertices[0],
        lastVertex = vertices[len - 1],
        closed = firstVertex.equals(lastVertex);

    var lineVertex = this.buffers.lineVertex;
    var lineElement = this.buffers.lineElement;

    // we could be more precies, but it would only save a negligible amount of space
    this.elementGroups.makeRoomFor(len * 4);
    var elementGroup = this.elementGroups.current;
    var vertexStartIndex = elementGroup.vertexStartIndex;

    if (len == 2 && closed) {
        // console.warn('a line may not have coincident points');
        return;
    }

    var beginCap = cap,
        endCap = closed ? 'butt' : cap,
        flip = 1,
        distance = 0,
        currentVertex, prevVertex,  nextVertex, prevNormal,  nextNormal;

    // the last three vertices added
    var e1, e2, e3;

    if (closed) {
        currentVertex = vertices[len - 2];
        nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
    }

    for (var i = 0; i < len; i++) {

        nextVertex = closed && i === len - 1 ?
            vertices[1] : // if the line is closed, we treat the last vertex like the first
            vertices[i + 1]; // just the next vertex

        // if two consecutive vertices exist, skip the current one
        if (nextVertex && vertices[i].equals(nextVertex)) continue;

        if (nextNormal) prevNormal = nextNormal;
        if (currentVertex) prevVertex = currentVertex;

        currentVertex = vertices[i];

        // Calculate how far along the line the currentVertex is
        if (prevVertex) distance += currentVertex.dist(prevVertex);

        // Calculate the normal towards the next vertex in this line. In case
        // there is no next vertex, pretend that the line is continuing straight,
        // meaning that we are just using the previous normal.
        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;

        // If we still don't have a previous normal, this is the beginning of a
        // non-closed line, so we're doing a straight "join".
        prevNormal = prevNormal || nextNormal;

        // Determine the normal of the join extrusion. It is the angle bisector
        // of the segments between the previous line and the next line.
        var joinNormal = prevNormal.add(nextNormal)._unit();

        /*  joinNormal     prevNormal
         *             ↖      ↑
         *                .________. prevVertex
         *                |
         * nextNormal  ←  |  currentVertex
         *                |
         *     nextVertex !
         *
         */

        // Calculate the length of the miter (the ratio of the miter to the width).
        // Find the cosine of the angle between the next and join normals
        // using dot product. The inverse of that is the miter length.
        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
        var miterLength = 1 / cosHalfAngle;

        // Whether any vertices have been
        var startOfLine = e1 === undefined || e2 === undefined;

        // The join if a middle vertex, otherwise the cap.
        var middleVertex = prevVertex && nextVertex;
        var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

        if (middleVertex && currentJoin === 'round' && miterLength < roundLimit) {
            currentJoin = 'miter';
        }

        if (currentJoin === 'miter' && miterLength > miterLimit) {
            currentJoin = 'bevel';
        }

        if (currentJoin === 'bevel') {
            // The maximum extrude length is 63 / 256 = 4 times the width of the line
            // so if miterLength >= 4 we need to draw a different type of bevel where.
            if (miterLength > 4) currentJoin = 'flipbevel';

            // If the miterLength is really small and the line bevel wouldn't be visible,
            // just draw a miter join to save a triangle.
            if (miterLength < miterLimit) currentJoin = 'miter';
        }

        // Mitered joins
        if (currentJoin === 'miter') {
            // scale the unit vector by the miter length
            joinNormal._mult(miterLength);
            addCurrentVertex(joinNormal, 0, 0, false);

        } else if (currentJoin === 'flipbevel') {
            // miter is too big, flip the direction to make a beveled join

            if (miterLength > 100) {
                // Almost parallel lines
                flip = -flip;
                joinNormal = nextNormal;

            } else {
                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                joinNormal._perp()._mult(flip * bevelLength);
                flip = -flip;
            }
            addCurrentVertex(joinNormal, 0, 0, false);

        // All other types of joins
        } else {

            var offsetA, offsetB;
            if (currentJoin === 'bevel') {
                var dir = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;
                var offset = -Math.sqrt(miterLength * miterLength - 1);
                if (flip * dir > 0) {
                    offsetB = 0;
                    offsetA = offset;
                } else {
                    offsetA = 0;
                    offsetB = offset;
                }
            } else if (currentJoin === 'square') {
                offsetA = offsetB = 1;
            } else {
                offsetA = offsetB = 0;
            }

            // Close previous segment with a butt or a square cap or bevel
            if (!startOfLine) {
                addCurrentVertex(prevNormal, offsetA, offsetB, false);
            }

            // Add round cap or linejoin at end of segment
            if (!startOfLine && currentJoin === 'round') {
                addCurrentVertex(prevNormal, 1, 1, true);
            }

            // Segment include cap are done, unset vertices to disconnect segments.
            // Or leave them to create a bevel.
            if (startOfLine || currentJoin !== 'bevel') {
                e1 = e2 = -1;
                flip = 1;
            }

            // Add round cap before first segment
            if (startOfLine && beginCap === 'round') {
                addCurrentVertex(nextNormal, -1, -1, true);
            }

            // Start next segment with a butt or square cap or bevel
            if (nextVertex) {
                addCurrentVertex(nextNormal, -offsetA, -offsetB, false);
            }
        }

    }


    /*
     * Adds two vertices to the buffer that are
     * normal and -normal from the currentVertex.
     *
     * endBox moves the extrude one unit in the direction of the line
     * to create square or round cap.
     *
     * endLeft and endRight shifts the extrude along the line
     * endLeft === 1 moves the extrude in the direction of the line
     * endLeft === -1 moves the extrude in the reverse direction
     */
    function addCurrentVertex(normal, endLeft, endRight, round) {

        var tx = round ? 1 : 0;
        var extrude;

        extrude = normal.mult(flip);
        if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
        e3 = lineVertex.add(currentVertex, extrude, tx, 0, distance) - vertexStartIndex;
        if (e1 >= 0 && e2 >= 0) {
            lineElement.add(e1, e2, e3);
            elementGroup.elementLength++;
        }
        e1 = e2;
        e2 = e3;

        extrude = normal.mult(-flip);
        if (endRight) extrude._sub(normal.perp()._mult(endRight));
        e3 = lineVertex.add(currentVertex, extrude, tx, 1, distance) - vertexStartIndex;
        if (e1 >= 0 && e2 >= 0) {
            lineElement.add(e1, e2, e3);
            elementGroup.elementLength++;
        }
        e1 = e2;
        e2 = e3;

        elementGroup.vertexLength += 2;
    }
};

LineBucket.prototype.hasData = function() {
    return !!this.elementGroups.current;
};

},{"./elementgroups.js":11}],15:[function(require,module,exports){
'use strict';

module.exports = RasterBucket;

function RasterBucket(info) {
    this.info = info;
}

},{}],16:[function(require,module,exports){
'use strict';

var ElementGroups = require('./elementgroups.js');
var Anchor = require('../symbol/anchor.js');
var interpolate = require('../symbol/interpolate.js');
var Point = require('point-geometry');
var resolveTokens = require('../util/token.js');
var Placement = require('../symbol/placement.js');
var Shaping = require('../symbol/shaping.js');
var resolveText = require('../symbol/resolvetext.js');

module.exports = SymbolBucket;

var fullRange = [2 * Math.PI , 0];

function SymbolBucket(info, buffers, collision, elementGroups) {
    this.info = info;
    this.buffers = buffers;
    this.collision = collision;

    if (info['symbol-placement'] === 'line') {
        if (!info.hasOwnProperty('text-rotation-alignment')) {
            info['text-rotation-alignment'] = 'map';
        }
        if (!info.hasOwnProperty('icon-rotation-alignment')) {
            info['icon-rotation-alignment'] = 'map';
        }

        info['symbol-avoid-edges'] = true;
    }

    if (elementGroups) {
        this.elementGroups = elementGroups;
    } else {
        this.elementGroups = {
            text: new ElementGroups(buffers.glyphVertex),
            icon: new ElementGroups(buffers.iconVertex)
        };
    }
}

SymbolBucket.prototype.addFeatures = function() {
    var info = this.info;
    var features = this.features;
    var textFeatures = this.textFeatures;

    var horizontalAlign = 0.5;
    if (info['text-horizontal-align'] === 'right') horizontalAlign = 1;
    else if (info['text-horizontal-align'] === 'left') horizontalAlign = 0;

    var verticalAlign = 0.5;
    if (info['text-vertical-align'] === 'bottom') verticalAlign = 1;
    else if (info['text-vertical-align'] === 'top') verticalAlign = 0;

    var justify = 0.5;
    if (info['text-justify'] === 'right') justify = 1;
    else if (info['text-justify'] === 'left') justify = 0;

    var oneEm = 24;
    var lineHeight = info['text-line-height'] * oneEm;
    var maxWidth = info['symbol-placement'] !== 'line' && info['text-max-width'] * oneEm;
    var spacing = info['text-letter-spacing'] * oneEm;
    var fontstack = info['text-font'];
    var textOffset = [info['text-offset'][0] * oneEm, info['text-offset'][1] * oneEm];

    for (var k = 0; k < features.length; k++) {

        var feature = features[k];
        var text = textFeatures[k];
        var lines = feature.loadGeometry();

        var shaping = false;
        if (text) {
            shaping = Shaping.shape(text, fontstack, this.stacks, maxWidth,
                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
        }

        var image = false;
        if (this.sprite && this.info['icon-image']) {
            image = this.sprite[resolveTokens(feature.properties, info['icon-image'])];

            if (image) {
                // match glyph tex object. TODO change
                image.w = image.width;
                image.h = image.height;

                if (image.sdf) this.elementGroups.sdfIcons = true;
            }
        }

        if (!shaping && !image) continue;
        this.addFeature(lines, this.stacks, shaping, image);
    }
};

function byScale(a, b) {
    return a.scale - b.scale;
}

SymbolBucket.prototype.addFeature = function(lines, faces, shaping, image) {
    var info = this.info;
    var collision = this.collision;

    var minScale = 0.5;
    var glyphSize = 24;

    var horizontalText = info['text-rotation-alignment'] === 'viewport',
        horizontalIcon = info['icon-rotation-alignment'] === 'viewport',
        fontScale = info['text-max-size'] / glyphSize,
        textBoxScale = collision.tilePixelRatio * fontScale,
        iconBoxScale = collision.tilePixelRatio * info['icon-max-size'],
        iconWithoutText = info['text-optional'] || !shaping,
        textWithoutIcon = info['icon-optional'] || !image,
        avoidEdges = info['symbol-avoid-edges'];

    for (var i = 0; i < lines.length; i++) {

        var line = lines[i];
        var anchors;

        if (info['symbol-placement'] === 'line') {
            // Line labels
            anchors = interpolate(line, info['symbol-min-distance'], minScale, collision.maxPlacementScale, collision.tilePixelRatio);

            // Sort anchors by segment so that we can start placement with the
            // anchors that can be shown at the lowest zoom levels.
            anchors.sort(byScale);

        } else {
            // Point labels
            anchors = [new Anchor(line[0].x, line[0].y, 0, minScale)];
        }


        // TODO: figure out correct ascender height.
        var origin = new Point(0, -17);

        for (var j = 0, len = anchors.length; j < len; j++) {
            var anchor = anchors[j];
            var inside = !(anchor.x < 0 || anchor.x > 4096 || anchor.y < 0 || anchor.y > 4096);

            if (avoidEdges && !inside) continue;

            // Calculate the scales at which the text and icons can be first shown without overlap
            var glyph;
            var icon;
            var glyphScale = null;
            var iconScale = null;

            if (shaping) {
                glyph = Placement.getGlyphs(anchor, origin, shaping, faces, textBoxScale, horizontalText, line, info);
                glyphScale = info['text-allow-overlap'] ? glyph.minScale
                    : collision.getPlacementScale(glyph.boxes, glyph.minScale, avoidEdges);
                if (!glyphScale && !iconWithoutText) continue;
            }

            if (image) {
                icon = Placement.getIcon(anchor, image, iconBoxScale, line, info);
                iconScale = info['icon-allow-overlap'] ? icon.minScale
                    : collision.getPlacementScale(icon.boxes, icon.minScale, avoidEdges);
                if (!iconScale && !textWithoutIcon) continue;
            }

            if (!iconWithoutText && !textWithoutIcon) {
                iconScale = glyphScale = Math.max(iconScale, glyphScale);
            } else if (!textWithoutIcon && glyphScale) {
                glyphScale = Math.max(iconScale, glyphScale);
            } else if (!iconWithoutText && iconScale) {
                iconScale = Math.max(iconScale, glyphScale);
            }

            // Get the rotation ranges it is safe to show the glyphs
            var glyphRange = (!glyphScale || info['text-allow-overlap']) ? fullRange
                : collision.getPlacementRange(glyph.boxes, glyphScale, horizontalText);
            var iconRange = (!iconScale || info['icon-allow-overlap']) ? fullRange
                : collision.getPlacementRange(icon.boxes, iconScale, horizontalIcon);

            var maxRange = [
                Math.min(iconRange[0], glyphRange[0]),
                Math.max(iconRange[1], glyphRange[1])];

            if (!iconWithoutText && !textWithoutIcon) {
                iconRange = glyphRange = maxRange;
            } else if (!textWithoutIcon) {
                glyphRange = maxRange;
            } else if (!iconWithoutText) {
                iconRange = maxRange;
            }

            // Insert final placement into collision tree and add glyphs/icons to buffers
            if (glyphScale) {
                if (!info['text-ignore-placement']) {
                    collision.insert(glyph.boxes, anchor, glyphScale, glyphRange, horizontalText);
                }
                if (inside) this.addSymbols(this.buffers.glyphVertex, this.elementGroups.text, glyph.shapes, glyphScale, glyphRange);
            }

            if (iconScale) {
                if (!info['icon-ignore-placement']) {
                    collision.insert(icon.boxes, anchor, iconScale, iconRange, horizontalIcon);
                }
                if (inside) this.addSymbols(this.buffers.iconVertex, this.elementGroups.icon, icon.shapes, iconScale, iconRange);
            }

        }
    }
};

SymbolBucket.prototype.addSymbols = function(buffer, elementGroups, symbols, scale, placementRange) {

    var zoom = this.collision.zoom;

    elementGroups.makeRoomFor(0);
    var elementGroup = elementGroups.current;

    var placementZoom = Math.log(scale) / Math.LN2 + zoom;

    for (var k = 0; k < symbols.length; k++) {

        var symbol = symbols[k],
            tl = symbol.tl,
            tr = symbol.tr,
            bl = symbol.bl,
            br = symbol.br,
            tex = symbol.tex,
            angle = symbol.angle,
            anchor = symbol.anchor,


            minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
            maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);

        if (maxZoom <= minZoom) continue;

        // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
        if (minZoom === placementZoom) minZoom = 0;

        // first triangle
        buffer.add(anchor.x, anchor.y, tl.x, tl.y, tex.x, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
        buffer.add(anchor.x, anchor.y, tr.x, tr.y, tex.x + tex.w, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
        buffer.add(anchor.x, anchor.y, bl.x, bl.y, tex.x, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);

        // second triangle
        buffer.add(anchor.x, anchor.y, tr.x, tr.y, tex.x + tex.w, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
        buffer.add(anchor.x, anchor.y, bl.x, bl.y, tex.x, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);
        buffer.add(anchor.x, anchor.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);

        elementGroup.vertexLength += 6;
    }

};

SymbolBucket.prototype.getDependencies = function(tile, actor, callback) {
    var firstdone = false;
    var firsterr;
    this.getTextDependencies(tile, actor, done);
    this.getIconDependencies(tile, actor, done);
    function done(err) {
        if (err || firstdone) callback(err);
        firstdone = true;
        firsterr = err;
    }
};

SymbolBucket.prototype.getIconDependencies = function(tile, actor, callback) {
    var bucket = this;
    if (this.info['icon-image']) {
        if (SymbolBucket.sprite) {
            this.sprite = SymbolBucket.sprite;
            callback();
        } else {
            actor.send('get sprite json', {}, function(err, data) {
                SymbolBucket.sprite = bucket.sprite = data.sprite;
                callback(err);
            });
        }
    } else {
        callback();
    }
};

SymbolBucket.prototype.getTextDependencies = function(tile, actor, callback) {
    var features = this.features;
    var info = this.info;

    if (tile.stacks === undefined) tile.stacks = {};
    var stacks = this.stacks = tile.stacks;
    var fontstack = info['text-font'];
    if (stacks[fontstack] === undefined) {
        stacks[fontstack] = { glyphs: {}, rects: {} };
    }
    var stack = stacks[fontstack];

    var data = resolveText(features, info, stack.glyphs);
    this.textFeatures = data.textFeatures;

    actor.send('get glyphs', {
        id: tile.id,
        fontstack: fontstack,
        codepoints: data.codepoints
    }, function(err, newstack) {
        if (err) return callback(err);

        var newglyphs = newstack.glyphs;
        var newrects = newstack.rects;
        var glyphs = stack.glyphs;
        var rects = stack.rects;

        for (var codepoint in newglyphs) {
            glyphs[codepoint] = newglyphs[codepoint];
            rects[codepoint] = newrects[codepoint];
        }

        callback();
    });
};

SymbolBucket.prototype.hasData = function() {
    return !!this.elementGroups.text.current || !!this.elementGroups.icon.current;
};

},{"../symbol/anchor.js":57,"../symbol/interpolate.js":62,"../symbol/placement.js":63,"../symbol/resolvetext.js":64,"../symbol/shaping.js":66,"../util/token.js":86,"./elementgroups.js":11,"point-geometry":95}],17:[function(require,module,exports){
'use strict';

module.exports = LatLng;

function LatLng(lat, lng) {
    if (isNaN(lat) || isNaN(lng)) {
        throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    }
    this.lat = +lat;
    this.lng = +lng;
}


// constructs LatLng from an array if necessary

LatLng.convert = function (a) {
    if (a instanceof LatLng) {
        return a;
    }
    if (Array.isArray(a)) {
        return new LatLng(a[0], a[1]);
    }
    return a;
};

},{}],18:[function(require,module,exports){
'use strict';

module.exports = LatLngBounds;

var LatLng = require('./latlng.js');

function LatLngBounds(sw, ne) {
    if (!sw) return;

    var latlngs = ne ? [sw, ne] : sw;

    for (var i = 0, len = latlngs.length; i < len; i++) {
        this.extend(latlngs[i]);
    }
}

LatLngBounds.prototype = {

    // extend the bounds to contain the given point or bounds
    extend: function (obj) {
        var sw = this._sw,
            ne = this._ne,
            sw2, ne2;

        if (obj instanceof LatLng) {
            sw2 = obj;
            ne2 = obj;

        } else if (obj instanceof LatLngBounds) {
            sw2 = obj._sw;
            ne2 = obj._ne;

            if (!sw2 || !ne2) return this;

        } else {
            return obj ? this.extend(LatLng.convert(obj) || LatLngBounds.convert(obj)) : this;
        }

        if (!sw && !ne) {
            this._sw = new LatLng(sw2.lat, sw2.lng);
            this._ne = new LatLng(ne2.lat, ne2.lng);

        } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
        }

        return this;
    },

    getCenter: function () {
        return new LatLng((this._sw.lat + this._ne.lat) / 2, (this._sw.lng + this._ne.lng) / 2);
    },

    getSouthWest: function () { return this._sw; },
    getNorthEast: function () { return this._ne; },
    getNorthWest: function () { return new LatLng(this.getNorth(), this.getWest()); },
    getSouthEast: function () { return new LatLng(this.getSouth(), this.getEast()); },

    getWest:  function () { return this._sw.lng; },
    getSouth: function () { return this._sw.lat; },
    getEast:  function () { return this._ne.lng; },
    getNorth: function () { return this._ne.lat; }
};

// constructs LatLngBounds from an array if necessary
LatLngBounds.convert = function (a) {
    if (!a || a instanceof LatLngBounds) return a;
    return new LatLngBounds(a);
};

},{"./latlng.js":17}],19:[function(require,module,exports){
'use strict';

var LatLng = require('./latlng.js'),
    Point = require('point-geometry');

module.exports = Transform;

// A single transform, generally used for a single tile to be scaled, rotated, and zoomed.

function Transform(minZoom, maxZoom) {
    this.tileSize = 512; // constant

    this._minZoom = minZoom || 0;
    this._maxZoom = maxZoom || 22;

    this.latRange = [-85.05113, 85.05113];

    this.width = 0;
    this.height = 0;
    this.zoom = 0;
    this.center = new LatLng(0, 0);
    this.angle = 0;
}

Transform.prototype = {
    get minZoom() { return this._minZoom; },
    set minZoom(zoom) {
        this._minZoom = zoom;
        this.zoom = Math.max(this.zoom, zoom);
    },

    get maxZoom() { return this._maxZoom; },
    set maxZoom(zoom) {
        this._maxZoom = zoom;
        this.zoom = Math.min(this.zoom, zoom);
    },

    get worldSize() {
        return this.tileSize * this.scale;
    },

    get centerPoint() {
        return this.size._div(2);
    },

    get size() {
        return new Point(this.width, this.height);
    },

    get bearing() {
        return -this.angle / Math.PI * 180;
    },
    set bearing(bearing) {
        // confine the angle to within [-180,180]
        bearing = ((((bearing + 180) % 360) + 360) % 360) - 180;
        this.angle = -bearing * Math.PI / 180;
    },

    get zoom() { return this._zoom; },
    set zoom(zoom) {
        zoom = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
        this._zoom = zoom;
        this.scale = this.zoomScale(zoom);
        this.tileZoom = Math.floor(zoom);
        this.zoomFraction = zoom - this.tileZoom;
        this._constrain();
    },

    zoomScale: function(zoom) { return Math.pow(2, zoom); },
    scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },

    project: function(latlng, worldSize) {
        return new Point(
            this.lngX(latlng.lng, worldSize),
            this.latY(latlng.lat, worldSize));
    },

    unproject: function(point, worldSize) {
        return new LatLng(
            this.yLat(point.y, worldSize),
            this.xLng(point.x, worldSize));
    },

    get x() { return this.lngX(this.center.lng); },
    get y() { return this.latY(this.center.lat); },

    get point() { return new Point(this.x, this.y); },

    // lat/lon <-> absolute pixel coords convertion
    lngX: function(lon, worldSize) {
        return (180 + lon) * (worldSize || this.worldSize) / 360;
    },
    // latitude to absolute y coord
    latY: function(lat, worldSize) {
        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
        return (180 - y) * (worldSize || this.worldSize) / 360;
    },

    xLng: function(x, worldSize) {
        return x * 360 / (worldSize || this.worldSize) - 180;
    },
    yLat: function(y, worldSize) {
        var y2 = 180 - y * 360 / (worldSize || this.worldSize);
        return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    },

    panBy: function(offset) {
        var point = this.centerPoint._add(offset);
        this.center = this.pointLocation(point);
        this._constrain();
    },

    setZoomAround: function(zoom, center) {
        var p = this.locationPoint(center),
            p1 = this.size._sub(p),
            latlng = this.pointLocation(p1);
        this.zoom = zoom;
        this.panBy(p1.sub(this.locationPoint(latlng)));
    },

    setBearingAround: function(bearing, center) {
        var offset = this.locationPoint(center).sub(this.centerPoint);
        this.panBy(offset);
        this.bearing = bearing;
        this.panBy(offset.mult(-1));
    },

    locationPoint: function(latlng) {
        var p = this.project(latlng);
        return this.centerPoint._sub(this.point._sub(p)._rotate(this.angle));
    },

    pointLocation: function(p) {
        var p2 = this.centerPoint._sub(p)._rotate(-this.angle);
        return this.unproject(this.point.sub(p2));
    },

    locationCoordinate: function(latlng) {
        var k = this.zoomScale(this.tileZoom) / this.worldSize;
        return {
            column: this.lngX(latlng.lng) * k,
            row: this.latY(latlng.lat) * k,
            zoom: this.tileZoom
        };
    },

    pointCoordinate: function(tileCenter, p) {
        var zoomFactor = this.zoomScale(this.zoomFraction),
            kt = this.zoomScale(this.tileZoom - tileCenter.zoom),
            p2 = this.centerPoint._sub(p)._rotate(-this.angle)._div(this.tileSize * zoomFactor);

        return {
            column: tileCenter.column * kt - p2.x,
            row: tileCenter.row * kt - p2.y,
            zoom: this.tileZoom
        };
    },

    _constrain: function() {
        if (!this.center) return;

        var minY, maxY, minX, maxX, sy, sx, x2, y2,
            size = this.size;

        if (this.latRange) {
            minY = this.latY(this.latRange[1]);
            maxY = this.latY(this.latRange[0]);
            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
        }

        if (this.lngRange) {
            minX = this.lngX(this.lngRange[0]);
            maxX = this.lngX(this.lngRange[1]);
            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
        }

        // how much the map should scale to fit the screen into given latitude/longitude ranges
        var s = Math.max(sx || 0, sy || 0);

        if (s) {
            this.center = this.unproject(new Point(
                sx ? (maxX + minX) / 2 : this.x,
                sy ? (maxY + minY) / 2 : this.y));
            this.zoom += this.scaleZoom(s);
            return;
        }

        if (this.latRange) {
            var y = this.y,
                h2 = size.y / 2;

            if (y - h2 < minY) y2 = minY + h2;
            if (y + h2 > maxY) y2 = maxY - h2;
        }

        if (this.lngRange) {
            var x = this.x,
                w2 = size.x / 2;

            if (x - w2 < minX) x2 = minX + w2;
            if (x + w2 > maxX) x2 = maxX - w2;
        }

        // pan the map if the screen goes off the range
        if (x2 !== undefined || y2 !== undefined) {
            this.center = this.unproject(new Point(
                x2 !== undefined ? x2 : this.x,
                y2 !== undefined ? y2 : this.y));
        }
    }
};

},{"./latlng.js":17,"point-geometry":95}],20:[function(require,module,exports){
// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
var simplex_font = {
    " ": [16, []],
    "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "\"": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
    "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
    "$": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
    "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
    "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
    "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
    ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
    "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
    "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
    ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "-": [26, [4, 9, 22, 9]],
    ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "/": [22, [20, 25, 2, -7]],
    "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
    "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
    "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
    "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "4": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
    "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
    "7": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
    "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
    "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
    ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "<": [24, [20, 18, 4, 9, 20, 0]],
    "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
    ">": [24, [4, 18, 20, 9, 4, 0]],
    "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
    "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
    "A": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
    "B": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
    "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
    "D": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
    "E": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
    "F": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
    "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
    "H": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
    "I": [8, [4, 21, 4, 0]],
    "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
    "K": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
    "L": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
    "M": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
    "N": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
    "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
    "P": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
    "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
    "R": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
    "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "T": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
    "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
    "V": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
    "W": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
    "X": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
    "Y": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
    "Z": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
    "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
    "\\": [14, [0, 21, 14, -3]],
    "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
    "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
    "_": [16, [0, -2, 16, -2]],
    "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
    "a": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "b": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "d": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
    "g": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "h": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
    "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
    "k": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
    "l": [8, [4, 21, 4, 0]],
    "m": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
    "n": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
    "p": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "q": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "r": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
    "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
    "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
    "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
    "v": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
    "w": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
    "x": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
    "y": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
    "z": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
    "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
    "|": [8, [4, 25, 4, -7]],
    "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
    "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]],
};

module.exports = function textVertices(text, left, baseline, scale) {
    scale = scale || 1;

    var strokes = [],
        i, len, j, len2, glyph, data, x, y, prev;

    for (i = 0, len = text.length; i < len; i++) {
        glyph = simplex_font[text[i]];
        if (!glyph) continue;
        prev = null;

        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
                prev = null;

            } else {
                x = left + glyph[1][j] * scale;
                y = baseline - glyph[1][j + 1] * scale;
                if (prev) {
                    strokes.push(prev.x, prev.y, x, y);
                }
                prev = {x: x, y: y};
            }
        }
        left += glyph[0] * scale;
    }

    return strokes;
};

},{}],21:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.0
 */
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
(function(e){"use strict";var t={};typeof exports=="undefined"?typeof define=="function"&&typeof define.amd=="object"&&define.amd?(t.exports={},define(function(){return t.exports})):t.exports=typeof window!="undefined"?window:e:t.exports=exports,function(e){if(!t)var t=1e-6;if(!n)var n=typeof Float32Array!="undefined"?Float32Array:Array;if(!r)var r=Math.random;var i={};i.setMatrixArrayType=function(e){n=e},typeof e!="undefined"&&(e.glMatrix=i);var s={};s.create=function(){var e=new n(2);return e[0]=0,e[1]=0,e},s.clone=function(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t},s.fromValues=function(e,t){var r=new n(2);return r[0]=e,r[1]=t,r},s.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e},s.set=function(e,t,n){return e[0]=t,e[1]=n,e},s.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e},s.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e},s.sub=s.subtract,s.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e},s.mul=s.multiply,s.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e},s.div=s.divide,s.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e},s.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e},s.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e},s.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e},s.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)},s.dist=s.distance,s.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r},s.sqrDist=s.squaredDistance,s.length=function(e){var t=e[0],n=e[1];return Math.sqrt(t*t+n*n)},s.len=s.length,s.squaredLength=function(e){var t=e[0],n=e[1];return t*t+n*n},s.sqrLen=s.squaredLength,s.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e},s.normalize=function(e,t){var n=t[0],r=t[1],i=n*n+r*r;return i>0&&(i=1/Math.sqrt(i),e[0]=t[0]*i,e[1]=t[1]*i),e},s.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]},s.cross=function(e,t,n){var r=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=r,e},s.lerp=function(e,t,n,r){var i=t[0],s=t[1];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e},s.random=function(e,t){t=t||1;var n=r()*2*Math.PI;return e[0]=Math.cos(n)*t,e[1]=Math.sin(n)*t,e},s.transformMat2=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i,e[1]=n[1]*r+n[3]*i,e},s.transformMat2d=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i+n[4],e[1]=n[1]*r+n[3]*i+n[5],e},s.transformMat3=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[3]*i+n[6],e[1]=n[1]*r+n[4]*i+n[7],e},s.transformMat4=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[4]*i+n[12],e[1]=n[1]*r+n[5]*i+n[13],e},s.forEach=function(){var e=s.create();return function(t,n,r,i,s,o){var u,a;n||(n=2),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],s(e,e,o),t[u]=e[0],t[u+1]=e[1];return t}}(),s.str=function(e){return"vec2("+e[0]+", "+e[1]+")"},typeof e!="undefined"&&(e.vec2=s);var o={};o.create=function(){var e=new n(3);return e[0]=0,e[1]=0,e[2]=0,e},o.clone=function(e){var t=new n(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},o.fromValues=function(e,t,r){var i=new n(3);return i[0]=e,i[1]=t,i[2]=r,i},o.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},o.set=function(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e},o.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e},o.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e},o.sub=o.subtract,o.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e},o.mul=o.multiply,o.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e},o.div=o.divide,o.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e},o.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e},o.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e},o.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e},o.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(n*n+r*r+i*i)},o.dist=o.distance,o.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return n*n+r*r+i*i},o.sqrDist=o.squaredDistance,o.length=function(e){var t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)},o.len=o.length,o.squaredLength=function(e){var t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r},o.sqrLen=o.squaredLength,o.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},o.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s>0&&(s=1/Math.sqrt(s),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s),e},o.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},o.cross=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2];return e[0]=i*a-s*u,e[1]=s*o-r*a,e[2]=r*u-i*o,e},o.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e},o.random=function(e,t){t=t||1;var n=r()*2*Math.PI,i=r()*2-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},o.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12],e[1]=n[1]*r+n[5]*i+n[9]*s+n[13],e[2]=n[2]*r+n[6]*i+n[10]*s+n[14],e},o.transformMat3=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=r*n[0]+i*n[3]+s*n[6],e[1]=r*n[1]+i*n[4]+s*n[7],e[2]=r*n[2]+i*n[5]+s*n[8],e},o.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},o.forEach=function(){var e=o.create();return function(t,n,r,i,s,o){var u,a;n||(n=3),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2];return t}}(),o.str=function(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"},typeof e!="undefined"&&(e.vec3=o);var u={};u.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e},u.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},u.fromValues=function(e,t,r,i){var s=new n(4);return s[0]=e,s[1]=t,s[2]=r,s[3]=i,s},u.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},u.set=function(e,t,n,r,i){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e},u.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e},u.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e},u.sub=u.subtract,u.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e[3]=t[3]*n[3],e},u.mul=u.multiply,u.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e[3]=t[3]/n[3],e},u.div=u.divide,u.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e[3]=Math.min(t[3],n[3]),e},u.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e[3]=Math.max(t[3],n[3]),e},u.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e},u.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e},u.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return Math.sqrt(n*n+r*r+i*i+s*s)},u.dist=u.distance,u.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return n*n+r*r+i*i+s*s},u.sqrDist=u.squaredDistance,u.length=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)},u.len=u.length,u.squaredLength=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i},u.sqrLen=u.squaredLength,u.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e},u.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=t[3]*o),e},u.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},u.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e[3]=u+r*(n[3]-u),e},u.random=function(e,t){return t=t||1,e[0]=r(),e[1]=r(),e[2]=r(),e[3]=r(),u.normalize(e,e),u.scale(e,e,t),e},u.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12]*o,e[1]=n[1]*r+n[5]*i+n[9]*s+n[13]*o,e[2]=n[2]*r+n[6]*i+n[10]*s+n[14]*o,e[3]=n[3]*r+n[7]*i+n[11]*s+n[15]*o,e},u.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},u.forEach=function(){var e=u.create();return function(t,n,r,i,s,o){var u,a;n||(n=4),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],e[3]=t[u+3],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2],t[u+3]=e[3];return t}}(),u.str=function(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.vec4=u);var a={};a.create=function(){var e=new n(4);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},a.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},a.transpose=function(e,t){if(e===t){var n=t[1];e[1]=t[2],e[2]=n}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e},a.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*s-i*r;return o?(o=1/o,e[0]=s*o,e[1]=-r*o,e[2]=-i*o,e[3]=n*o,e):null},a.adjoint=function(e,t){var n=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=n,e},a.determinant=function(e){return e[0]*e[3]-e[2]*e[1]},a.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*u+i*f,e[1]=r*a+i*l,e[2]=s*u+o*f,e[3]=s*a+o*l,e},a.mul=a.multiply,a.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=r*-u+i*a,e[2]=s*a+o*u,e[3]=s*-u+o*a,e},a.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1];return e[0]=r*u,e[1]=i*a,e[2]=s*u,e[3]=o*a,e},a.str=function(e){return"mat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.mat2=a);var f={};f.create=function(){var e=new n(6);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},f.clone=function(e){var t=new n(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},f.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},f.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},f.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=n*s-r*i;return a?(a=1/a,e[0]=s*a,e[1]=-r*a,e[2]=-i*a,e[3]=n*a,e[4]=(i*u-s*o)*a,e[5]=(r*o-n*u)*a,e):null},f.determinant=function(e){return e[0]*e[3]-e[1]*e[2]},f.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1],c=n[2],h=n[3],p=n[4],d=n[5];return e[0]=r*f+i*c,e[1]=r*l+i*h,e[2]=s*f+o*c,e[3]=s*l+o*h,e[4]=f*u+c*a+p,e[5]=l*u+h*a+d,e},f.mul=f.multiply,f.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=Math.sin(n),l=Math.cos(n);return e[0]=r*l+i*f,e[1]=-r*f+i*l,e[2]=s*l+o*f,e[3]=-s*f+l*o,e[4]=l*u+f*a,e[5]=l*a-f*u,e},f.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=t[0]*r,e[1]=t[1]*i,e[2]=t[2]*r,e[3]=t[3]*i,e[4]=t[4]*r,e[5]=t[5]*i,e},f.translate=function(e,t,n){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4]+n[0],e[5]=t[5]+n[1],e},f.str=function(e){return"mat2d("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+")"},typeof e!="undefined"&&(e.mat2d=f);var l={};l.create=function(){var e=new n(9);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},l.fromMat4=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e},l.clone=function(e){var t=new n(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},l.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},l.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},l.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e},l.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=l*o-u*f,h=-l*s+u*a,p=f*s-o*a,d=n*c+r*h+i*p;return d?(d=1/d,e[0]=c*d,e[1]=(-l*r+i*f)*d,e[2]=(u*r-i*o)*d,e[3]=h*d,e[4]=(l*n-i*a)*d,e[5]=(-u*n+i*s)*d,e[6]=p*d,e[7]=(-f*n+r*a)*d,e[8]=(o*n-r*s)*d,e):null},l.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8];return e[0]=o*l-u*f,e[1]=i*f-r*l,e[2]=r*u-i*o,e[3]=u*a-s*l,e[4]=n*l-i*a,e[5]=i*s-n*u,e[6]=s*f-o*a,e[7]=r*a-n*f,e[8]=n*o-r*s,e},l.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8];return t*(f*s-o*a)+n*(-f*i+o*u)+r*(a*i-s*u)},l.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8];return e[0]=h*r+p*o+d*f,e[1]=h*i+p*u+d*l,e[2]=h*s+p*a+d*c,e[3]=v*r+m*o+g*f,e[4]=v*i+m*u+g*l,e[5]=v*s+m*a+g*c,e[6]=y*r+b*o+w*f,e[7]=y*i+b*u+w*l,e[8]=y*s+b*a+w*c,e},l.mul=l.multiply,l.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=u,e[5]=a,e[6]=h*r+p*o+f,e[7]=h*i+p*u+l,e[8]=h*s+p*a+c,e},l.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=Math.sin(n),p=Math.cos(n);return e[0]=p*r+h*o,e[1]=p*i+h*u,e[2]=p*s+h*a,e[3]=p*o-h*r,e[4]=p*u-h*i,e[5]=p*a-h*s,e[6]=f,e[7]=l,e[8]=c,e},l.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},l.fromMat2d=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e},l.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=n*u,c=n*a,h=r*u,p=r*a,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-(h+d),e[3]=l+g,e[6]=c-m,e[1]=l-g,e[4]=1-(f+d),e[7]=p+v,e[2]=c+m,e[5]=p-v,e[8]=1-(f+h),e},l.normalFromMat4=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(a*C-o*A-f*N)*O,e[2]=(o*L-u*C+f*T)*O,e[3]=(i*L-r*A-s*k)*O,e[4]=(n*A-i*C+s*N)*O,e[5]=(r*C-n*L-s*T)*O,e[6]=(v*x-m*S+g*E)*O,e[7]=(m*w-d*x-g*b)*O,e[8]=(d*S-v*w+g*y)*O,e):null},l.str=function(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"},typeof e!="undefined"&&(e.mat3=l);var c={};c.create=function(){var e=new n(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.clone=function(e){var t=new n(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},c.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},c.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],u=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=u}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e},c.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(i*L-r*A-s*k)*O,e[2]=(v*x-m*S+g*E)*O,e[3]=(h*S-c*x-p*E)*O,e[4]=(a*C-o*A-f*N)*O,e[5]=(n*A-i*C+s*N)*O,e[6]=(m*w-d*x-g*b)*O,e[7]=(l*x-h*w+p*b)*O,e[8]=(o*L-u*C+f*T)*O,e[9]=(r*C-n*L-s*T)*O,e[10]=(d*S-v*w+g*y)*O,e[11]=(c*w-l*S-p*y)*O,e[12]=(u*N-o*k-a*T)*O,e[13]=(n*k-r*N+i*T)*O,e[14]=(v*b-d*E-m*y)*O,e[15]=(l*E-c*b+h*y)*O,e):null},c.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15];return e[0]=u*(h*g-p*m)-c*(a*g-f*m)+v*(a*p-f*h),e[1]=-(r*(h*g-p*m)-c*(i*g-s*m)+v*(i*p-s*h)),e[2]=r*(a*g-f*m)-u*(i*g-s*m)+v*(i*f-s*a),e[3]=-(r*(a*p-f*h)-u*(i*p-s*h)+c*(i*f-s*a)),e[4]=-(o*(h*g-p*m)-l*(a*g-f*m)+d*(a*p-f*h)),e[5]=n*(h*g-p*m)-l*(i*g-s*m)+d*(i*p-s*h),e[6]=-(n*(a*g-f*m)-o*(i*g-s*m)+d*(i*f-s*a)),e[7]=n*(a*p-f*h)-o*(i*p-s*h)+l*(i*f-s*a),e[8]=o*(c*g-p*v)-l*(u*g-f*v)+d*(u*p-f*c),e[9]=-(n*(c*g-p*v)-l*(r*g-s*v)+d*(r*p-s*c)),e[10]=n*(u*g-f*v)-o*(r*g-s*v)+d*(r*f-s*u),e[11]=-(n*(u*p-f*c)-o*(r*p-s*c)+l*(r*f-s*u)),e[12]=-(o*(c*m-h*v)-l*(u*m-a*v)+d*(u*h-a*c)),e[13]=n*(c*m-h*v)-l*(r*m-i*v)+d*(r*h-i*c),e[14]=-(n*(u*m-a*v)-o*(r*m-i*v)+d*(r*a-i*u)),e[15]=n*(u*h-a*c)-o*(r*h-i*c)+l*(r*a-i*u),e},c.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8],l=e[9],c=e[10],h=e[11],p=e[12],d=e[13],v=e[14],m=e[15],g=t*o-n*s,y=t*u-r*s,b=t*a-i*s,w=n*u-r*o,E=n*a-i*o,S=r*a-i*u,x=f*d-l*p,T=f*v-c*p,N=f*m-h*p,C=l*v-c*d,k=l*m-h*d,L=c*m-h*v;return g*L-y*k+b*C+w*N-E*T+S*x},c.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=t[9],p=t[10],d=t[11],v=t[12],m=t[13],g=t[14],y=t[15],b=n[0],w=n[1],E=n[2],S=n[3];return e[0]=b*r+w*u+E*c+S*v,e[1]=b*i+w*a+E*h+S*m,e[2]=b*s+w*f+E*p+S*g,e[3]=b*o+w*l+E*d+S*y,b=n[4],w=n[5],E=n[6],S=n[7],e[4]=b*r+w*u+E*c+S*v,e[5]=b*i+w*a+E*h+S*m,e[6]=b*s+w*f+E*p+S*g,e[7]=b*o+w*l+E*d+S*y,b=n[8],w=n[9],E=n[10],S=n[11],e[8]=b*r+w*u+E*c+S*v,e[9]=b*i+w*a+E*h+S*m,e[10]=b*s+w*f+E*p+S*g,e[11]=b*o+w*l+E*d+S*y,b=n[12],w=n[13],E=n[14],S=n[15],e[12]=b*r+w*u+E*c+S*v,e[13]=b*i+w*a+E*h+S*m,e[14]=b*s+w*f+E*p+S*g,e[15]=b*o+w*l+E*d+S*y,e},c.mul=c.multiply,c.translate=function(e,t,n){var r=n[0],i=n[1],s=n[2],o,u,a,f,l,c,h,p,d,v,m,g;return t===e?(e[12]=t[0]*r+t[4]*i+t[8]*s+t[12],e[13]=t[1]*r+t[5]*i+t[9]*s+t[13],e[14]=t[2]*r+t[6]*i+t[10]*s+t[14],e[15]=t[3]*r+t[7]*i+t[11]*s+t[15]):(o=t[0],u=t[1],a=t[2],f=t[3],l=t[4],c=t[5],h=t[6],p=t[7],d=t[8],v=t[9],m=t[10],g=t[11],e[0]=o,e[1]=u,e[2]=a,e[3]=f,e[4]=l,e[5]=c,e[6]=h,e[7]=p,e[8]=d,e[9]=v,e[10]=m,e[11]=g,e[12]=o*r+l*i+d*s+t[12],e[13]=u*r+c*i+v*s+t[13],e[14]=a*r+h*i+m*s+t[14],e[15]=f*r+p*i+g*s+t[15]),e},c.scale=function(e,t,n){var r=n[0],i=n[1],s=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},c.rotate=function(e,n,r,i){var s=i[0],o=i[1],u=i[2],a=Math.sqrt(s*s+o*o+u*u),f,l,c,h,p,d,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_;return Math.abs(a)<t?null:(a=1/a,s*=a,o*=a,u*=a,f=Math.sin(r),l=Math.cos(r),c=1-l,h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8],E=n[9],S=n[10],x=n[11],T=s*s*c+l,N=o*s*c+u*f,C=u*s*c-o*f,k=s*o*c-u*f,L=o*o*c+l,A=u*o*c+s*f,O=s*u*c+o*f,M=o*u*c-s*f,_=u*u*c+l,e[0]=h*T+m*N+w*C,e[1]=p*T+g*N+E*C,e[2]=d*T+y*N+S*C,e[3]=v*T+b*N+x*C,e[4]=h*k+m*L+w*A,e[5]=p*k+g*L+E*A,e[6]=d*k+y*L+S*A,e[7]=v*k+b*L+x*A,e[8]=h*O+m*M+w*_,e[9]=p*O+g*M+E*_,e[10]=d*O+y*M+S*_,e[11]=v*O+b*M+x*_,n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)},c.rotateX=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[4],o=t[5],u=t[6],a=t[7],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+f*r,e[5]=o*i+l*r,e[6]=u*i+c*r,e[7]=a*i+h*r,e[8]=f*i-s*r,e[9]=l*i-o*r,e[10]=c*i-u*r,e[11]=h*i-a*r,e},c.rotateY=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i-f*r,e[1]=o*i-l*r,e[2]=u*i-c*r,e[3]=a*i-h*r,e[8]=s*r+f*i,e[9]=o*r+l*i,e[10]=u*r+c*i,e[11]=a*r+h*i,e},c.rotateZ=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[4],l=t[5],c=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+f*r,e[1]=o*i+l*r,e[2]=u*i+c*r,e[3]=a*i+h*r,e[4]=f*i-s*r,e[5]=l*i-o*r,e[6]=c*i-u*r,e[7]=h*i-a*r,e},c.fromRotationTranslation=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=r+r,a=i+i,f=s+s,l=r*u,c=r*a,h=r*f,p=i*a,d=i*f,v=s*f,m=o*u,g=o*a,y=o*f;return e[0]=1-(p+v),e[1]=c+y,e[2]=h-g,e[3]=0,e[4]=c-y,e[5]=1-(l+v),e[6]=d+m,e[7]=0,e[8]=h+g,e[9]=d-m,e[10]=1-(l+p),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e},c.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=n*u,c=n*a,h=r*u,p=r*a,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-(h+d),e[1]=l+g,e[2]=c-m,e[3]=0,e[4]=l-g,e[5]=1-(f+d),e[6]=p+v,e[7]=0,e[8]=c+m,e[9]=p-v,e[10]=1-(f+h),e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.frustum=function(e,t,n,r,i,s,o){var u=1/(n-t),a=1/(i-r),f=1/(s-o);return e[0]=s*2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s*2*a,e[6]=0,e[7]=0,e[8]=(n+t)*u,e[9]=(i+r)*a,e[10]=(o+s)*f,e[11]=-1,e[12]=0,e[13]=0,e[14]=o*s*2*f,e[15]=0,e},c.perspective=function(e,t,n,r,i){var s=1/Math.tan(t/2),o=1/(r-i);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(i+r)*o,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*i*r*o,e[15]=0,e},c.ortho=function(e,t,n,r,i,s,o){var u=1/(t-n),a=1/(r-i),f=1/(s-o);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*u,e[13]=(i+r)*a,e[14]=(o+s)*f,e[15]=1,e},c.lookAt=function(e,n,r,i){var s,o,u,a,f,l,h,p,d,v,m=n[0],g=n[1],y=n[2],b=i[0],w=i[1],E=i[2],S=r[0],x=r[1],T=r[2];return Math.abs(m-S)<t&&Math.abs(g-x)<t&&Math.abs(y-T)<t?c.identity(e):(h=m-S,p=g-x,d=y-T,v=1/Math.sqrt(h*h+p*p+d*d),h*=v,p*=v,d*=v,s=w*d-E*p,o=E*h-b*d,u=b*p-w*h,v=Math.sqrt(s*s+o*o+u*u),v?(v=1/v,s*=v,o*=v,u*=v):(s=0,o=0,u=0),a=p*u-d*o,f=d*s-h*u,l=h*o-p*s,v=Math.sqrt(a*a+f*f+l*l),v?(v=1/v,a*=v,f*=v,l*=v):(a=0,f=0,l=0),e[0]=s,e[1]=a,e[2]=h,e[3]=0,e[4]=o,e[5]=f,e[6]=p,e[7]=0,e[8]=u,e[9]=l,e[10]=d,e[11]=0,e[12]=-(s*m+o*g+u*y),e[13]=-(a*m+f*g+l*y),e[14]=-(h*m+p*g+d*y),e[15]=1,e)},c.str=function(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"},typeof e!="undefined"&&(e.mat4=c);var h={};h.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},h.rotationTo=function(){var e=o.create(),t=o.fromValues(1,0,0),n=o.fromValues(0,1,0);return function(r,i,s){var u=o.dot(i,s);return u<-0.999999?(o.cross(e,t,i),o.length(e)<1e-6&&o.cross(e,n,i),o.normalize(e,e),h.setAxisAngle(r,e,Math.PI),r):u>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(o.cross(e,i,s),r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=1+u,h.normalize(r,r))}}(),h.setAxes=function(){var e=l.create();return function(t,n,r,i){return e[0]=r[0],e[3]=r[1],e[6]=r[2],e[1]=i[0],e[4]=i[1],e[7]=i[2],e[2]=n[0],e[5]=n[1],e[8]=n[2],h.normalize(t,h.fromMat3(t,e))}}(),h.clone=u.clone,h.fromValues=u.fromValues,h.copy=u.copy,h.set=u.set,h.identity=function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},h.setAxisAngle=function(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e},h.add=u.add,h.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*l+o*u+i*f-s*a,e[1]=i*l+o*a+s*u-r*f,e[2]=s*l+o*f+r*a-i*u,e[3]=o*l-r*u-i*a-s*f,e},h.mul=h.multiply,h.scale=u.scale,h.rotateX=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+o*u,e[1]=i*a+s*u,e[2]=s*a-i*u,e[3]=o*a-r*u,e},h.rotateY=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a-s*u,e[1]=i*a+o*u,e[2]=s*a+r*u,e[3]=o*a-i*u,e},h.rotateZ=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=i*a-r*u,e[2]=s*a+o*u,e[3]=o*a-s*u,e},h.calculateW=function(e,t){var n=t[0],r=t[1],i=t[2];return e[0]=n,e[1]=r,e[2]=i,e[3]=-Math.sqrt(Math.abs(1-n*n-r*r-i*i)),e},h.dot=u.dot,h.lerp=u.lerp,h.slerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3],a=n[0],f=n[1],l=n[2],c=n[3],h,p,d,v,m;return p=i*a+s*f+o*l+u*c,p<0&&(p=-p,a=-a,f=-f,l=-l,c=-c),1-p>1e-6?(h=Math.acos(p),d=Math.sin(h),v=Math.sin((1-r)*h)/d,m=Math.sin(r*h)/d):(v=1-r,m=r),e[0]=v*i+m*a,e[1]=v*s+m*f,e[2]=v*o+m*l,e[3]=v*u+m*c,e},h.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s,u=o?1/o:0;return e[0]=-n*u,e[1]=-r*u,e[2]=-i*u,e[3]=s*u,e},h.conjugate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e},h.length=u.length,h.len=h.length,h.squaredLength=u.squaredLength,h.sqrLen=h.squaredLength,h.normalize=u.normalize,h.fromMat3=function(){var e=typeof Int8Array!="undefined"?new Int8Array([1,2,0]):[1,2,0];return function(t,n){var r=n[0]+n[4]+n[8],i;if(r>0)i=Math.sqrt(r+1),t[3]=.5*i,i=.5/i,t[0]=(n[7]-n[5])*i,t[1]=(n[2]-n[6])*i,t[2]=(n[3]-n[1])*i;else{var s=0;n[4]>n[0]&&(s=1),n[8]>n[s*3+s]&&(s=2);var o=e[s],u=e[o];i=Math.sqrt(n[s*3+s]-n[o*3+o]-n[u*3+u]+1),t[s]=.5*i,i=.5/i,t[3]=(n[u*3+o]-n[o*3+u])*i,t[o]=(n[o*3+s]+n[s*3+o])*i,t[u]=(n[u*3+s]+n[s*3+u])*i}return t}}(),h.str=function(e){return"quat("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.quat=h)}(t.exports)})(this);

},{}],22:[function(require,module,exports){
'use strict';

if (typeof window === 'undefined') {
    new (require('./source/worker.js'))(self);
} else {
    // jshint -W079
    var mapboxgl = module.exports = window.mapboxgl = {};

    mapboxgl.Map = require('./ui/map.js');
    mapboxgl.Navigation = require('./ui/control/navigation.js');
    mapboxgl.Attribution = require('./ui/control/attribution.js');

    mapboxgl.Source = require('./source/source');
    mapboxgl.GeoJSONSource = require('./source/geojsonsource');
    mapboxgl.VideoSource = require('./source/videosource');

    mapboxgl.Style = require('./style/style.js');

    mapboxgl.LatLng = require('./geo/latlng.js');
    mapboxgl.LatLngBounds = require('./geo/latlngbounds.js');
    mapboxgl.Point = require('point-geometry');

    mapboxgl.Evented = require('./util/evented.js');
    mapboxgl.util = require('./util/util.js');

    var browser = require('./util/browser.js');
    mapboxgl.util.supported = browser.supported;

    var ajax = require('./util/ajax.js');
    mapboxgl.util.getJSON = ajax.getJSON;
    mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;

    var config = require('./util/config.js');
    mapboxgl.config = config;

    Object.defineProperty(mapboxgl, 'accessToken', {
        get: function() { return config.ACCESS_TOKEN; },
        set: function(token) { config.ACCESS_TOKEN = token; }
    });
}

},{"./geo/latlng.js":17,"./geo/latlngbounds.js":18,"./source/geojsonsource":35,"./source/source":39,"./source/videosource":44,"./source/worker.js":45,"./style/style.js":53,"./ui/control/attribution.js":67,"./ui/control/navigation.js":69,"./ui/map.js":74,"./util/ajax.js":76,"./util/browser.js":77,"./util/config.js":80,"./util/evented.js":82,"./util/util.js":87,"point-geometry":95}],23:[function(require,module,exports){
'use strict';

var mat3 = require('../lib/glmatrix.js').mat3;

module.exports = drawBackground;

function drawBackground(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {
    var color = layerStyle['background-color'];
    var image = layerStyle['background-image'];
    var opacity = layerStyle['background-opacity'];
    var shader;

    if (image) {
        // Draw texture fill
        var imagePos = imageSprite.getPosition(image, true);
        if (!imagePos) return;

        shader = painter.patternShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
        gl.uniform2fv(shader.u_pattern_br, imagePos.br);
        gl.uniform1f(shader.u_mix, painter.transform.zoomFraction);
        gl.uniform1f(shader.u_opacity, opacity);

        var transform = painter.transform;
        var size = imagePos.size;
        var center = transform.locationCoordinate(transform.center);
        var scale = 1 / Math.pow(2, transform.zoomFraction);
        var matrix = mat3.create();

        mat3.scale(matrix, matrix, [1 / size[0], 1 / size[1], 1]);
        mat3.translate(matrix, matrix, [
            (center.column * transform.tileSize) % size[0],
            (center.row    * transform.tileSize) % size[1],
            0
        ]);
        mat3.rotate(matrix, matrix, -transform.angle);
        mat3.scale(matrix, matrix, [
            scale * transform.width  / 2,
           -scale * transform.height / 2,
            1
        ]);

        gl.uniformMatrix3fv(shader.u_patternmatrix, false, matrix);

        imageSprite.bind(gl, true);

    } else {
        // Draw filling rectangle.
        shader = painter.fillShader;
        gl.switchShader(shader, params.padded || posMatrix);
        gl.uniform4fv(shader.u_color, color);
    }

    gl.disable(gl.STENCIL_TEST);
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.backgroundBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.backgroundBuffer.itemCount);
    gl.enable(gl.STENCIL_TEST);

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
}

},{"../lib/glmatrix.js":21}],24:[function(require,module,exports){
'use strict';

var textVertices = require('../lib/debugtext.js');
var browser = require('../util/browser.js');

module.exports = drawDebug;

function drawDebug(gl, painter, tile, params) {
    // Blend to the front, not the back.
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.switchShader(painter.debugShader, painter.tile.posMatrix, painter.tile.exMatrix);

    // draw bounding rectangle
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugBuffer);
    gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.uniform4f(painter.debugShader.u_color, 1, 0, 0, 1);
    gl.lineWidth(4);
    gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.itemCount);

    // draw tile coordinate
    var coord = params.z + '/' + params.x + '/' + params.y;

    var vertices = textVertices(coord, 50, 200, 5);

    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugTextBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array(vertices), gl.STREAM_DRAW);
    gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugTextBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.lineWidth(8 * browser.devicePixelRatio);
    gl.uniform4f(painter.debugShader.u_color, 1, 1, 1, 1);
    gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
    gl.lineWidth(2 * browser.devicePixelRatio);
    gl.uniform4f(painter.debugShader.u_color, 0, 0, 0, 1);
    gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);

    // Revert blending mode to blend to the back.
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
}

},{"../lib/debugtext.js":20,"../util/browser.js":77}],25:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');
var mat3 = require('../lib/glmatrix.js').mat3;

module.exports = drawFill;

function drawFill(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {

    var translatedPosMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle['fill-translate'], layerStyle['fill-translate-anchor']);

    var color = layerStyle['fill-color'];

    var vertex, elements, group, count;

    // Draw the stencil mask.

    // We're only drawing to the first seven bits (== support a maximum of
    // 127 overlapping polygons in one place before we get rendering errors).
    gl.stencilMask(0x3F);
    gl.clear(gl.STENCIL_BUFFER_BIT);

    // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
    // increasing the lower 7 bits by one if the triangle is a front-facing
    // triangle. This means that all visible polygons should be in CCW
    // orientation, while all holes (see below) are in CW orientation.
    gl.stencilFunc(gl.NOTEQUAL, 0x80, 0x80);

    // When we do a nonzero fill, we count the number of times a pixel is
    // covered by a counterclockwise polygon, and subtract the number of
    // times it is "uncovered" by a clockwise polygon.
    gl.stencilOpSeparate(gl.FRONT, gl.INCR_WRAP, gl.KEEP, gl.KEEP);
    gl.stencilOpSeparate(gl.BACK, gl.DECR_WRAP, gl.KEEP, gl.KEEP);

    // When drawing a shape, we first draw all shapes to the stencil buffer
    // and incrementing all areas where polygons are
    gl.colorMask(false, false, false, false);

    // Draw the actual triangle fan into the stencil buffer.
    gl.switchShader(painter.fillShader, translatedPosMatrix, painter.tile.exMatrix);

    // Draw all buffers
    vertex = bucket.buffers.fillVertex;
    vertex.bind(gl);
    elements = bucket.buffers.fillElement;
    elements.bind(gl);

    var offset, elementOffset;
    for (var i = 0; i < bucket.elementGroups.groups.length; i++) {
        group = bucket.elementGroups.groups[i];
        offset = group.vertexStartIndex * vertex.itemSize;
        gl.vertexAttribPointer(painter.fillShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);

        count = group.elementLength * 3;
        elementOffset = group.elementStartIndex * elements.itemSize;
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
    }

    // Now that we have the stencil mask in the stencil buffer, we can start
    // writing to the color buffer.
    gl.colorMask(true, true, true, true);

    // From now on, we don't want to update the stencil buffer anymore.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(0x0);

    var strokeColor = layerStyle['fill-outline-color'];

    // Because we're drawing top-to-bottom, and we update the stencil mask
    // below, we have to draw the outline first (!)
    if (layerStyle['fill-antialias'] === true && params.antialiasing && !(layerStyle['fill-image'] && !strokeColor)) {
        gl.switchShader(painter.outlineShader, translatedPosMatrix, painter.tile.exMatrix);
        gl.lineWidth(2 * browser.devicePixelRatio);

        if (strokeColor) {
            // If we defined a different color for the fill outline, we are
            // going to ignore the bits in 0x3F and just care about the global
            // clipping mask.
            gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
        } else {
            // Otherwise, we only want to draw the antialiased parts that are
            // *outside* the current shape. This is important in case the fill
            // or stroke color is translucent. If we wouldn't clip to outside
            // the current shape, some pixels from the outline stroke overlapped
            // the (non-antialiased) fill.
            gl.stencilFunc(gl.EQUAL, 0x80, 0xBF);
        }

        gl.uniform2f(painter.outlineShader.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.uniform4fv(painter.outlineShader.u_color, strokeColor ? strokeColor : color);

        // Draw all buffers
        vertex = bucket.buffers.fillVertex;
        elements = bucket.buffers.outlineElement;
        elements.bind(gl);

        for (var k = 0; k < bucket.elementGroups.groups.length; k++) {
            group = bucket.elementGroups.groups[k];
            offset = group.vertexStartIndex * vertex.itemSize;
            gl.vertexAttribPointer(painter.outlineShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);

            count = group.secondElementLength * 2;
            elementOffset = group.secondElementStartIndex * elements.itemSize;
            gl.drawElements(gl.LINES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    }

    var image = layerStyle['fill-image'];
    var opacity = layerStyle['fill-opacity'] || 1;
    var shader;

    if (image) {
        // Draw texture fill
        var imagePos = imageSprite.getPosition(image, true);
        if (!imagePos) return;

        shader = painter.patternShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
        gl.uniform2fv(shader.u_pattern_br, imagePos.br);
        gl.uniform1f(shader.u_mix, painter.transform.zoomFraction);
        gl.uniform1f(shader.u_opacity, opacity);

        var factor = 8 / Math.pow(2, painter.transform.tileZoom - params.z);

        var matrix = mat3.create();
        mat3.scale(matrix, matrix, [
            1 / (imagePos.size[0] * factor),
            1 / (imagePos.size[1] * factor),
            1, 1
        ]);

        gl.uniformMatrix3fv(shader.u_patternmatrix, false, matrix);

        imageSprite.bind(gl, true);

    } else {
        // Draw filling rectangle.
        shader = painter.fillShader;
        gl.switchShader(shader, params.padded || posMatrix);
        gl.uniform4fv(shader.u_color, color);
    }

    // Only draw regions that we marked
    gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x3F);
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
}

},{"../lib/glmatrix.js":21,"../util/browser.js":77}],26:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');

module.exports = function drawLine(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {
    // don't draw zero-width lines
    if (layerStyle['line-width'] <= 0) return;

    var antialiasing = 1 / browser.devicePixelRatio;
    var width = layerStyle['line-width'];
    var offset = layerStyle['line-offset'] / 2;
    var blur = layerStyle['line-blur'] + antialiasing;

    var inset = Math.max(-1, offset - width / 2 - antialiasing / 2) + 1;
    var outset = offset + width / 2 + antialiasing / 2;

    var color = layerStyle['line-color'];
    var ratio = painter.transform.scale / (1 << params.z) / 8;
    var vtxMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle['line-translate'], layerStyle['line-translate-anchor']);

    var shader;

    var imagePos = layerStyle['line-image'] && imageSprite.getPosition(layerStyle['line-image']);
    if (imagePos) {
        var factor = 8 / Math.pow(2, painter.transform.tileZoom - params.z);

        imageSprite.bind(gl, true);

        shader = painter.linepatternShader;
        gl.switchShader(shader, vtxMatrix, painter.tile.exMatrix);

        gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
        gl.uniform1f(shader.u_ratio, ratio);
        gl.uniform1f(shader.u_blur, blur);

        gl.uniform2fv(shader.u_pattern_size, [imagePos.size[0] * factor, imagePos.size[1] ]);
        gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
        gl.uniform2fv(shader.u_pattern_br, imagePos.br);
        gl.uniform1f(shader.u_fade, painter.transform.zoomFraction);

    } else {
        shader = painter.lineShader;
        gl.switchShader(shader, vtxMatrix, painter.tile.exMatrix);

        gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
        gl.uniform1f(shader.u_ratio, ratio);
        gl.uniform1f(shader.u_blur, blur);

        gl.uniform4fv(shader.u_color, color);
        gl.uniform2fv(shader.u_dasharray, layerStyle['line-dasharray']);
    }

    var vertex = bucket.buffers.lineVertex;
    vertex.bind(gl);
    var element = bucket.buffers.lineElement;
    element.bind(gl);

    var groups = bucket.elementGroups.groups;
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var vtxOffset = group.vertexStartIndex * vertex.itemSize;
        gl.vertexAttribPointer(shader.a_pos, 4, gl.SHORT, false, 8, vtxOffset + 0);
        gl.vertexAttribPointer(shader.a_extrude, 2, gl.BYTE, false, 8, vtxOffset + 6);
        gl.vertexAttribPointer(shader.a_linesofar, 2, gl.SHORT, false, 8, vtxOffset + 4);

        var count = group.elementLength * 3;
        var elementOffset = group.elementStartIndex * element.itemSize;
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
    }

};

},{"../util/browser.js":77}],27:[function(require,module,exports){
'use strict';

var TileCoord = require('../source/tilecoord.js');
var PrerenderedTexture = require('./prerendered.js');
var mat4 = require('../lib/glmatrix.js').mat4;

module.exports = drawRaster;

function drawRaster(gl, painter, bucket, layerStyle, params, style, layer, tile) {
    if (layer && layer.layers) {

        if (!bucket.prerendered) {
            bucket.prerendered = new PrerenderedTexture(gl, bucket.info, painter);
            bucket.prerendered.bindFramebuffer();

            gl.clearStencil(0x80);
            gl.stencilMask(0xFF);
            gl.clear(gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
            gl.stencilMask(0x00);

            gl.viewport(0, 0, bucket.prerendered.size, bucket.prerendered.size);

            var buffer = bucket.prerendered.buffer * 4096;

            var matrix = mat4.create();
            mat4.ortho(matrix, -buffer, 4096 + buffer, -4096 - buffer, buffer, 0, 1);
            mat4.translate(matrix, matrix, [0, -4096, 0]);

            params.padded = mat4.create();
            mat4.ortho(params.padded, 0, 4096, -4096, 0, 0, 1);
            mat4.translate(params.padded, params.padded, [0, -4096, 0]);

            painter.draw(tile, style, layer.layers, params, matrix);

            delete params.padded;

            if (bucket.info['raster-blur'] > 0) {
                bucket.prerendered.blur(painter, bucket.info['raster-blur']);
            }

            bucket.prerendered.unbindFramebuffer();
            gl.viewport(0, 0, painter.width, painter.height);
        }

    }

    var texture = bucket.tile ? bucket.tile : bucket.prerendered;

    gl.disable(gl.STENCIL_TEST);

    var shader = painter.rasterShader;
    gl.switchShader(shader, painter.tile.posMatrix, painter.tile.exMatrix);

    // color parameters
    gl.uniform1f(shader.u_brightness_low, layerStyle['raster-brightness'][0]);
    gl.uniform1f(shader.u_brightness_high, layerStyle['raster-brightness'][1]);
    gl.uniform1f(shader.u_saturation_factor, saturationFactor(layerStyle['raster-saturation']));
    gl.uniform1f(shader.u_contrast_factor, contrastFactor(layerStyle['raster-contrast']));
    gl.uniform3fv(shader.u_spin_weights, spinWeights(layerStyle['raster-hue-rotate']));

    var parentTile, opacities;
    if (layer && layer.layers) {
        parentTile = null;
        opacities = [layerStyle['raster-opacity'], 0];
    } else {
        parentTile = findParent(texture);
        opacities = getOpacities(texture, parentTile, layerStyle);
    }
    var parentScaleBy, parentTL;

    gl.activeTexture(gl.TEXTURE0);
    texture.bind(gl);

    if (parentTile) {
        gl.activeTexture(gl.TEXTURE1);
        parentTile.bind(gl);

        var tilePos = TileCoord.fromID(texture.id);
        var parentPos = parentTile && TileCoord.fromID(parentTile.id);
        parentScaleBy = Math.pow(2, parentPos.z - tilePos.z);
        parentTL = [tilePos.x * parentScaleBy % 1, tilePos.y * parentScaleBy % 1];
    } else {
        opacities[1] = 0;
    }

    var bufferScale = bucket.prerendered ? (4096 * (1 + 2 * bucket.prerendered.buffer)) / 4096 : 1;

    // cross-fade parameters
    gl.uniform2fv(shader.u_tl_parent, parentTL || [0, 0]);
    gl.uniform1f(shader.u_scale_parent, parentScaleBy || 1);
    gl.uniform1f(shader.u_buffer_scale, bufferScale);
    gl.uniform1f(shader.u_opacity0, opacities[0]);
    gl.uniform1f(shader.u_opacity1, opacities[1]);
    gl.uniform1i(shader.u_image0, 0);
    gl.uniform1i(shader.u_image1, 1);

    gl.bindBuffer(gl.ARRAY_BUFFER, texture.boundsBuffer || painter.tileExtentBuffer);

    gl.vertexAttribPointer(shader.a_pos,         2, gl.SHORT, false, 8, 0);
    gl.vertexAttribPointer(shader.a_texture_pos, 2, gl.SHORT, false, 8, 4);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.enable(gl.STENCIL_TEST);
}

function findParent(tile) {
    var source = tile.source;
    if (!source) return;
    var parentTiles = {};
    source._findLoadedParent(tile.id, source.minzoom, parentTiles);
    return source.tiles[Object.keys(parentTiles)[0]];
}

function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
}

function spinWeights(angle) {
    angle *= Math.PI / 180;
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    return [
        (2 * c + 1) / 3,
        (-Math.sqrt(3) * s - c + 1) / 3,
        (Math.sqrt(3) * s - c + 1) / 3
    ];
}

function contrastFactor(contrast) {
    return contrast > 0 ?
        1 / (1 - contrast) :
        1 + contrast;
}

function saturationFactor(saturation) {
    return saturation > 0 ?
        1 - 1 / (1.001 - saturation) :
        -saturation;
}

function getOpacities(tile, parentTile, layerStyle) {
    if (!tile.source) return [1, 0];

    var now = new Date().getTime();

    var fadeDuration = layerStyle['raster-fade-duration'];
    var sinceTile = (now - tile.timeAdded) / fadeDuration;
    var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

    var tilePos = TileCoord.fromID(tile.id);
    var parentPos = parentTile && TileCoord.fromID(parentTile.id);

    var idealZ = tile.source._coveringZoomLevel(tile.source._getZoom());
    var parentFurther = parentTile ? Math.abs(parentPos.z - idealZ) > Math.abs(tilePos.z - idealZ) : false;

    var opacity = [];
    if (!parentTile || parentFurther) {
        // if no parent or parent is older
        opacity[0] = clamp(sinceTile, 0, 1);
        opacity[1] = 1 - opacity[0];
    } else {
        // parent is younger, zooming out
        opacity[0] = clamp(1 - sinceParent, 0, 1);
        opacity[1] = 1 - opacity[0];
    }

    var op = layerStyle['raster-opacity'];
    opacity[0] *= op;
    opacity[1] *= op;

    return opacity;
}

},{"../lib/glmatrix.js":21,"../source/tilecoord.js":41,"./prerendered.js":33}],28:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');
var mat4 = require('../lib/glmatrix.js').mat4;

module.exports = drawSymbols;

function drawSymbols(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {
    gl.disable(gl.STENCIL_TEST);
    if (bucket.elementGroups.text.groups.length) {
        drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, 'text');
    }
    if (bucket.elementGroups.icon.groups.length) {
        drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, 'icon');
    }
    gl.enable(gl.STENCIL_TEST);
}

var defaultSizes = {
    icon: 1,
    text: 24
};

function drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, prefix) {

    posMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle[prefix + '-translate'], layerStyle[prefix + '-translate-anchor']);

    var info = bucket.info;

    var exMatrix = mat4.clone(painter.projectionMatrix);
    var alignedWithMap = info[prefix + '-rotation-alignment'] === 'map';
    var angleOffset = (alignedWithMap ? painter.transform.angle : 0);

    if (angleOffset) {
        mat4.rotateZ(exMatrix, exMatrix, angleOffset);
    }

    // If layerStyle.size > info[prefix + '-max-size'] then labels may collide
    var fontSize = layerStyle[prefix + '-size'] || info[prefix + '-max-size'];
    var fontScale = fontSize / defaultSizes[prefix];
    mat4.scale(exMatrix, exMatrix, [ fontScale, fontScale, 1 ]);

    var text = prefix === 'text';
    var sdf = text || bucket.elementGroups.sdfIcons;
    var shader, buffer, texsize;

    if (!text && !imageSprite.loaded())
        return;

    gl.activeTexture(gl.TEXTURE0);

    if (sdf) {
        shader = painter.sdfShader;
    } else {
        shader = painter.iconShader;
    }

    if (text) {
        painter.glyphAtlas.updateTexture(gl);
        buffer = bucket.buffers.glyphVertex;
        texsize = [painter.glyphAtlas.width / 4, painter.glyphAtlas.height / 4];
    } else {
        imageSprite.bind(gl, alignedWithMap || params.rotating || params.zooming || fontScale != 1 || sdf);
        buffer = bucket.buffers.iconVertex;
        texsize = [imageSprite.img.width, imageSprite.img.height];
    }

    gl.switchShader(shader, posMatrix, exMatrix);
    gl.uniform1i(shader.u_texture, 0);
    gl.uniform2fv(shader.u_texsize, texsize);

    buffer.bind(gl, shader);

    // Convert the -pi..pi to an int8 range.
    var angle = Math.round(painter.transform.angle / Math.PI * 128);

    // adjust min/max zooms for variable font sies
    var zoomAdjust = Math.log(fontSize / info[prefix + '-max-size']) / Math.LN2 || 0;

    var flip = alignedWithMap && info[prefix + '-keep-upright'];
    gl.uniform1f(shader.u_flip, flip ? 1 : 0);
    gl.uniform1f(shader.u_angle, (angle + 256) % 256);
    gl.uniform1f(shader.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

    var f = painter.frameHistory.getFadeProperties(300);
    gl.uniform1f(shader.u_fadedist, f.fadedist * 10);
    gl.uniform1f(shader.u_minfadezoom, Math.floor(f.minfadezoom * 10));
    gl.uniform1f(shader.u_maxfadezoom, Math.floor(f.maxfadezoom * 10));
    gl.uniform1f(shader.u_fadezoom, (painter.transform.zoom + f.bump) * 10);

    var begin = bucket.elementGroups[prefix].groups[0].vertexStartIndex,
        len = bucket.elementGroups[prefix].groups[0].vertexLength;

    if (sdf) {
        var sdfPx = 8;
        var blurOffset = 1.19;
        var haloOffset = 6;
        var gamma = 0.105 * defaultSizes[prefix] / fontSize / browser.devicePixelRatio;

        gl.uniform1f(shader.u_gamma, gamma);
        gl.uniform4fv(shader.u_color, layerStyle[prefix + '-color']);
        gl.uniform1f(shader.u_buffer, (256 - 64) / 256);
        gl.drawArrays(gl.TRIANGLES, begin, len);

        if (layerStyle[prefix + '-halo-color']) {
            // Draw halo underneath the text.
            gl.uniform1f(shader.u_gamma, layerStyle[prefix + '-halo-blur'] * blurOffset / fontScale / sdfPx + gamma);
            gl.uniform4fv(shader.u_color, layerStyle[prefix + '-halo-color']);
            gl.uniform1f(shader.u_buffer, (haloOffset - layerStyle[prefix + '-halo-width'] / fontScale) / sdfPx);
            gl.drawArrays(gl.TRIANGLES, begin, len);
        }
    } else {
        gl.uniform1f(shader.u_opacity, layerStyle['icon-opacity']);
        gl.drawArrays(gl.TRIANGLES, begin, len);
    }
}

},{"../lib/glmatrix.js":21,"../util/browser.js":77}],29:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');
var mat4 = require('../lib/glmatrix.js').mat4;

module.exports = drawVertices;

function drawVertices(gl, painter, bucket) {
    // Blend to the front, not the back.
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.switchShader(painter.dotShader, painter.tile.posMatrix, painter.tile.exMatrix);

    // // Draw debug points.
    gl.uniform1f(painter.dotShader.u_size, 4 * browser.devicePixelRatio);
    gl.uniform1f(painter.dotShader.u_blur, 0.25);
    gl.uniform4fv(painter.dotShader.u_color, [0.25, 0, 0, 0.25]);

    // Draw the actual triangle fan into the stencil buffer.

    var vertex, groups, group, begin, count;

    // Draw all buffers
    if (bucket.info.fill) {
        vertex = bucket.buffers.fillVertex;
        vertex.bind(gl);
        groups = bucket.elementGroups.groups;
        for (var i = 0; i < groups.length; i++) {
            group = groups[i];
            begin = group.vertexStartIndex;
            count = group.vertexLength;
            gl.vertexAttribPointer(painter.dotShader.a_pos, 2, gl.SHORT, false, 0, 0);
            gl.drawArrays(gl.POINTS, begin, count);
        }
    }

    var newPosMatrix = mat4.clone(painter.tile.posMatrix);
    mat4.scale(newPosMatrix, newPosMatrix, [0.5, 0.5, 1]);

    gl.switchShader(painter.dotShader, newPosMatrix, painter.tile.exMatrix);

    // Draw all line buffers
    if (bucket.info.line) {
        vertex = bucket.buffers.lineVertex;
        vertex.bind(gl);
        groups = bucket.elementGroups.groups;
        for (var k = 0; k < groups.length; k++) {
            group = groups[k];
            begin = group.vertexStartIndex;
            count = group.vertexLength;
            gl.vertexAttribPointer(painter.dotShader.a_pos, 2, gl.SHORT, false, 0, 0);
            gl.drawArrays(gl.POINTS, begin, count);
        }

    }

    // Revert blending mode to blend to the back.
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
}

},{"../lib/glmatrix.js":21,"../util/browser.js":77}],30:[function(require,module,exports){
'use strict';

module.exports = FrameHistory;

function FrameHistory() {
    this.frameHistory = [];
}

FrameHistory.prototype.getFadeProperties = function(duration) {
    if (duration === undefined) duration = 300;
    var currentTime = (new Date()).getTime();

    // Remove frames until only one is outside the duration, or until there are only three
    while (this.frameHistory.length > 3 && this.frameHistory[1].time + duration < currentTime) {
        this.frameHistory.shift();
    }

    if (this.frameHistory[1].time + duration < currentTime) {
        this.frameHistory[0].z = this.frameHistory[1].z;
    }

    var frameLen = this.frameHistory.length;
    if (frameLen < 3) console.warn('there should never be less than three frames in the history');

    // Find the range of zoom levels we want to fade between
    var startingZ = this.frameHistory[0].z,
        lastFrame = this.frameHistory[frameLen - 1],
        endingZ = lastFrame.z,
        lowZ = Math.min(startingZ, endingZ),
        highZ = Math.max(startingZ, endingZ);

    // Calculate the speed of zooming, and how far it would zoom in terms of zoom levels in one duration
    var zoomDiff = lastFrame.z - this.frameHistory[1].z,
        timeDiff = lastFrame.time - this.frameHistory[1].time;
    var fadedist = zoomDiff / (timeDiff / duration);

    if (isNaN(fadedist)) console.warn('fadedist should never be NaN');

    // At end of a zoom when the zoom stops changing continue pretending to zoom at that speed
    // bump is how much farther it would have been if it had continued zooming at the same rate
    var bump = (currentTime - lastFrame.time) / duration * fadedist;

    return {
        fadedist: fadedist,
        minfadezoom: lowZ,
        maxfadezoom: highZ,
        bump: bump
    };
};

// Record frame history that will be used to calculate fading params
FrameHistory.prototype.record = function(zoom) {
    var currentTime = (new Date()).getTime();

    // first frame ever
    if (!this.frameHistory.length) {
        this.frameHistory.push({time: 0, z: zoom }, {time: 0, z: zoom });
    }

    if (this.frameHistory.length === 2 || this.frameHistory[this.frameHistory.length - 1].z !== zoom) {
        this.frameHistory.push({
            time: currentTime,
            z: zoom
        });
    }
};

},{}],31:[function(require,module,exports){
'use strict';

var shaders = require('./shaders.js');

exports.extend = function(context) {
    context.getShader = function(name, type) {
        var kind = type == this.FRAGMENT_SHADER ? 'fragment' : 'vertex';
        if (!shaders[name] || !shaders[name][kind]) {
            throw new Error("Could not find shader " + name);
        }

        var shader = this.createShader(type);
        this.shaderSource(shader, shaders[name][kind]);
        this.compileShader(shader);
        if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
            throw new Error(this.getShaderInfoLog(shader));
        }
        return shader;
    };

    context.initializeShader = function(name, attributes, uniforms) {
        var shader = {
            program: this.createProgram(),
            fragment: this.getShader(name, this.FRAGMENT_SHADER),
            vertex: this.getShader(name, this.VERTEX_SHADER),
            attributes: []
        };
        this.attachShader(shader.program, shader.vertex);
        this.attachShader(shader.program, shader.fragment);
        this.linkProgram(shader.program);

        if (!this.getProgramParameter(shader.program, this.LINK_STATUS)) {
            console.error(this.getProgramInfoLog(shader.program));
            alert("Could not initialize shader " + name);
        } else {
            for (var i = 0; i < attributes.length; i++) {
                shader[attributes[i]] = this.getAttribLocation(shader.program, attributes[i]);
                shader.attributes.push(shader[attributes[i]]);
            }
            for (var k = 0; k < uniforms.length; k++) {
                shader[uniforms[k]] = this.getUniformLocation(shader.program, uniforms[k]);
            }
        }

        return shader;
    };

    // Switches to a different shader program.
    context.switchShader = function(shader, posMatrix, exMatrix) {
        if (!posMatrix) {
            console.trace('posMatrix does not have required argument');
        }

        if (this.currentShader !== shader) {
            this.useProgram(shader.program);

            // Disable all attributes from the existing shader that aren't used in
            // the new shader. Note: attribute indices are *not* program specific!
            var enabled = this.currentShader ? this.currentShader.attributes : [];
            var required = shader.attributes;

            for (var i = 0; i < enabled.length; i++) {
                if (required.indexOf(enabled[i]) < 0) {
                    this.disableVertexAttribArray(enabled[i]);
                }
            }

            // Enable all attributes for the new shader.
            for (var j = 0; j < required.length; j++) {
                if (enabled.indexOf(required[j]) < 0) {
                    this.enableVertexAttribArray(required[j]);
                }
            }

            this.currentShader = shader;
        }

        // Update the matrices if necessary. Note: This relies on object identity!
        // This means changing the matrix values without the actual matrix object
        // will FAIL to update the matrix properly.
        if (shader.posMatrix !== posMatrix) {
            this.uniformMatrix4fv(shader.u_matrix, false, posMatrix);
            shader.posMatrix = posMatrix;
        }
        if (exMatrix && shader.exMatrix !== exMatrix && shader.u_exmatrix) {
            this.uniformMatrix4fv(shader.u_exmatrix, false, exMatrix);
            shader.exMatrix = exMatrix;
        }
    };

    return context;
};

},{"./shaders.js":34}],32:[function(require,module,exports){
'use strict';

var glutil = require('./glutil.js');
var browser = require('../util/browser.js');
var GlyphAtlas = require('../symbol/glyphatlas.js');
var glmatrix = require('../lib/glmatrix.js');
var FrameHistory = require('./framehistory.js');

var mat4 = glmatrix.mat4;

var drawSymbol = require('./drawsymbol.js');
var drawLine = require('./drawline.js');
var drawFill = require('./drawfill.js');
var drawRaster = require('./drawraster.js');
var drawDebug = require('./drawdebug.js');
var drawBackground = require('./drawbackground.js');
var drawVertices = require('./drawvertices.js');

/*
 * Initialize a new painter object.
 *
 * @param {Canvas} gl an experimental-webgl drawing context
 */
module.exports = GLPainter;
function GLPainter(gl, transform) {
    this.gl = glutil.extend(gl);
    this.transform = transform;

    this.reusableTextures = {};
    this.preFbos = {};

    this.tileExtent = 4096;
    this.frameHistory = new FrameHistory();

    this.setup();
}

/*
 * Update the GL viewport, projection matrix, and transforms to compensate
 * for a new width and height value.
 */
GLPainter.prototype.resize = function(width, height) {
    var gl = this.gl;
    // Initialize projection matrix
    this.projectionMatrix = mat4.create();
    mat4.ortho(this.projectionMatrix, 0, width, height, 0, 0, -1);

    this.width = width * browser.devicePixelRatio;
    this.height = height * browser.devicePixelRatio;
    gl.viewport(0, 0, this.width, this.height);

};


GLPainter.prototype.setup = function() {
    var gl = this.gl;

    gl.verbose = true;

    // We are blending the new pixels *behind* the existing pixels. That way we can
    // draw front-to-back and use then stencil buffer to cull opaque pixels early.
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);

    gl.enable(gl.STENCIL_TEST);

    this.glyphAtlas = new GlyphAtlas(1024, 1024);
    // this.glyphAtlas.debug = true;
    this.glyphAtlas.bind(gl);

    // Initialize shaders
    this.debugShader = gl.initializeShader('debug',
        ['a_pos'],
        ['u_matrix', 'u_pointsize', 'u_color']);

    this.gaussianShader = gl.initializeShader('gaussian',
        ['a_pos'],
        ['u_matrix', 'u_image', 'u_offset']);

    this.rasterShader = gl.initializeShader('raster',
        ['a_pos', 'a_texture_pos'],
        ['u_matrix', 'u_brightness_low', 'u_brightness_high', 'u_saturation_factor', 'u_spin_weights', 'u_contrast_factor', 'u_opacity0', 'u_opacity1', 'u_image0', 'u_image1', 'u_tl_parent', 'u_scale_parent', 'u_buffer_scale']);

    this.lineShader = gl.initializeShader('line',
        ['a_pos', 'a_extrude', 'a_linesofar'],
        ['u_matrix', 'u_exmatrix', 'u_linewidth', 'u_color', 'u_ratio', 'u_dasharray', 'u_blur']);

    this.linepatternShader = gl.initializeShader('linepattern',
        ['a_pos', 'a_extrude', 'a_linesofar'],
        ['u_matrix', 'u_exmatrix', 'u_linewidth', 'u_ratio', 'u_pattern_size', 'u_pattern_tl', 'u_pattern_br', 'u_point', 'u_blur', 'u_fade']);

    this.dotShader = gl.initializeShader('dot',
        ['a_pos'],
        ['u_matrix', 'u_size', 'u_color', 'u_blur']);

    this.sdfShader = gl.initializeShader('sdf',
        ['a_pos', 'a_tex', 'a_offset', 'a_angle', 'a_minzoom', 'a_maxzoom', 'a_rangeend', 'a_rangestart', 'a_labelminzoom'],
        ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_color', 'u_gamma', 'u_buffer', 'u_angle', 'u_zoom', 'u_flip', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom']);

    this.iconShader = gl.initializeShader('icon',
        ['a_pos', 'a_tex', 'a_offset', 'a_angle', 'a_minzoom', 'a_maxzoom', 'a_rangeend', 'a_rangestart', 'a_labelminzoom'],
        ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_angle', 'u_zoom', 'u_flip', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_opacity']);

    this.outlineShader = gl.initializeShader('outline',
        ['a_pos'],
        ['u_matrix', 'u_color', 'u_world']
    );

    this.patternShader = gl.initializeShader('pattern',
        ['a_pos'],
        ['u_matrix', 'u_pattern_tl', 'u_pattern_br', 'u_mix', 'u_patternmatrix', 'u_opacity', 'u_image']
    );

    this.fillShader = gl.initializeShader('fill',
        ['a_pos'],
        ['u_matrix', 'u_color']
    );

    this.identityMatrix = mat4.create();

    // The backgroundBuffer is used when drawing to the full *canvas*
    this.backgroundBuffer = gl.createBuffer();
    this.backgroundBuffer.itemSize = 2;
    this.backgroundBuffer.itemCount = 4;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

    // The tileExtentBuffer is used when drawing to a full *tile*
    this.tileExtentBuffer = gl.createBuffer();
    this.tileExtentBuffer.itemSize = 4;
    this.tileExtentBuffer.itemCount = 4;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([
        // tile coord x, tile coord y, texture coord x, texture coord y
                      0, 0,                    0, 0,
        this.tileExtent, 0,                32767, 0,
                      0, this.tileExtent,      0, 32767,
        this.tileExtent, this.tileExtent,  32767, 32767
    ]), gl.STATIC_DRAW);

    // The debugBuffer is used to draw tile outlines for debugging
    this.debugBuffer = gl.createBuffer();
    this.debugBuffer.itemSize = 2;
    this.debugBuffer.itemCount = 5;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.debugBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([0, 0, 4095, 0, 4095, 4095, 0, 4095, 0, 0]), gl.STATIC_DRAW);

    // The debugTextBuffer is used to draw tile IDs for debugging
    this.debugTextBuffer = gl.createBuffer();
    this.debugTextBuffer.itemSize = 2;
};

/*
 * Reset the color buffers of the drawing canvas.
 */
GLPainter.prototype.clearColor = function() {
    var gl = this.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/*
 * Reset the drawing canvas by clearing the stencil buffer so that we can draw
 * new tiles at the same location, while retaining previously drawn pixels.
 */
GLPainter.prototype.clearStencil = function() {
    var gl = this.gl;
    gl.clearStencil(0x0);
    gl.stencilMask(0xFF);
    gl.clear(gl.STENCIL_BUFFER_BIT);
};

GLPainter.prototype.drawClippingMask = function() {
    var gl = this.gl;
    gl.switchShader(this.fillShader, this.tile.posMatrix, this.tile.exMatrix);
    gl.colorMask(false, false, false, false);

    // Clear the entire stencil buffer, except for the 7th bit, which stores
    // the global clipping mask that allows us to avoid drawing in regions of
    // tiles we've already painted in.
    gl.clearStencil(0x0);
    gl.stencilMask(0xBF);
    gl.clear(gl.STENCIL_BUFFER_BIT);

    // The stencil test will fail always, meaning we set all pixels covered
    // by this geometry to 0x80. We use the highest bit 0x80 to mark the regions
    // we want to draw in. All pixels that have this bit *not* set will never be
    // drawn in.
    gl.stencilFunc(gl.EQUAL, 0xC0, 0x40);
    gl.stencilMask(0xC0);
    gl.stencilOp(gl.REPLACE, gl.KEEP, gl.KEEP);

    // Draw the clipping mask
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
    gl.vertexAttribPointer(this.fillShader.a_pos, this.tileExtentBuffer.itemSize, gl.SHORT, false, 8, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);

    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
    gl.stencilMask(0x00);
    gl.colorMask(true, true, true, true);
};

GLPainter.prototype.prepareBuffers = function() {}; // Overridden by headless tests.

/*
 * Draw a new tile to the context, assuming that the viewport is
 * already correctly set.
 */
GLPainter.prototype.draw = function glPainterDraw(tile, style, layers, params, matrix) {
    this.tile = tile;

    // false when drawing a group of composited layers
    if (tile && !matrix) {
        // Draw the root clipping mask.
        this.drawClippingMask();
    }

    if (!Array.isArray(layers)) console.warn('Layers is not an array');

    this.frameHistory.record(this.transform.zoom);

    // Draw layers front-to-back.
    // Layers are already in reverse order from style.restructure()
    for (var i = 0, len = layers.length; i < len; i++) {
        this.applyStyle(layers[i], style, tile && tile.buckets, params, tile, matrix);
    }

    if (params.debug) {
        drawDebug(this.gl, this, tile, params);
    }
};

GLPainter.prototype.applyStyle = function(layer, style, buckets, params, tile, matrix) {
    var gl = this.gl;

    var layerStyle = style.computed[layer.id];
    if (!layerStyle || layerStyle.hidden) return;

    if (layer.layers && layer.type === 'raster') {
        drawRaster(gl, this, buckets[layer.bucket], layerStyle, params, style, layer, tile);
    } else if (params.background) {
        drawBackground(gl, this, undefined, layerStyle, this.identityMatrix, params, style.sprite);
    } else {

        var bucket = buckets[layer.bucket];
        // There are no vertices yet for this layer.
        if (!bucket || (bucket.hasData && !bucket.hasData())) return;

        var type = bucket.type;

        if (bucket.minZoom && this.transform.zoom < bucket.minZoom) return;
        if (bucket.maxZoom && this.transform.zoom >= bucket.maxZoom) return;

        var draw = type === 'symbol' ? drawSymbol :
                   type === 'fill' ? drawFill :
                   type === 'line' ? drawLine :
                   type === 'raster' ? drawRaster : null;

        if (draw) {
            var useMatrix = matrix || this.tile.posMatrix;
            draw(gl, this, bucket, layerStyle, useMatrix, params, style.sprite);
        } else {
            console.warn('No bucket type specified');
        }

        if (params.vertices && !layer.layers) {
            drawVertices(gl, this, bucket);
        }
    }
};

// Draws non-opaque areas. This is for debugging purposes.
GLPainter.prototype.drawStencilBuffer = function() {
    var gl = this.gl;
    gl.switchShader(this.fillShader, this.identityMatrix);

    // Blend to the front, not the back.
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);

    // Drw the filling quad where the stencil buffer isn't set.
    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
    gl.vertexAttribPointer(this.fillShader.a_pos, this.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.uniform4fv(this.fillShader.u_color, [0, 0, 0, 0.5]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.backgroundBuffer.itemCount);

    // Revert blending mode to blend to the back.
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
};

GLPainter.prototype.translateMatrix = function(matrix, z, translate, anchor) {
    if (!translate[0] && !translate[1]) return matrix;

    if (anchor === 'viewport') {
        var sin_a = Math.sin(-this.transform.angle);
        var cos_a = Math.cos(-this.transform.angle);
        translate = [
            translate[0] * cos_a - translate[1] * sin_a,
            translate[0] * sin_a + translate[1] * cos_a
        ];
    }

    var tilePixelRatio = this.transform.scale / (1 << z) / 8;
    var translation = [
        translate[0] / tilePixelRatio,
        translate[1] / tilePixelRatio,
        0
    ];

    var translatedMatrix = new Float32Array(16);
    mat4.translate(translatedMatrix, matrix, translation);
    return translatedMatrix;
};

GLPainter.prototype.saveTexture = function(texture) {
    var textures = this.reusableTextures[texture.size];
    if (!textures) {
        this.reusableTextures[texture.size] = [texture];
    } else {
        textures.push(texture);
    }
};


GLPainter.prototype.getTexture = function(size) {
    var textures = this.reusableTextures[size];
    return textures && textures.length > 0 ? textures.pop() : null;
};

},{"../lib/glmatrix.js":21,"../symbol/glyphatlas.js":60,"../util/browser.js":77,"./drawbackground.js":23,"./drawdebug.js":24,"./drawfill.js":25,"./drawline.js":26,"./drawraster.js":27,"./drawsymbol.js":28,"./drawvertices.js":29,"./framehistory.js":30,"./glutil.js":31}],33:[function(require,module,exports){
'use strict';

var glmatrix = require('../lib/glmatrix.js');
var mat4 = glmatrix.mat4;

module.exports = PrerenderedTexture;

function PrerenderedTexture(gl, bucket, painter) {
    this.gl = gl;
    this.buffer = bucket['raster-buffer'] || (1/32);
    this.size = (bucket['raster-size'] || 512) * (1 + 2 * this.buffer);
    this.painter = painter;

    this.texture = null;
    this.fbo = null;
    this.fbos = this.painter.preFbos[this.size];
}

PrerenderedTexture.prototype.bindFramebuffer = function() {
    var gl = this.gl;

    // try to reuse available raster textures
    this.texture = this.painter.getTexture(this.size);

    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size, this.size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.texture.size = this.size;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }

    if (!this.fbos) {
        this.fbo = gl.createFramebuffer();
        var stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, this.size, this.size);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    } else {
        this.fbo = this.fbos.pop();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    }
};

PrerenderedTexture.prototype.unbindFramebuffer = function() {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if (this.fbos) this.fbos.push(this.fbo); else this.painter.preFbos[this.size] = [this.fbo];
};

PrerenderedTexture.prototype.bind = function() {
    if (!this.texture) throw('pre-rendered texture does not exist');
    var gl = this.gl;
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
};

PrerenderedTexture.prototype.blur = function(painter, passes) {
    var gl = this.gl;
    var originalTexture = this.texture;
    var secondaryTexture = this.painter.getTexture(this.size);
    if (!secondaryTexture) {
        secondaryTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size, this.size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        secondaryTexture.size = this.size;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
    }
    gl.bindTexture(gl.TEXTURE_2D, null);

    var matrix = mat4.create();
    mat4.ortho(matrix, 0, 4096, -4096, 0, 0, 1);
    mat4.translate(matrix, matrix, [0, -4096, 0]);

    gl.switchShader(painter.gaussianShader, matrix);
    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1i(painter.gaussianShader.u_image, 0);

    for (var i = 0; i < passes; i++) {

        // Render horizontal
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, secondaryTexture, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2fv(painter.gaussianShader.u_offset, [1 / this.size, 0]);
        gl.bindTexture(gl.TEXTURE_2D, originalTexture);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
        gl.vertexAttribPointer(painter.gaussianShader.a_pos, 2, gl.SHORT, false, 8, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);


        // Render vertical
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, originalTexture, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2fv(painter.gaussianShader.u_offset, [0, 1 / this.size]);
        gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
        gl.vertexAttribPointer(painter.gaussianShader.a_pos, 2, gl.SHORT, false, 8, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    this.painter.saveTexture(secondaryTexture);
};

},{"../lib/glmatrix.js":21}],34:[function(require,module,exports){
'use strict';

var glify = undefined;

module.exports = {
    "debug": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform float u_pointsize;\nuniform mat4 u_matrix;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = a_pos;\n  tmpvar_1.z = float((a_pos.x >= 32767.0));\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = u_pointsize;\n}\n\n","fragment":"precision mediump float;\nuniform vec4 u_color;\nvoid main ()\n{\n  gl_FragColor = u_color;\n}\n\n"},
    "dot": {"vertex":"precision mediump float;\nuniform mat4 u_matrix;\nuniform float u_size;\nattribute vec2 a_pos;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = u_size;\n}\n\n","fragment":"precision mediump float;\nuniform vec4 u_color;\nuniform float u_blur;\nvoid main ()\n{\n  mediump vec2 x_1;\n  x_1 = (gl_PointCoord - 0.5);\n  mediump float tmpvar_2;\n  tmpvar_2 = clamp (((\n    sqrt(dot (x_1, x_1))\n   - 0.5) / (\n    (0.5 - u_blur)\n   - 0.5)), 0.0, 1.0);\n  gl_FragColor = (u_color * (tmpvar_2 * (tmpvar_2 * \n    (3.0 - (2.0 * tmpvar_2))\n  )));\n}\n\n"},
    "fill": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = 2.0;\n}\n\n","fragment":"precision mediump float;\nuniform vec4 u_color;\nvoid main ()\n{\n  gl_FragColor = u_color;\n}\n\n"},
    "gaussian": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nuniform vec2 u_offset;\nvarying highp vec2 a[3];\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_matrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = ((tmpvar_2.xy / 2.0) + 0.5);\n  a[0] = tmpvar_3;\n  vec2 cse_4;\n  cse_4 = (u_offset * 1.18243);\n  a[1] = (tmpvar_3 + cse_4);\n  a[2] = (tmpvar_3 - cse_4);\n}\n\n","fragment":"precision mediump float;\nuniform sampler2D u_image;\nvarying vec2 a[3];\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (((texture2D (u_image, a[0]) * 0.40262) + (texture2D (u_image, a[1]) * 0.29869)) + (texture2D (u_image, a[2]) * 0.29869));\n  gl_FragColor = tmpvar_1;\n}\n\n"},
    "line": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute float a_linesofar;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_ratio;\nuniform vec2 u_linewidth;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  vec2 c_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (vec2(mod (a_pos, 2.0)));\n  c_1.x = tmpvar_2.x;\n  c_1.y = sign((tmpvar_2.y - 0.5));\n  a = c_1;\n  vec4 tmpvar_3;\n  tmpvar_3.zw = vec2(0.0, 0.0);\n  tmpvar_3.xy = ((u_linewidth.x * a_extrude) * 0.015873);\n  vec4 tmpvar_4;\n  tmpvar_4.zw = vec2(0.0, 1.0);\n  tmpvar_4.xy = floor((a_pos * 0.5));\n  gl_Position = ((u_matrix * tmpvar_4) + (u_exmatrix * tmpvar_3));\n  b = (a_linesofar * u_ratio);\n}\n\n","fragment":"precision mediump float;\nuniform vec2 u_linewidth;\nuniform vec2 u_dasharray;\nuniform vec4 u_color;\nuniform float u_blur;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = (sqrt(dot (a, a)) * u_linewidth.x);\n  float tmpvar_2;\n  tmpvar_2 = (float(mod (b, (u_dasharray.x + u_dasharray.y))));\n  gl_FragColor = (u_color * (clamp (\n    (min ((tmpvar_1 - (u_linewidth.y - u_blur)), (u_linewidth.x - tmpvar_1)) / u_blur)\n  , 0.0, 1.0) * max (\n    float((-(u_dasharray.y) >= 0.0))\n  , \n    clamp (min (tmpvar_2, (u_dasharray.x - tmpvar_2)), 0.0, 1.0)\n  )));\n}\n\n"},
    "linepattern": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute float a_linesofar;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_point;\nuniform vec2 u_linewidth;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  vec2 c_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (vec2(mod (a_pos, 2.0)));\n  c_1.x = tmpvar_2.x;\n  c_1.y = sign((tmpvar_2.y - 0.5));\n  a = c_1;\n  vec4 tmpvar_3;\n  tmpvar_3.zw = vec2(0.0, 1.0);\n  tmpvar_3.xy = floor((a_pos / 2.0));\n  vec4 tmpvar_4;\n  tmpvar_4.w = 0.0;\n  tmpvar_4.xy = ((u_linewidth.x * (a_extrude / 63.0)) * (1.0 - u_point));\n  tmpvar_4.z = (float((a_pos.x >= 32767.0)) + (u_point * float(\n    (c_1.y >= 1.0)\n  )));\n  gl_Position = ((u_matrix * tmpvar_3) + (u_exmatrix * tmpvar_4));\n  b = a_linesofar;\n  gl_PointSize = ((2.0 * u_linewidth.x) - 1.0);\n}\n\n","fragment":"precision mediump float;\nuniform vec2 u_linewidth;\nuniform vec2 u_pattern_size;\nuniform vec2 u_pattern_tl;\nuniform vec2 u_pattern_br;\nuniform float u_point;\nuniform float u_blur;\nuniform float u_fade;\nuniform sampler2D u_image;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  lowp vec4 j_1;\n  mediump vec2 x_2;\n  x_2 = ((gl_PointCoord * 2.0) - 1.0);\n  mediump float tmpvar_3;\n  tmpvar_3 = (((\n    sqrt(dot (a, a))\n   * \n    (1.0 - u_point)\n  ) + (u_point * \n    sqrt(dot (x_2, x_2))\n  )) * u_linewidth.x);\n  float tmpvar_4;\n  tmpvar_4 = (float(mod ((b / u_pattern_size.x), 1.0)));\n  float tmpvar_5;\n  tmpvar_5 = (0.5 + ((a.y * u_linewidth.x) / u_pattern_size.y));\n  vec2 tmpvar_6;\n  tmpvar_6.x = tmpvar_4;\n  tmpvar_6.y = tmpvar_5;\n  vec2 tmpvar_7;\n  tmpvar_7.x = (float(mod ((tmpvar_4 * 2.0), 1.0)));\n  tmpvar_7.y = tmpvar_5;\n  lowp vec4 tmpvar_8;\n  tmpvar_8 = ((texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_6)) * (1.0 - u_fade)) + (u_fade * texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_7))));\n  j_1.w = tmpvar_8.w;\n  j_1.xyz = (tmpvar_8.xyz * tmpvar_8.w);\n  gl_FragColor = (j_1 * clamp ((\n    min ((tmpvar_3 - (u_linewidth.y - u_blur)), (u_linewidth.x - tmpvar_3))\n   / u_blur), 0.0, 1.0));\n}\n\n"},
    "outline": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nuniform vec2 u_world;\nvarying highp vec2 a;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_matrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  a = (((tmpvar_2.xy + 1.0) / 2.0) * u_world);\n}\n\n","fragment":"precision mediump float;\nuniform vec4 u_color;\nvarying vec2 a;\nvoid main ()\n{\n  highp vec2 x_1;\n  x_1 = (a - gl_FragCoord.xy);\n  highp float tmpvar_2;\n  tmpvar_2 = clamp (((\n    sqrt(dot (x_1, x_1))\n   - 1.0) / -1.0), 0.0, 1.0);\n  highp vec4 tmpvar_3;\n  tmpvar_3 = (u_color * (tmpvar_2 * (tmpvar_2 * \n    (3.0 - (2.0 * tmpvar_2))\n  )));\n  gl_FragColor = tmpvar_3;\n}\n\n"},
    "pattern": {"vertex":"precision mediump float;\nuniform mat4 u_matrix;\nuniform mat3 u_patternmatrix;\nattribute vec2 a_pos;\nvarying vec2 a;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  vec3 tmpvar_2;\n  tmpvar_2.z = 1.0;\n  tmpvar_2.xy = a_pos;\n  a = (u_patternmatrix * tmpvar_2).xy;\n}\n\n","fragment":"precision mediump float;\nuniform float u_opacity;\nuniform float u_mix;\nuniform vec2 u_pattern_tl;\nuniform vec2 u_pattern_br;\nuniform sampler2D u_image;\nvarying vec2 a;\nvoid main ()\n{\n  vec2 tmpvar_1;\n  tmpvar_1 = (vec2(mod (a, 1.0)));\n  lowp vec4 tmpvar_2;\n  tmpvar_2 = (mix (texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_1)), texture2D (u_image, mix (u_pattern_tl, u_pattern_br, \n    (vec2(mod ((tmpvar_1 * 2.0), 1.0)))\n  )), u_mix) * u_opacity);\n  gl_FragColor = tmpvar_2;\n}\n\n"},
    "raster": {"vertex":"precision mediump float;\nuniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\nvarying vec2 a;\nvarying vec2 b;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  vec2 tmpvar_2;\n  tmpvar_2 = (((\n    (a_texture_pos / 32767.0)\n   - 0.5) / u_buffer_scale) + 0.5);\n  a = tmpvar_2;\n  b = ((tmpvar_2 * u_scale_parent) + u_tl_parent);\n}\n\n","fragment":"precision mediump float;\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform float u_brightness_low;\nuniform float u_brightness_high;\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 a;\nvarying vec2 b;\nuniform vec3 u_spin_weights;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = ((texture2D (u_image0, a) * u_opacity0) + (texture2D (u_image1, b) * u_opacity1));\n  lowp vec3 tmpvar_2;\n  tmpvar_2.x = dot (tmpvar_1.xyz, u_spin_weights);\n  tmpvar_2.y = dot (tmpvar_1.xyz, u_spin_weights.zxy);\n  tmpvar_2.z = dot (tmpvar_1.xyz, u_spin_weights.yzx);\n  lowp vec4 tmpvar_3;\n  tmpvar_3.xyz = mix (vec3(u_brightness_low), vec3(u_brightness_high), ((\n    ((tmpvar_2 + ((\n      (((tmpvar_1.x + tmpvar_1.y) + tmpvar_1.z) / 3.0)\n     - tmpvar_2) * u_saturation_factor)) - 0.5)\n   * u_contrast_factor) + 0.5));\n  tmpvar_3.w = tmpvar_1.w;\n  gl_FragColor = tmpvar_3;\n}\n\n"},
    "icon": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_tex;\nattribute float a_angle;\nattribute float a_minzoom;\nattribute float a_maxzoom;\nattribute float a_rangeend;\nattribute float a_rangestart;\nattribute float a_labelminzoom;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_angle;\nuniform float u_zoom;\nuniform float u_flip;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform float u_opacity;\nuniform vec2 u_texsize;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float d_1;\n  d_1 = 0.0;\n  float tmpvar_2;\n  tmpvar_2 = (float(mod ((a_angle + u_angle), 256.0)));\n  if ((((u_flip > 0.0) && (tmpvar_2 >= 64.0)) && (tmpvar_2 < 192.0))) {\n    d_1 = 1.0;\n  };\n  float tmpvar_3;\n  tmpvar_3 = (((2.0 - \n    float((u_zoom >= a_minzoom))\n  ) - (1.0 - \n    float((u_zoom >= a_maxzoom))\n  )) + d_1);\n  float tmpvar_4;\n  tmpvar_4 = clamp (((u_fadezoom - a_labelminzoom) / u_fadedist), 0.0, 1.0);\n  if ((u_fadedist >= 0.0)) {\n    b = tmpvar_4;\n  } else {\n    b = (1.0 - tmpvar_4);\n  };\n  if ((u_maxfadezoom < a_labelminzoom)) {\n    b = 0.0;\n  };\n  if ((u_minfadezoom >= a_labelminzoom)) {\n    b = 1.0;\n  };\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 1.0);\n  tmpvar_5.xy = a_pos;\n  vec4 tmpvar_6;\n  tmpvar_6.w = 0.0;\n  tmpvar_6.xy = (a_offset / 64.0);\n  tmpvar_6.z = ((tmpvar_3 + float(\n    (0.0 >= b)\n  )) + (float(\n    (u_angle >= a_rangeend)\n  ) * (1.0 - \n    float((u_angle >= a_rangestart))\n  )));\n  gl_Position = ((u_matrix * tmpvar_5) + (u_exmatrix * tmpvar_6));\n  a = (a_tex / u_texsize);\n  b = (b * u_opacity);\n}\n\n","fragment":"precision mediump float;\nuniform sampler2D u_texture;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (texture2D (u_texture, a) * b);\n  gl_FragColor = tmpvar_1;\n}\n\n"},
    "sdf": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_tex;\nattribute float a_angle;\nattribute float a_minzoom;\nattribute float a_maxzoom;\nattribute float a_rangeend;\nattribute float a_rangestart;\nattribute float a_labelminzoom;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_angle;\nuniform float u_zoom;\nuniform float u_flip;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform vec2 u_texsize;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float c_1;\n  c_1 = 0.0;\n  float tmpvar_2;\n  tmpvar_2 = (float(mod ((a_angle + u_angle), 256.0)));\n  if ((((u_flip > 0.0) && (tmpvar_2 >= 64.0)) && (tmpvar_2 < 192.0))) {\n    c_1 = 1.0;\n  };\n  float tmpvar_3;\n  tmpvar_3 = (((2.0 - \n    float((u_zoom >= a_minzoom))\n  ) - (1.0 - \n    float((u_zoom >= a_maxzoom))\n  )) + c_1);\n  float tmpvar_4;\n  tmpvar_4 = clamp (((u_fadezoom - a_labelminzoom) / u_fadedist), 0.0, 1.0);\n  if ((u_fadedist >= 0.0)) {\n    b = tmpvar_4;\n  } else {\n    b = (1.0 - tmpvar_4);\n  };\n  if ((u_maxfadezoom < a_labelminzoom)) {\n    b = 0.0;\n  };\n  if ((u_minfadezoom >= a_labelminzoom)) {\n    b = 1.0;\n  };\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 1.0);\n  tmpvar_5.xy = a_pos;\n  vec4 tmpvar_6;\n  tmpvar_6.w = 0.0;\n  tmpvar_6.xy = (a_offset / 64.0);\n  tmpvar_6.z = ((tmpvar_3 + float(\n    (0.0 >= b)\n  )) + (float(\n    (u_angle >= a_rangeend)\n  ) * (1.0 - \n    float((u_angle >= a_rangestart))\n  )));\n  gl_Position = ((u_matrix * tmpvar_5) + (u_exmatrix * tmpvar_6));\n  a = (a_tex / u_texsize);\n}\n\n","fragment":"precision mediump float;\nuniform sampler2D u_texture;\nuniform vec4 u_color;\nuniform float u_buffer;\nuniform float u_gamma;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float edge0_1;\n  edge0_1 = (u_buffer - u_gamma);\n  lowp float tmpvar_2;\n  tmpvar_2 = clamp (((texture2D (u_texture, a).w - edge0_1) / (\n    (u_buffer + u_gamma)\n   - edge0_1)), 0.0, 1.0);\n  lowp vec4 tmpvar_3;\n  tmpvar_3 = (u_color * ((tmpvar_2 * \n    (tmpvar_2 * (3.0 - (2.0 * tmpvar_2)))\n  ) * b));\n  gl_FragColor = tmpvar_3;\n}\n\n"}
};

},{}],35:[function(require,module,exports){
'use strict';

var util = require('../util/util.js');
var Source = require('./source.js');
var GeoJSONTile = require('./geojsontile.js');

module.exports = GeoJSONSource;

function GeoJSONSource(options) {
    this._tiles = {};
    this._alltiles = {};
    this.enabled = true;
    this.zooms = [1, 5, 9, 13];
    this.minTileZoom = this.zooms[0];
    this.maxTileZoom = this.zooms[this.zooms.length - 1];
    this.data = options.data;
}

GeoJSONSource.prototype = util.inherit(Source, {
    minzoom: 1,
    maxzoom: 13,

    setData: function(data) {
        this.data = data;
        if (this.map) this._updateData();
        return this;
    },

    onAdd: function(map) {
        this.map = map;
        this.painter = map.painter;

        if (this.map.style) this._updateData();
        map.on('style.change', this._updateData.bind(this));
    },

    _updateData: function() {
        var source = this;
        this.workerID = this.map.dispatcher.send('parse geojson', {
            data: this.data,
            zooms: this.zooms,
            tileSize: 512,
            source: this.id
        }, function(err, tiles) {
            if (err) return;
            for (var i = 0; i < tiles.length; i++) {
                source._alltiles[tiles[i].id] = new GeoJSONTile(tiles[i].id, source, tiles[i]);
            }
            if (source.map) source.map.update();
        }.bind(this));
        return this;
    },

    _addTile: function(id) {
        var tile = this._alltiles[id];
        if (tile) {
            tile._load();
            this._tiles[id] = tile;
            this.fire('tile.add', {tile: tile});
        }
        return tile || {};
    },

    _coveringZoomLevel: function(zoom) {
        for (var i = this.zooms.length - 1; i >= 0; i--) {
            if (this.zooms[i] <= zoom) {
                var z = this.zooms[i];
                return z;
            }
        }
        return 0;
    }
});

},{"../util/util.js":87,"./geojsontile.js":36,"./source.js":39}],36:[function(require,module,exports){
'use strict';

var Tile = require('./tile.js');
var BufferSet = require('../data/buffer/bufferset.js');
var createBucket = require('../data/createbucket.js');

module.exports = GeoJSONTile;

function GeoJSONTile(id, source, data) {
    this.id = id;
    this.source = source;
    this.data = data;
    this.workerID = source.workerID;
}

GeoJSONTile.prototype = Object.create(Tile.prototype);

GeoJSONTile.prototype._load = function() {
    if (this.loaded) return;
    this.loaded = true;

    var data = this.data;
    this.buffers = new BufferSet(data.buffers);

    this.buckets = {};
    for (var b in data.elementGroups) {
        this.buckets[b] = createBucket(this.source.map.style.buckets[b], this.buffers, undefined, data.elementGroups[b]);
    }


};

// noops
GeoJSONTile.prototype.abort = function() { };
GeoJSONTile.prototype.remove = function() { };

},{"../data/buffer/bufferset.js":2,"../data/createbucket.js":10,"./tile.js":40}],37:[function(require,module,exports){
'use strict';

module.exports = Wrapper;

// conform to vectortile api
function Wrapper(features) {
    this.features = features;
    this.length = features.length;
}

Wrapper.prototype.feature = function(i) {
    return new FeatureWrapper(this.features[i]);
};

var mapping = {
    'Point': 1,
    'LineString': 2,
    'Polygon': 3
};

function FeatureWrapper(feature) {
    this.feature = feature;
    this.type = mapping[feature.type];
    this.properties = feature.properties;
}

FeatureWrapper.prototype.loadGeometry = function() {
    return this.feature.coords;
};

FeatureWrapper.prototype.bbox = function() {

    if (this.type === mapping.Point) {
        return [
            this.feature.coords[0][0].x,
            this.feature.coords[0][0].y,
            this.feature.coords[0][0].x,
            this.feature.coords[0][0].y
        ];
    }

    var rings = this.feature.coords;

    var x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];

        for (var j = 0; j < ring.length; j++) {
            var coord = ring[j];

            x1 = Math.min(x1, coord.x);
            x2 = Math.max(x2, coord.x);
            y1 = Math.min(y1, coord.y);
            y2 = Math.max(y2, coord.y);
        }
    }

    return [x1, y1, x2, y2];
};

},{}],38:[function(require,module,exports){
'use strict';

var Tile = require('./tile.js');
var ajax = require('../util/ajax.js');
var util = require('../util/util.js');

module.exports = RasterTile;

function RasterTile(id, source, url, callback) {
    this.id = id;
    this.loaded = false;
    this.url = url;
    this.source = source;
    this.map = source.map;
    this._load();
    this.callback = callback;
    this.uses = 1;

    // Todo finish figuring out what raster buckets are
    this.buckets = {};
    this.info = { raster: true };
    var buckets = this.map.style.buckets;
    for (var b in buckets) {
        var bucket = buckets[b];
        var sourceid = bucket && bucket.source;
        if (source.id === sourceid) {
            this.buckets[b] = {
                info: bucket.render,
                type: 'raster',
                tile: this
            };
        }
    }
}

RasterTile.prototype = util.inherit(Tile, {
    _load: function() {
        var tile = this;
        ajax.getImage(this.url, function(err, img) {
            // @TODO handle errors.
            if (err) return;
            tile.img = img;
            if (tile.map) tile.onTileLoad();
        });
    },

    onTileLoad: function() {
        // start texture upload
        this.bind(this.map.painter.gl);

        this.timeAdded = new Date().getTime();
        this.map.animationLoop.set(this.map.style.rasterFadeDuration);

        this.loaded = true;
        this.callback();
    },

    abort: function() {
        this.aborted = true;
        if (this.img) this.img.src = '';
        delete this.img;
    },

    bind: function(gl) {
        if (!this.texture) {
            // try to find reusable texture
            this.texture = this.map.painter.getTexture(this.img.width);
            if (this.texture) {
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.img);
            } else {
                this.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.img);
                this.texture.size = this.img.width;
            }
            gl.generateMipmap(gl.TEXTURE_2D);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }
    },

    remove: function() {
        if (this.texture) this.map.painter.saveTexture(this.texture);
        delete this.map;
    },

    featuresAt: function(pos, params, callback) {
        // noop
        callback(null, []);
    }
});
},{"../util/ajax.js":76,"../util/util.js":87,"./tile.js":40}],39:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    ajax = require('../util/ajax.js'),
    normalizeURL = require('../util/mapbox.js').normalizeSourceURL,
    Evented = require('../util/evented.js'),
    Cache = require('../util/mrucache.js'),
    TileCoord = require('./tilecoord'),
    VectorTile = require('./vectortile'),
    RasterTile = require('./rastertile.js'),
    Point = require('point-geometry');

module.exports = Source;

function Source(options) {
    this.enabled = false;

    util.extend(this, util.pick(options,
        'type', 'url', 'tileSize'));

    if (this.type === 'vector' && this.tileSize !== 512) {
        throw new Error('vector tile sources must have a tileSize of 512');
    }

    this.Tile = this.type === 'vector' ? VectorTile : RasterTile;

    this._tiles = {};
    this._cache = new Cache(this.cacheSize, function(tile) {
        tile.remove();
    });

    var loaded = function(err, tileJSON) {
        if (err) throw err;

        if (!tileJSON.tiles)
            throw new Error('missing tiles property');

        util.extend(this, util.pick(tileJSON,
            'tiles', 'minzoom', 'maxzoom', 'attribution'));

        this.enabled = true;
        this.update();

        if (this.map) this.map.fire('source.add', {source: this});
    }.bind(this);

    if (this.url) {
        ajax.getJSON(normalizeURL(this.url), loaded);
    } else {
        loaded(null, options);
    }

    this._updateTiles = util.throttle(this._updateTiles, 50, this);
}

Source.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    tileSize: 512,
    cacheSize: 20,

    onAdd: function(map) {
        this.map = map;
        this.painter = map.painter;
    },

    load: function() {
        for (var t in this._tiles) {
            this._tiles[t]._load();
        }
    },

    loaded: function() {
        for (var t in this._tiles) {
            if (!this._tiles[t].loaded)
                return false;
        }
        return true;
    },

    update: function() {
        if (!this.enabled) return;
        this._updateTiles();
    },

    render: function(layers) {
        // Iteratively paint every tile.
        if (!this.enabled) return;
        var order = Object.keys(this._tiles);
        order.sort(this._z_order);
        for (var i = 0; i < order.length; i++) {
            var id = order[i];
            var tile = this._tiles[id];
            if (tile.loaded && !this.coveredTiles[id]) {
                this._renderTile(tile, id, layers);
            }
        }
    },

    featuresAt: function(point, params, callback) {
        point = Point.convert(point);

        if (params.layer) {
            var style = this.map.style,
                layer = style.getLayer(params.layer);
            params.bucket = style.buckets[layer.ref || layer.id];
        }

        var order = Object.keys(this._tiles);
        order.sort(this._z_order);
        for (var i = 0; i < order.length; i++) {
            var id = order[i];
            var tile = this._tiles[id];
            var pos = tile.positionAt(id, point);

            if (pos && pos.x >= 0 && pos.x < 4096 && pos.y >= 0 && pos.y < 4096) {
                // The click is within the viewport. There is only ever one tile in
                // a layer that has this property.
                return tile.featuresAt(pos, params, callback);
            }
        }

        callback(null, []);
    },

    // get the zoom level adjusted for the difference in map and source tilesizes
    _getZoom: function() {
        var zOffset = Math.log(this.map.transform.tileSize / this.tileSize) / Math.LN2;
        return this.map.transform.zoom + zOffset;
    },

    _coveringZoomLevel: function(zoom) {
        for (var z = this.maxzoom; z >= this.minzoom; z--) {
            if (z <= zoom) {
                if (this.type === 'raster') {
                    // allow underscaling by rounding to the nearest zoom level
                    if (z < this.maxzoom) {
                        z += Math.round(zoom - z);
                    }
                }
                return z;
            }
        }
        return 0;
    },

    _childZoomLevel: function(zoom) {
        zoom = Math.max(this.minzoom, zoom + 1);
        return zoom <= this.maxzoom ? zoom : null;
    },

    _getCoveringTiles: function(zoom) {
        if (zoom === undefined) zoom = this._getZoom();
        var z = this._coveringZoomLevel(zoom),
            tiles = 1 << z,
            tr = this.map.transform,
            tileCenter = TileCoord.zoomTo(tr.locationCoordinate(tr.center), z);

        var points = [
            TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: 0, y: 0}), z),
            TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: tr.width, y: 0}), z),
            TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: tr.width, y: tr.height}), z),
            TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: 0, y: tr.height}), z)
        ], t = {};

        // Divide the screen up in two triangles and scan each of them:
        // +---/
        // | / |
        // /---+
        this._scanTriangle(points[0], points[1], points[2], 0, tiles, scanLine);
        this._scanTriangle(points[2], points[3], points[0], 0, tiles, scanLine);

        return Object.keys(t).sort(fromCenter);

        function fromCenter(a, b) {
            var ad = Math.abs(a.x - tileCenter.column) +
                    Math.abs(a.y - tileCenter.row),
                bd = Math.abs(b.x - tileCenter.column) +
                    Math.abs(b.y - tileCenter.row);

            return ad - bd;
        }

        function scanLine(x0, x1, y) {
            var x, wx;
            if (y >= 0 && y <= tiles) {
                for (x = x0; x < x1; x++) {
                    wx = (x + tiles) % tiles;
                    t[TileCoord.toID(z, wx, y, Math.floor(x/tiles))] = {x: wx, y: y};
                }
            }
        }
    },

    // Given a tile of data, its id, and a style layers, render the tile to the canvas
    _renderTile: function(tile, id, layers) {
        var pos = TileCoord.fromID(id);
        var z = pos.z, x = pos.x, y = pos.y, w = pos.w;
        x += w * (1 << z);

        tile.calculateMatrices(z, x, y, this.map.transform, this.painter);

        this.painter.draw(tile, this.map.style, layers, {
            z: z, x: x, y: y,
            debug: this.map.debug,
            antialiasing: this.map.antialiasing,
            vertices: this.map.vertices,
            rotating: this.map.rotating,
            zooming: this.map.zooming
        });
    },

    // Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
    // adds found tiles to retain object; returns true if children completely cover the tile

    _findLoadedChildren: function(id, maxCoveringZoom, retain) {
        var complete = true;
        var z = TileCoord.fromID(id).z;
        var ids = TileCoord.children(id);
        for (var i = 0; i < ids.length; i++) {
            if (this._tiles[ids[i]] && this._tiles[ids[i]].loaded) {
                retain[ids[i]] = true;
            } else {
                complete = false;
                if (z < maxCoveringZoom) {
                    // Go further down the hierarchy to find more unloaded children.
                    this._findLoadedChildren(ids[i], maxCoveringZoom, retain);
                }
            }
        }
        return complete;
    },

    // Find a loaded parent of the given tile (up to minCoveringZoom);
    // adds the found tile to retain object and returns true if a parent was found

    _findLoadedParent: function(id, minCoveringZoom, retain) {
        for (var z = TileCoord.fromID(id).z; z >= minCoveringZoom; z--) {
            id = TileCoord.parent(id);
            if (this._tiles[id] && this._tiles[id].loaded) {
                retain[id] = true;
                return true;
            }
        }
        return false;
    },

    // Removes tiles that are outside the viewport and adds new tiles that are inside the viewport.
    _updateTiles: function() {
        if (!this.map || !this.map.loadNewTiles ||
            !this.map.style || !this.map.style.sources || !this.map.style.sources[this.id]) return;

        var zoom = Math.floor(this._getZoom());
        var required = this._getCoveringTiles().sort(this._centerOut.bind(this));
        var i;
        var id;
        var complete;
        var tile;

        // Determine the overzooming/underzooming amounts.
        var minCoveringZoom = Math.max(this.minzoom, zoom - 10);
        var maxCoveringZoom = this.minzoom;
        while (maxCoveringZoom < zoom + 1) {
            var level = this._childZoomLevel(maxCoveringZoom);
            if (level === null) break;
            else maxCoveringZoom = level;
        }

        // Retain is a list of tiles that we shouldn't delete, even if they are not
        // the most ideal tile for the current viewport. This may include tiles like
        // parent or child tiles that are *already* loaded.
        var retain = {};
        // Covered is a list of retained tiles who's areas are full covered by other,
        // better, retained tiles. They are not drawn separately.
        this.coveredTiles = {};

        var fullyComplete = true;

        // Add existing child/parent tiles if the actual tile is not yet loaded
        for (i = 0; i < required.length; i++) {
            id = +required[i];
            retain[id] = true;
            tile = this._addTile(id);

            if (!tile.loaded) {
                // The tile we require is not yet loaded. Try to find a parent or
                // child tile that we already have.

                // First, try to find existing child tiles that completely cover the
                // missing tile.
                complete = this._findLoadedChildren(id, maxCoveringZoom, retain);

                // Then, if there are no complete child tiles, try to find existing
                // parent tiles that completely cover the missing tile.
                if (!complete) {
                    complete = this._findLoadedParent(id, minCoveringZoom, retain);
                }

                // The unloaded tile's area is not completely covered loaded tiles
                if (!complete) {
                    fullyComplete = false;
                }
            }
        }

        var now = new Date().getTime();
        var fadeDuration = this.type === 'raster' ? this.map.style.rasterFadeDuration : 0;

        for (id in retain) {
            tile = this._tiles[id];
            if (tile && tile.timeAdded > now - fadeDuration) {
                // This tile is still fading in. Find tiles to cross-fade with it.

                complete = this._findLoadedChildren(id, maxCoveringZoom, retain);

                if (complete) {
                    this.coveredTiles[id] = true;
                } else {
                    this._findLoadedParent(id, minCoveringZoom, retain);
                }
            }
        }

        for (id in this.coveredTiles) retain[id] = true;

        // Remove the tiles we don't need anymore.
        var remove = util.keysDifference(this._tiles, retain);
        for (i = 0; i < remove.length; i++) {
            id = +remove[i];
            this._removeTile(id);
        }
    },

    _loadTile: function(id) {
        var layer = this;
        var map = this.map,
            pos = TileCoord.fromID(id),
            tile;

        if (pos.w === 0) {
            // console.time('loading ' + pos.z + '/' + pos.x + '/' + pos.y);
            var url = TileCoord.url(id, this.tiles);
            tile = this._tiles[id] = new this.Tile(id, this, url, tileComplete);
        } else {
            var wrapped = TileCoord.toID(pos.z, pos.x, pos.y, 0);
            tile = this._tiles[id] = this._tiles[wrapped] || this._addTile(wrapped);
            tile.uses++;
        }

        function tileComplete(err) {
            // console.timeEnd('loading ' + pos.z + '/' + pos.x + '/' + pos.y);
            if (err) {
                console.warn('failed to load tile %d/%d/%d: %s', pos.z, pos.x, pos.y, err.stack || err);
            } else {
                layer.fire('tile.load', {tile: tile});
                map.update();
            }
        }

        return tile;
    },

    // Adds a vector tile to the map. It will trigger a rerender of the map and will
    // be part in all future renders of the map. The map object will handle copying
    // the tile data to the GPU if it is required to paint the current viewport.
    _addTile: function(id) {
        var tile = this._tiles[id];

        if (!tile) {
            tile = this._cache.get(id);
            if (tile) {
                tile.uses = 1;
                this._tiles[id] = tile;
            }
        }

        if (!tile) {
            tile = this._loadTile(id);
            this.fire('tile.add', {tile: tile});
        }

        return tile;
    },

    _removeTile: function(id) {
        var tile = this._tiles[id];
        if (tile) {
            tile.uses--;
            delete this._tiles[id];

            if (tile.uses <= 0) {
                delete tile.timeAdded;
                if (!tile.loaded) {
                    tile.abort();
                    tile.remove();
                } else {
                    this._cache.add(id, tile);
                }

                this.fire('tile.remove', {tile: tile});
            }
        }
    },

    // Taken from polymaps src/Layer.js
    // https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

    // scan-line conversion
    _scanTriangle: function(a, b, c, ymin, ymax, scanLine) {
        var ab = this._edge(a, b),
            bc = this._edge(b, c),
            ca = this._edge(c, a);

        var t;

        // sort edges by y-length
        if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
        if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
        if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }

        // scan span! scan span!
        if (ab.dy) this._scanSpans(ca, ab, ymin, ymax, scanLine);
        if (bc.dy) this._scanSpans(ca, bc, ymin, ymax, scanLine);
    },

    // scan-line conversion
    _edge: function(a, b) {
        if (a.row > b.row) { var t = a; a = b; b = t; }
        return {
            x0: a.column,
            y0: a.row,
            x1: b.column,
            y1: b.row,
            dx: b.column - a.column,
            dy: b.row - a.row
        };
    },

    // scan-line conversion
    _scanSpans: function(e0, e1, ymin, ymax, scanLine) {
        var y0 = Math.max(ymin, Math.floor(e1.y0)),
            y1 = Math.min(ymax, Math.ceil(e1.y1));

        // sort edges by x-coordinate
        if ((e0.x0 == e1.x0 && e0.y0 == e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
            var t = e0; e0 = e1; e1 = t;
        }

        // scan lines!
        var m0 = e0.dx / e0.dy,
            m1 = e1.dx / e1.dy,
            d0 = e0.dx > 0, // use y + 1 to compute x0
            d1 = e1.dx < 0; // use y + 1 to compute x1
        for (var y = y0; y < y1; y++) {
            var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0,
                x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
            scanLine(Math.floor(x1), Math.ceil(x0), y);
        }
    },

    _z_order: function(a, b) {
        return (b % 32) - (a % 32);
    },

    _centerOut: function(a, b) {
        var tr = this.map.transform;
        var aPos = TileCoord.fromID(a);
        var bPos = TileCoord.fromID(b);
        var c = TileCoord.zoomTo(tr.locationCoordinate(tr.center), aPos.z);
        var center = new Point(c.column - 0.5, c.row - 0.5);
        return center.dist(aPos) - center.dist(bPos);
    },
});

var sources = {
    vector: Source,
    raster: Source,
    geojson: require('./geojsonsource'),
    video: require('./videosource')
};

Source.create = function(source) {
    return new sources[source.type](source);
};

},{"../util/ajax.js":76,"../util/evented.js":82,"../util/mapbox.js":84,"../util/mrucache.js":85,"../util/util.js":87,"./geojsonsource":35,"./rastertile.js":38,"./tilecoord":41,"./vectortile":43,"./videosource":44,"point-geometry":95}],40:[function(require,module,exports){
'use strict';

var glmatrix = require('../lib/glmatrix.js'),
    mat2 = glmatrix.mat2,
    mat4 = glmatrix.mat4,
    vec2 = glmatrix.vec2;

module.exports = Tile;

function Tile() {}

Tile.prototype = {
    // todo unhardcode
    tileExtent: 4096,

    calculateMatrices: function(z, x, y, transform, painter) {

        // Initialize model-view matrix that converts from the tile coordinates
        // to screen coordinates.
        var tileScale = Math.pow(2, z);
        var scale = transform.worldSize / tileScale;

        // TODO: remove
        this.scale = scale;

        // The position matrix
        this.posMatrix = mat4.create();
        mat4.translate(this.posMatrix, this.posMatrix, [transform.centerPoint.x, transform.centerPoint.y, 0]);
        mat4.rotateZ(this.posMatrix, this.posMatrix, transform.angle);
        mat4.translate(this.posMatrix, this.posMatrix, [-transform.centerPoint.x, -transform.centerPoint.y, 0]);

        var pixelX = transform.width / 2 - transform.x,
            pixelY = transform.height / 2 - transform.y;

        mat4.translate(this.posMatrix, this.posMatrix, [pixelX + x * scale, pixelY + y * scale, 1]);

        // Create inverted matrix for interaction
        this.invPosMatrix = mat4.create();
        mat4.invert(this.invPosMatrix, this.posMatrix);

        mat4.scale(this.posMatrix, this.posMatrix, [ scale / this.tileExtent, scale / this.tileExtent, 1 ]);
        mat4.multiply(this.posMatrix, painter.projectionMatrix, this.posMatrix);

        // The extrusion matrix.
        this.exMatrix = mat4.clone(painter.projectionMatrix);
        mat4.rotateZ(this.exMatrix, this.exMatrix, transform.angle);

        // 2x2 matrix for rotating points
        this.rotationMatrix = mat2.create();
        mat2.rotate(this.rotationMatrix, this.rotationMatrix, transform.angle);
    },

    positionAt: function(id, point) {
        // tile hasn't finished loading
        if (!this.invPosMatrix) return null;

        var pos = vec2.transformMat4([], [point.x, point.y], this.invPosMatrix);
        vec2.scale(pos, pos, 4096 / this.scale);
        return {
            x: pos[0],
            y: pos[1],
            scale: this.scale
        };
    },

    featuresAt: function(pos, params, callback) {
        this.source.map.dispatcher.send('query features', {
            id: this.id,
            x: pos.x,
            y: pos.y,
            scale: pos.scale,
            source: this.source.id,
            params: params
        }, callback, this.workerID);
    }
};

},{"../lib/glmatrix.js":21}],41:[function(require,module,exports){
'use strict';

/*
 * Tiles are generally represented as packed integer ids constructed by
 * `TileCoord.toID(x, y, z)`
 */

var TileCoord = exports;

TileCoord.toID = function(z, x, y, w) {
    w = w || 0;
    w *= 2;
    if (w < 0) w = w * -1 -1;
    var dim = 1 << z;
    return ((dim * dim * w + dim * y + x) * 32) + z;
};

TileCoord.asString = function(id) {
    var pos = TileCoord.fromID(id);
    return pos.z + "/" + pos.x + "/" + pos.y;
};

/*
 * Parse a packed integer id into an object with x, y, and z properties
 */
TileCoord.fromID = function(id) {
    var z = id % 32, dim = 1 << z;
    var xy = ((id - z) / 32);
    var x = xy % dim, y = ((xy - x) / dim) % dim;
    var w = Math.floor(xy / (dim * dim));
    if (w % 2 !== 0) w = w * -1 -1;
    w /= 2;
    return { z: z, x: x, y: y, w: w };
};

/*
 * Given a packed integer id, return its zoom level
 */
TileCoord.zoom = function(id) {
    return id % 32;
};

// Given an id and a list of urls, choose a url template and return a tile URL
TileCoord.url = function(id, urls) {
    var pos = TileCoord.fromID(id);

    return urls[(pos.x + pos.y) % urls.length]
        .replace('{h}', (pos.x % 16).toString(16) + (pos.y % 16).toString(16))
        .replace('{z}', pos.z)
        .replace('{x}', pos.x)
        .replace('{y}', pos.y);
};

/*
 * Given a packed integer id, return the id of its parent tile
 */
TileCoord.parent = function(id) {
    var pos = TileCoord.fromID(id);
    if (pos.z === 0) return id;
    else return TileCoord.toID(pos.z - 1, Math.floor(pos.x / 2), Math.floor(pos.y / 2));
};

TileCoord.parentWithZoom = function(id, zoom) {
    var pos = TileCoord.fromID(id);
    while (pos.z > zoom) {
        pos.z--;
        pos.x = Math.floor(pos.x / 2);
        pos.y = Math.floor(pos.y / 2);
    }
    return TileCoord.toID(pos.z, pos.x, pos.y);
};

/*
 * Given a packed integer id, return an array of integer ids representing
 * its four children.
 */
TileCoord.children = function(id) {
    var pos = TileCoord.fromID(id);
    pos.z += 1;
    pos.x *= 2;
    pos.y *= 2;
    return [
        TileCoord.toID(pos.z, pos.x, pos.y, pos.w),
        TileCoord.toID(pos.z, pos.x + 1, pos.y, pos.w),
        TileCoord.toID(pos.z, pos.x, pos.y + 1, pos.w),
        TileCoord.toID(pos.z, pos.x + 1, pos.y + 1, pos.w)
    ];
};

TileCoord.zoomTo = function(c, z) {
    c.column = c.column * Math.pow(2, z - c.zoom);
    c.row = c.row * Math.pow(2, z - c.zoom);
    c.zoom = z;
    return c;
};


},{}],42:[function(require,module,exports){
'use strict';

var rewind = require('geojson-rewind');

var TileCoord = require('./tilecoord.js');
var Transform = require('../geo/transform.js');
var Point = require('point-geometry');
var LatLng = require('../geo/latlng.js');

module.exports = tileGeoJSON;

function tileGeoJSON(geojson, zoom) {
    var tiles = {};
    var tileExtent = 4096;
    var transform = new Transform();
    transform.zoom = zoom;

    geojson = rewind(geojson);

    if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            tileFeature(geojson.features[i], transform, tiles, tileExtent);
        }

    } else if (geojson.type === 'Feature') {
        tileFeature(geojson, transform, tiles, tileExtent);

    } else {
        throw('Unrecognized geojson type');
    }

    return tiles;
}

function tileFeature(feature, transform, tiles, tileExtent) {
    var coords = feature.geometry.coordinates;
    var type = feature.geometry.type;

    var tiled;
    if (type === 'Point') {
        tiled = tileLineString([coords], transform, tileExtent);

    } else if (type === 'LineString' || type === 'MultiPoint') {
        tiled = tileLineString(coords, transform, tileExtent);

    } else if (type === 'Polygon' || type === 'MultiLineString') {
        tiled = {};
        for (var i = 0; i < coords.length; i++) {
            var tiled_ = tileLineString(coords[i], transform, tileExtent, type === 'Polygon');
            for (var tileID in tiled_) {
                if (!tiled[tileID]) tiled[tileID] = [];
                tiled[tileID] = (tiled[tileID] || []).concat(tiled_[tileID]);
            }
        }

    } else if (type === 'MultiPolygon') {
        throw("todo");
    } else {
        throw("unrecognized geometry type");
    }

    for (var id in tiled) {
        tiles[id] = tiles[id] || [];
        tiles[id].push({
            properties: feature.properties,
            coords: tiled[id],
            type: feature.geometry.type
        });
    }
}

function tileLineString(coords, transform, tileExtent, rejoin) {

    var padding = 0.01;
    var paddedExtent = tileExtent * (1 + 2 * padding);
    var coord = transform.locationCoordinate(new LatLng(coords[0][1], coords[0][0]));
    var prevCoord;

    var tiles = {};

    for (var i = 0; i < coords.length; i++) {
        prevCoord = coord;
        coord = transform.locationCoordinate(new LatLng(coords[i][1], coords[i][0]));

        var dx = coord.column - prevCoord.column || Number.MIN_VALUE,
            dy = coord.row - prevCoord.row || Number.MIN_VALUE,
            dirX = dx / Math.abs(dx),
            dirY = dy / Math.abs(dy);

        // Find the rectangular bounding box, in tiles, of the polygon
        var startTileX = Math.floor(prevCoord.column - dirX * padding);
        var endTileX = Math.floor(coord.column + dirX * padding);
        var startTileY = Math.floor(prevCoord.row - dirY * padding);
        var endTileY = Math.floor(coord.row + dirY * padding);

        // Iterate over all tiles the segment might intersect
        // and split the segment across those tiles
        for (var x = startTileX; (x - endTileX) * dirX <= 0; x += dirX) {
            var leftX = (x - padding - prevCoord.column) / dx;
            var rightX = (x + 1 + padding - prevCoord.column) / dx;

            for (var y = startTileY; (y - endTileY) * dirY <= 0; y += dirY) {
                var topY = (y - padding - prevCoord.row) / dy;
                var bottomY = (y + 1 + padding - prevCoord.row) / dy;

                // fraction of the distance along the segment at which the segment
                // enters or exits the tile
                var enter = Math.max(Math.min(leftX, rightX), Math.min(topY, bottomY));
                var exit = Math.min(Math.max(leftX, rightX), Math.max(topY, bottomY));

                var tileID = TileCoord.toID(transform.tileZoom, x, y),
                    tile = tiles[tileID],
                    point;

                // segments starts outside the tile, add entry point
                if (0 <= enter && enter < 1) {
                    point = new Point(
                        ((prevCoord.column + enter * dx) - x) * tileExtent,
                        ((prevCoord.row + enter * dy) - y) * tileExtent);

                    point.continues = true;

                    if (!tile) tiles[tileID] = tile = [];
                    tile.push([point]);
                }

                // segments ends outside the tile, add exit point
                if (0 <= exit && exit < 1) {
                    point = new Point(
                        ((prevCoord.column + exit * dx) - x) * tileExtent,
                        ((prevCoord.row + exit * dy) - y) * tileExtent);

                    point.continues = true;

                    tile[tile.length - 1].push(point);

                // add the point itself
                } else {
                    point = new Point(
                        (coord.column - x) * tileExtent,
                        (coord.row - y) * tileExtent);

                    if (!tile) tiles[tileID] = tile = [[point]];
                    else tile[tile.length - 1].push(point);
                }
            }
        }
    }

    if (rejoin) {
        // reassemble the disconnected segments into a linestring
        // sections of the linestring outside the tile are replaced with segments
        // that follow the tile's edge
        for (var id in tiles) {

            var segments = tiles[id];

            if (!segments[0][0].continues && segments.length > 1) {
                // if the first segment is the beginning of the linestring
                // then join it with the last so that all segments start and
                // end at tile boundaries
                var last = segments.pop();
                Array.prototype.unshift.apply(segments[0], last.slice(0, last.length - 1));
            }

            var start = edgeDist(segments[0][0], tileExtent, padding);

            for (var k = 0; k < segments.length; k++) {
                // Add all tile corners along the path between the current segment's exit point
                // and the next segment's entry point

                var thisExit = edgeDist(segments[k][segments[k].length - 1], paddedExtent);
                var nextEntry = edgeDist(segments[(k + 1) % segments.length][0], paddedExtent);

                var startToExit = (thisExit - start + 4) % 4;
                var startToNextEntry = (nextEntry - start + 4) % 4;
                var direction = (thisExit === nextEntry || startToExit < startToNextEntry) ? 1 : -1;
                var roundFn = direction > 0 ? Math.ceil : Math.floor;

                for (var c = roundFn(thisExit) % 4; c != roundFn(nextEntry) % 4; c = (c + direction + 4) % 4) {
                    var corner = corners[c];
                    segments[k].push(new Point(
                        (corner.x + (corner.x - 0.5 > 0 ? 1 : -1) * padding) * tileExtent,
                        (corner.y + (corner.y - 0.5 > 0 ? 1 : -1) * padding) * tileExtent));
                }
            }

            // Join all segments
            tiles[id] = [Array.prototype.concat.apply([], segments)];
        }
    }

    return tiles;

}

var corners = [
    new Point(0, 0),
    new Point(1, 0),
    new Point(1, 1),
    new Point(0, 1)];

/*
 * Converts to a point to the distance along the edge of the tile (out of 4).
 *
 *         0.5
 *     0 _______ 1
 *      |       |
 *  3.5 |       | 1.5
 *      |       |
 *      |_______|
 *     3   2.5   2
 */
function edgeDist(point, extent) {
    var x = point.x / extent;
    var y = point.y / extent;
    var d;
    if (Math.abs(y - 0.5) >= Math.abs(x - 0.5)) {
        d = Math.round(y) * 2 + (y < 0.5 ? x : 1 - x);
    } else {
        d = Math.round(1 - x) * 2 + (x > 0.5 ? y : 1 - y) + 1;
    }

    return d % 4;
}

},{"../geo/latlng.js":17,"../geo/transform.js":19,"./tilecoord.js":41,"geojson-rewind":89,"point-geometry":95}],43:[function(require,module,exports){
'use strict';

var Tile = require('./tile.js'),
    TileCoord = require('./tilecoord.js'),
    BufferSet = require('../data/buffer/bufferset.js'),
    util = require('../util/util.js');

var createBucket = require('../data/createbucket.js');

module.exports = VectorTile;

function VectorTile(id, source, url, callback) {
    this.id = id;
    this.loaded = false;
    this.url = url;
    this.zoom = TileCoord.fromID(id).z;
    this.map = source.map;
    this.id = util.uniqueId();
    this.callback = callback;
    this.source = source;

    if (this.zoom >= source.maxzoom) {
        this.depth = this.map.options.maxZoom - this.zoom;
    } else {
        this.depth = 1;
    }
    this.uses = 1;
    this._load();
}

VectorTile.prototype = util.inherit(Tile, {

    _load: function() {
        var tile = this;
        this.workerID = this.map.dispatcher.send('load tile', {
            url: this.url,
            id: this.id,
            zoom: this.zoom,
            maxZoom: this.source.maxzoom,
            tileSize: this.source.tileSize,
            source: this.source.id,
            depth: this.depth
        }, function(err, data) {
            if (!err && data) {
                tile.onTileLoad(data);
            }
            tile.callback(err);
        });
    },

    onTileLoad: function(data) {

        // Tile has been removed from the map
        if (!this.map) return;

        this.buffers = new BufferSet(data.buffers);

        this.buckets = {};
        for (var b in data.elementGroups) {
            this.buckets[b] = createBucket(this.map.style.buckets[b], this.buffers, undefined, data.elementGroups[b]);
          if (data && data.elementGroups[b] && data.elementGroups[b].groups && data.elementGroups[b].groups.length){
            info[b] = true;
            
          }
        }
        this.loaded = true;
        updateInfo(); 
        setTimeout(function(){
          info = {};
        },10000);
    },

    remove: function() {

        // reuse prerendered textures
        for (var bucket in this.buckets) {
            if (this.buckets[bucket].prerendered) this.map.painter.saveTexture(this.buckets[bucket].prerendered.texture);
        }

        this.map.dispatcher.send('remove tile', { id: this.id, source: this.source.id }, null, this.workerID);
        this.map.painter.glyphAtlas.removeGlyphs(this.id);

        var gl = this.map.painter.gl;
        var buffers = this.buffers;
        if (buffers) {
            for (var b in buffers) {
                buffers[b].destroy(gl);
            }
        }
        delete this.map;
    },

    abort: function() {
        this.map.dispatcher.send('abort tile', { id: this.id, source: this.source.id }, null, this.workerID);
    }
});

},{"../data/buffer/bufferset.js":2,"../data/createbucket.js":10,"../util/util.js":87,"./tile.js":40,"./tilecoord.js":41}],44:[function(require,module,exports){
'use strict';

var util = require('../util/util.js');
var Tile = require('./tile.js');
var TileCoord = require('./tilecoord.js');
var LatLng = require('../geo/latlng.js');
var Point = require('point-geometry');
var Source = require('./source.js');

module.exports = VideoSource;

function VideoSource(options) {
    this.video = document.createElement('video');
    this.video.crossOrigin = 'Anonymous';
    this.video.loop = true;

    var urls = (typeof options.url === 'string') ? [options.url] : options.url;

    for (var i = 0; i < urls.length; i++) {
        var s = document.createElement('source');
        s.src = urls[i];
        this.video.appendChild(s);
    }

    this.coordinates = options.coordinates;
    this.enabled = true;

    var loopID;
    var source = this;

    // start repainting when video starts playing
    this.video.addEventListener('playing', function() {
        loopID = source.map.style.animationLoop.set(Infinity);
        source.map._rerender();
    });

    // stop repainting when video stops
    this.video.addEventListener('pause', function() {
        source.map.style.animationLoop.cancel(loopID);
    });
}

VideoSource.prototype = util.inherit(Source, {
    onAdd: function(map) {
        this.map = map;
        this.video.play();
        this.createTile();
    },

    createTile: function() {
        /*
         * Calculate which mercator tile is suitable for rendering the video in
         * and create a buffer with the corner coordinates. These coordinates
         * may be outside the tile, because raster tiles aren't clipped when rendering.
         */
        var map = this.map;
        var coords = this.coordinates.map(function(latlng) {
            var loc = LatLng.convert(latlng);
            return TileCoord.zoomTo(map.transform.locationCoordinate(loc), 0);
        });

        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;

        for (var i = 0; i < coords.length; i++) {
            minX = Math.min(minX, coords[i].column);
            minY = Math.min(minY, coords[i].row);
            maxX = Math.max(maxX, coords[i].column);
            maxY = Math.max(maxY, coords[i].row);
        }

        var dx = maxX - minX;
        var dy = maxY - minY;
        var dMax = Math.max(dx, dy);
        var center = TileCoord.zoomTo({
            column: (minX + maxX) / 2,
            row: (minY + maxY) / 2,
            zoom: 0
        }, Math.floor(-Math.log(dMax) / Math.LN2));

        var tileExtent = 4096;
        var tileCoords = coords.map(function(coord) {
            var zoomedCoord = TileCoord.zoomTo(coord, center.zoom);
            return new Point(
                Math.round((zoomedCoord.column - center.column) * tileExtent),
                Math.round((zoomedCoord.row - center.row) * tileExtent));
        });

        var gl = map.painter.gl;
        var maxInt16 = 32767;
        var array = new Int16Array([
            tileCoords[0].x, tileCoords[0].y, 0, 0,
            tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
            tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
            tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
        ]);
        this.boundsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.boundsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);

        this.tile = new Tile();
        this.center = center;
    },

    load: function() {
        // noop
    },

    update: function() {
        // noop
    },

    render: function(layers) {
        if (!this.enabled) return;
        if (this.video.readyState < 2) return; // not enough data for current position

        var layer = layers[0];

        var bucket = {
            type: 'raster',
            tile: this,
            boundsBuffer: this.boundsBuffer,
            bind: this.bind.bind(this)
        };

        var buckets = {};
        buckets[layer.bucket] = bucket;

        var c = this.center;
        this.tile.calculateMatrices(c.zoom, c.column, c.row, this.map.transform, this.map.painter);
        this.map.painter.tile = this.tile;
        this.map.painter.applyStyle(layer, this.map.style, buckets, {});
    },

    bind: function(gl) {
        if (!this.texture) {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);

        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        }
    },

    featuresAt: function(point, params, callback) {
        // TODO return pixel?
        return callback(null, []);
    }
});

},{"../geo/latlng.js":17,"../util/util.js":87,"./source.js":39,"./tile.js":40,"./tilecoord.js":41,"point-geometry":95}],45:[function(require,module,exports){
'use strict';

var Actor = require('../util/actor.js'),
    bucketFilter = require('../style/bucketfilter.js'),
    WorkerTile = require('./workertile.js'),
    tileGeoJSON = require('./tilegeojson.js'),
    Wrapper = require('./geojsonwrapper.js'),
    util = require('../util/util.js'),
    queue = require('queue-async'),
    ajax = require('../util/ajax.js');

module.exports = Worker;

function Worker(self) {
    this.self = self;
    this.actor = new Actor(self, this);
}

util.extend(Worker.prototype, {
    alert: function() {
        this.self.postMessage({
            type: 'alert message',
            data: [].slice.call(arguments)
        });
    },

    // Updates the style to use for this map.
    'set buckets': function(data) {
        var buckets = WorkerTile.buckets = data;
        for (var i = 0; i < buckets.length; i++) {
            var bucket = buckets[i];
            bucket.compare = bucketFilter(bucket.filter);
        }
    },

    'set glyphs': function(data) {
        WorkerTile.prototype.glyphs = data;
    },

    /*
     * Load and parse a tile at `url`, and call `callback` with
     * (err, response)
     *
     * @param {string} url
     * @param {function} callback
     */
    'load tile': function(params, callback) {
        new WorkerTile(params.url, undefined, params.id, params.zoom, params.maxZoom, params.tileSize, params.source, params.depth, this.actor, callback);
    },

    /*
     * Abort the request keyed under `url`
     *
     * @param {string} url
     */
    'abort tile': function(params) {
        WorkerTile.cancel(params.id, params.source);
    },

    'remove tile': function(params) {
        var id = params.id;
        var source = params.source;
        if (WorkerTile.loaded[source] && WorkerTile.loaded[source][id]) {
            delete WorkerTile.loaded[source][id];
        }
    },

    'parse geojson': function(params, callback) {
        var data = params.data,
            zooms = params.zooms,
            len = zooms.length,
            maxZoom = zooms[len - 1],
            actor = this.actor,
            q = queue();

        function worker(id, tile, zoom, callback) {
            new WorkerTile(undefined, new Wrapper(tile), id, zoom, maxZoom, params.tileSize, params.source, 4, actor, function(err, data) {
                if (err) return callback(err);
                data.id = id;
                callback(null, data);
            });
        }

        function tileData(err, data) {
            if (err) throw err;
            for (var i = 0; i < len; i++) {
                var zoom = zooms[i];
                var tiles = tileGeoJSON(data, zoom);
                for (var id in tiles) {
                    q.defer(worker, id, tiles[id], zoom);
                }
            }
            q.awaitAll(callback);
        }

        if (typeof data === 'string') ajax.getJSON(data, tileData);
        else tileData(null, data);
    },

    'query features': function(params, callback) {
        var tile = WorkerTile.loaded[params.source] && WorkerTile.loaded[params.source][params.id];
        if (tile) {
            tile.featureTree.query(params, callback);
        } else {
            callback(null, []);
        }
    }
});

},{"../style/bucketfilter.js":48,"../util/actor.js":75,"../util/ajax.js":76,"../util/util.js":87,"./geojsonwrapper.js":37,"./tilegeojson.js":42,"./workertile.js":46,"queue-async":96}],46:[function(require,module,exports){
'use strict';

var FeatureTree = require('../data/featuretree.js');
var Protobuf = require('pbf');
var vt = require('vector-tile');
var Collision = require('../symbol/collision.js');
var getArrayBuffer = require('../util/ajax.js').getArrayBuffer;

var BufferSet = require('../data/buffer/bufferset.js');
var createBucket = require('../data/createbucket.js');

module.exports = WorkerTile;
function WorkerTile(url, data, id, zoom, maxZoom, tileSize, source, depth, actor, callback) {
    var tile = this;
    this.id = id;
    this.zoom = zoom;
    this.maxZoom = maxZoom;
    this.tileSize = tileSize;
    this.source = source;
    this.depth = depth;
    this.buffers = new BufferSet();

    function loaded(data) {
        WorkerTile.loaded[source] = WorkerTile.loaded[source] || {};
        WorkerTile.loaded[source][id] = tile;
        tile.data = data;
        tile.parse(data, actor, callback);
    }

    if (url) {
        if (WorkerTile.loading[source] === undefined) WorkerTile.loading[source] = {};
        WorkerTile.loading[source][id] = getArrayBuffer(url, function(err, data) {
            delete WorkerTile.loading[source][id];
            if (err) {
                callback(err);
            } else {
                loaded(new vt.VectorTile(new Protobuf(new Uint8Array(data))));
            }
        });
    } else {
        loaded(data);
    }
}

WorkerTile.cancel = function(id, sourceID) {
    var source = WorkerTile.loading[sourceID];
    if (source && source[id]) {
        source[id].abort();
        delete source[id];
    }
};

// Stores tiles that are currently loading.
WorkerTile.loading = {};

// Stores tiles that are currently loaded.
WorkerTile.loaded = {};

// Stores the style information.
WorkerTile.buckets = [];

/*
 * Given tile data, parse raw vertices and data, create a vector
 * tile and parse it into ready-to-render vertices.
 *
 * @param {object} data
 * @param {function} respond
 */
WorkerTile.prototype.parse = function(data, actor, callback) {
    var tile = this;
    var bucketInfo = WorkerTile.buckets;
    this.callback = callback;

    var tileExtent = 4096;
    this.collision = new Collision(this.zoom, tileExtent, this.tileSize, this.depth);
    this.featureTree = new FeatureTree(getGeometry, getType);

    var buckets = this.buckets = sortTileIntoBuckets(this, data, bucketInfo);

    var key, bucket;
    var prevPlacementBucket;

    var remaining = WorkerTile.buckets.length;

    /*
     *  The async parsing here is a bit tricky.
     *  Some buckets depend on resources that may need to be loaded async (glyphs).
     *  Some buckets need to be parsed in order (to get placement priorities right).
     *
     *  Dependencies calls are initiated first to get those rolling.
     *  Buckets that don't need to be parsed in order, aren't to save time.
     */

    var orderedBuckets = WorkerTile.buckets;
    for (var i = 0; i < orderedBuckets.length; i++) {
        bucket = buckets[orderedBuckets[i].id];
        if (!bucket) {
            remaining--;
            continue; // raster bucket, etc
        }

        var filter = bucket.info.filter;
        if (filter && filter.source !== this.source) continue;

        // Link buckets that need to be parsed in order
        if (bucket.collision) {
            if (prevPlacementBucket) {
                prevPlacementBucket.next = bucket;
            } else {
                bucket.previousPlaced = true;
            }
            prevPlacementBucket = bucket;
        }

        if (bucket.getDependencies) {
            bucket.getDependencies(this, actor, dependenciesDone(bucket));
        }

    }

    // parse buckets where order doesn't matter and no dependencies
    for (key in buckets) {
        bucket = buckets[key];
        if (!bucket.getDependencies && !bucket.collision) {
            parseBucket(tile, bucket);
        }
    }

    function dependenciesDone(bucket) {
        return function(err) {
            bucket.dependenciesLoaded = true;
            parseBucket(tile, bucket, err);
        };
    }

    function parseBucket(tile, bucket, skip) {
        if (bucket.getDependencies && !bucket.dependenciesLoaded) return;
        if (bucket.collision && !bucket.previousPlaced) return;

        if (!skip) {
            var now = Date.now();
            if (bucket.type !== 'raster') bucket.addFeatures();
            var time = Date.now() - now;
            if (bucket.interactive) {
                for (var i = 0; i < bucket.features.length; i++) {
                    var feature = bucket.features[i];
                    tile.featureTree.insert(feature.bbox(), bucket.name, feature);
                }
            }
            if (typeof self !== 'undefined') {
                self.bucketStats = self.bucketStats || {_total: 0};
                self.bucketStats._total += time;
                self.bucketStats[bucket.name] = (self.bucketStats[bucket.name] || 0) + time;
            }
        }

        remaining--;
        if (!remaining) return tile.done();

        // try parsing the next bucket, if it is ready
        if (bucket.next) {
            bucket.next.previousPlaced = true;
            parseBucket(tile, bucket.next);
        }
    }
};

WorkerTile.prototype.done = function() {
    // Collect all buffers to mark them as transferable object.
    var buffers = [];

    for (var type in this.buffers) {
        buffers.push(this.buffers[type].array);
    }

    // Convert buckets to a transferable format
    var buckets = this.buckets;
    var elementGroups = {};
    for (var b in buckets) elementGroups[b] = buckets[b].elementGroups;

    this.callback(null, {
        elementGroups: elementGroups,
        buffers: this.buffers
    }, buffers);

    // we don't need anything except featureTree at this point, so we mark it for GC
    this.buffers = null;
    this.collision = null;
    this.buckets = null;
};

function sortTileIntoBuckets(tile, data, bucketInfo) {

    var sourceLayers = {},
        buckets = {},
        layerName;

    // For each source layer, find a list of buckets that use data from it
    for (var i = 0; i < bucketInfo.length; i++) {
        var info = bucketInfo[i];
        var bucketName = info.id;

        var minZoom = info['min-zoom'];
        var maxZoom = info['max-zoom'];

        if (info.source !== tile.source) continue;
        if (minZoom && tile.zoom < minZoom && minZoom < tile.maxZoom) continue;
        if (maxZoom && tile.zoom >= maxZoom) continue;

        var bucket = createBucket(info, tile.buffers, tile.collision);
        if (!bucket) continue;
        bucket.features = [];
        bucket.name = bucketName;
        buckets[bucketName] = bucket;

        if (data.layers) {
            // vectortile
            layerName = info['source-layer'];
            if (!sourceLayers[layerName]) sourceLayers[layerName] = {};
            sourceLayers[layerName][bucketName] = info;
        } else {
            // geojson tile
            sourceLayers[bucketName] = info;
        }
    }

    // read each layer, and sort its feature's into buckets
    if (data.layers) {
        // vectortile
        for (layerName in sourceLayers) {
            var layer = data.layers[layerName];
            if (!layer) continue;
            sortLayerIntoBuckets(layer, sourceLayers[layerName], buckets);
        }
    } else {
        // geojson
        sortLayerIntoBuckets(data, sourceLayers, buckets);
    }

    return buckets;
}

/*
 * Sorts features in a layer into different buckets, according to the maping
 *
 * Layers in vector tiles contain many different features, and feature types,
 * e.g. the landuse layer has parks, industrial buildings, forests, playgrounds
 * etc. However, when styling, we need to separate these features so that we can
 * render them separately with different styles.
 *
 * @param {VectorTileLayer} layer
 * @param {Mapping} mapping
 */
function sortLayerIntoBuckets(layer, mapping, buckets) {
    for (var i = 0; i < layer.length; i++) {
        var feature = layer.feature(i);
        for (var key in mapping) {
            if (mapping[key].compare(feature)) {
                buckets[key].features.push(feature);
            }
        }
    }
}

function getGeometry(feature) {
    return feature.loadGeometry();
}

function getType(feature) {
    return vt.VectorTileFeature.types[feature.type];
}

},{"../data/buffer/bufferset.js":2,"../data/createbucket.js":10,"../data/featuretree.js":12,"../symbol/collision.js":59,"../util/ajax.js":76,"pbf":93,"vector-tile":99}],47:[function(require,module,exports){
'use strict';

module.exports = AnimationLoop;

function AnimationLoop() {
    this.n = 0;
    this.times = [];
}

// Are all animations done?
AnimationLoop.prototype.stopped = function() {
    this.times = this.times.filter(function(t) {
        return t.time >= (new Date()).getTime();
    });
    return !this.times.length;
};

// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
AnimationLoop.prototype.set = function(t) {
    this.times.push({ id: this.n, time: t + (new Date()).getTime() });
    return this.n++;
};

// Cancel an animation
AnimationLoop.prototype.cancel = function(n) {
    this.times = this.times.filter(function(t) {
        return t.id != n;
    });
};

},{}],48:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('vector-tile').VectorTileFeature;

function infix(operator) {
    return function(left, right) { return left + ' ' + operator + ' ' + right; };
}

var infixOperators = {
    '==': infix('==='),
    '>': infix('>'), '$gt': infix('>'),
    '<': infix('<'), '$lt': infix('<'),
    '<=': infix('<='), '$lte': infix('<='),
    '>=': infix('>='), '$gte': infix('>='),
    '!=': infix('!=='), '$ne': infix('!=='),
    '$exists': function (value) { return value + ' !== undefined'; }
};

function or(items)  { return '(' + items.join(' || ') + ')'; }
function and(items) { return '(' + items.join(' && ') + ')'; }
function not(item)  { return '!' + item; }
function nor(items) { return not(or(items)); }

var arrayOperators = {
    '||': or, '$or': or,
    '&&': and, '$and': and,
    '!': nor, '$nor': nor
};

var objOperators = {
    '!': not, '$not': not
};

module.exports = function (filter) {
    // simple key & value comparison
    function valueFilter(key, value, operator) {
        return operator('p[' + JSON.stringify(key) + ']', JSON.stringify(value));
    }

    // compares key & value or key & or(values)
    function simpleFieldFilter(key, value, operator) {
        var operatorFn = infixOperators[operator || '=='];
        if (!operatorFn) throw new Error('Unknown operator: ' + operator);

        if (Array.isArray(value)) {
            return or(value.map(function (v) {
                return valueFilter(key, v, operatorFn);
            }));

        } else return valueFilter(key, value, operatorFn);
    }

    // handles any filter key/value pair
    function fieldFilter(key, value) {

        if (Array.isArray(value)) {
            if (key in arrayOperators) { // handle and/or operators
                return arrayOperators[key](value.map(fieldsFilter));
            }

        } else if (typeof value === 'object') {

            // handle not operator
            if (key in objOperators) return objOperators[key](fieldsFilter(value));

            // handle {key: {operator: value}} notation
            var filters = [];
            for (var op in value) {
                filters.push(simpleFieldFilter(key, value[op], op));
            }
            return and(filters);

        }
        // handle simple key/value or key/values comparison
        return simpleFieldFilter(key, value);
    }

    function typeFilter(type) {
        return 'f.type === ' + VectorTileFeature.types.indexOf(type);
    }

    function fieldsFilter(obj) {
        var filters = [];

        for (var key in obj) {
            if (key === '$type') {
                filters.push(typeFilter(obj[key]));
            } else {
                filters.push(fieldFilter(key, obj[key]));
            }
        }

        return filters.length ? and(filters) : 'true';
    }

    var filterStr = 'var p = f.properties || {}; return ' + fieldsFilter(filter || {}) + ';';

    // jshint evil: true
    return new Function('f', filterStr);
};

},{"vector-tile":99}],49:[function(require,module,exports){
'use strict';

var reference = require('./reference');

module.exports = {};

reference['class'].forEach(function(className) {
    var Calculated = function() {};
    var style = reference[className];
    for (var prop in style) {
        if (style[prop]['default'] === undefined) continue;
        Calculated.prototype[prop] = style[prop]['default'];
    }
    Calculated.prototype.hidden = false;
    module.exports[className.replace('class_','')] = Calculated;
});


},{"./reference":51}],50:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented.js');
var ajax = require('../util/ajax.js');
var browser = require('../util/browser.js');

module.exports = ImageSprite;

function ImageSprite(base) {

    var sprite = this;
    this.base = base;
    this.retina = browser.devicePixelRatio > 1;

    base = sprite.base + (sprite.retina ? '@2x' : '');

    ajax.getJSON(base + '.json', function(err, data) {
        // @TODO handle errors via sprite event.
        if (err) return;
        sprite.data = data;
        if (sprite.img) sprite.fire('loaded');
    });

    ajax.getImage(base + '.png', function(err, img) {
        // @TODO handle errors via sprite event.
        if (err) return;

        // premultiply the sprite
        var data = img.getData();
        var newdata = img.data = new Uint8Array(data.length);
        for (var i = 0; i < data.length; i+=4) {
            var alpha = data[i + 3] / 255;
            newdata[i + 0] = data[i + 0] * alpha;
            newdata[i + 1] = data[i + 1] * alpha;
            newdata[i + 2] = data[i + 2] * alpha;
            newdata[i + 3] = data[i + 3];
        }

        sprite.img = img;
        if (sprite.data) sprite.fire('loaded');
    });
}

ImageSprite.prototype = Object.create(Evented);

ImageSprite.prototype.toJSON = function() {
    return this.base;
};

ImageSprite.prototype.loaded = function() {
    return !!(this.data && this.img);
};

ImageSprite.prototype.resize = function(gl) {
    var sprite = this;
    if (browser.devicePixelRatio > 1 !== sprite.retina) {

        var newSprite = new ImageSprite(sprite.base);
        newSprite.on('loaded', function() {

            sprite.img = newSprite.img;
            sprite.data = newSprite.data;
            sprite.retina = newSprite.retina;

            if (sprite.texture) {
                gl.deleteTexture(sprite.texture);
                delete sprite.texture;
            }

        });
    }
};

ImageSprite.prototype.bind = function(gl, linear) {
    var sprite = this;

    if (!sprite.loaded())
        return;

    if (!sprite.texture) {
        sprite.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, sprite.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var img = sprite.img;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, img.width, img.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, img.data);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, sprite.texture);
    }

    var filter = linear ? gl.LINEAR : gl.NEAREST;
    if (filter !== sprite.filter) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    }
};

ImageSprite.prototype.getPosition = function(name, repeating) {

    // `repeating` indicates that the image will be used in a repeating pattern
    // repeating pattern images are assumed to have a 1px padding that mirrors the opposite edge
    // positions for repeating images are adjusted to exclude the edge
    repeating = repeating === true ? 1 : 0;

    var pos = this.data && this.data[name];
    if (pos && this.img) {
        var width = this.img.width;
        var height = this.img.height;
        return {
            size: [pos.width / pos.pixelRatio, pos.height / pos.pixelRatio],
            tl: [(pos.x + repeating)/ width, (pos.y + repeating) / height],
            br: [(pos.x + pos.width - 2 * repeating) / width, (pos.y + pos.height - 2 * repeating) / height]
        };
    }
};

},{"../util/ajax.js":76,"../util/browser.js":77,"../util/evented.js":82}],51:[function(require,module,exports){
module.exports = require('mapbox-gl-style-spec/reference/v5');

},{"mapbox-gl-style-spec/reference/v5":92}],52:[function(require,module,exports){
'use strict';

var reference = require('./reference');

module.exports = {};

reference.render.forEach(function(className) {
    var Properties = function(props) {
        for (var p in props) {
            this[p] = props[p];
        }
    };

    var properties = reference[className];
    for (var prop in properties) {
        if (properties[prop]['default'] === undefined) continue;
        Properties.prototype[prop] = properties[prop]['default'];
    }
    module.exports[className.replace('render_','')] = Properties;
});


},{"./reference":51}],53:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented.js');

var StyleTransition = require('./styletransition.js');
var StyleDeclaration = require('./styledeclaration.js');
var StyleConstant = require('./styleconstant.js');
var CalculatedStyle = require('./calculatedstyle.js');
var ImageSprite = require('./imagesprite.js');

var util = require('../util/util.js');

module.exports = Style;

/*
 * The map style's current state
 *
 * The stylesheet object is not modified. To change the style, just change
 * the the stylesheet object and trigger a cascade.
 */
function Style(stylesheet, animationLoop) {
    if (stylesheet.version !== 5) console.warn('Stylesheet version must be 5');
    if (!Array.isArray(stylesheet.layers)) console.warn('Stylesheet must have layers');

    this.classes = {};
    this.stylesheet = stylesheet;
    this.animationLoop = animationLoop;

    this.buckets = {};
    this.orderedBuckets = [];
    this.transitions = {};
    this.computed = {};
    this.sources = {};

    this.cascade({transition: false});

    if (stylesheet.sprite) this.setSprite(stylesheet.sprite);
}

Style.prototype = Object.create(Evented);

function premultiplyLayer(layer, type) {
    var colorProp = type + '-color',
        haloProp = type + '-halo-color',
        outlineProp = type + '-outline-color',
        color = layer[colorProp],
        haloColor = layer[haloProp],
        outlineColor = layer[outlineProp],
        opacity = layer[type + '-opacity'];

    var colorOpacity = color && (opacity * color[3]);
    var haloOpacity = haloColor && (opacity * haloColor[3]);
    var outlineOpacity = outlineColor && (opacity * outlineColor[3]);

    if (colorOpacity !== undefined && colorOpacity < 1) {
        layer[colorProp] = util.premultiply([color[0], color[1], color[2], colorOpacity]);
    }
    if (haloOpacity !== undefined && haloOpacity < 1) {
        layer[haloProp] = util.premultiply([haloColor[0], haloColor[1], haloColor[2], haloOpacity]);
    }
    if (outlineOpacity !== undefined && outlineOpacity < 1) {
        layer[outlineProp] = util.premultiply([outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity]);
    }
}

// Formerly known as zoomed styles
Style.prototype.recalculate = function(z) {
    if (typeof z !== 'number') console.warn('recalculate expects zoom level');

    var transitions = this.transitions;
    var layerValues = {};

    this.sources = {};

    this.rasterFadeDuration = 300;

    for (var name in transitions) {
        var layer = transitions[name],
            bucket = this.buckets[layer.ref || name],
            layerType = this.layermap[name].type;

        if (!CalculatedStyle[layerType]) {
            console.warn('unknown layer type ' + layerType);
            continue;
        }
        var appliedLayer = layerValues[name] = new CalculatedStyle[layerType]();
        for (var rule in layer) {
            var transition = layer[rule];
            appliedLayer[rule] = transition.at(z);
        }

        if (layerType === 'symbol') {
            if ((appliedLayer['text-opacity'] === 0 || !bucket.render['text-field']) &&
                (appliedLayer['icon-opacity'] === 0 || !bucket.render['icon-image'])) {
                appliedLayer.hidden = true;
            } else {
                premultiplyLayer(appliedLayer, 'text');
                premultiplyLayer(appliedLayer, 'icon');
            }
        } else {
            if (appliedLayer[layerType + '-opacity'] === 0) {
                appliedLayer.hidden = true;
            } else {
                premultiplyLayer(appliedLayer, layerType);
            }
        }

        // Find all the sources that are currently being used
        // so that we can automatically enable/disable them as needed
        if (!appliedLayer.hidden) {
            var source = bucket && bucket.source;

            // mark source as used so that tiles are downloaded
            if (source) this.sources[source] = true;
        }

        if (appliedLayer['raster-fade-duration']) {
            this.rasterFadeDuration = Math.max(this.rasterFadeDuration, appliedLayer['raster-fade-duration']);
        }
    }

    this.computed = layerValues;

    this.z = z;
    this.fire('zoom');
};

Style.prototype._simpleLayer = function(layer) {
    var simple = {};
    simple.id = layer.id;

    var bucket = this.buckets[layer.ref || layer.id];
    if (bucket) simple.bucket = bucket.id;
    if (layer.type) simple.type = layer.type;

    if (layer.layers) {
        simple.layers = [];
        for (var i = 0; i < layer.layers.length; i++) {
            simple.layers.push(this._simpleLayer(layer.layers[i]));
        }
    }
    return simple;
};

// Split the layers into groups of consecutive layers with the same datasource
Style.prototype._groupLayers = function(layers) {
    var g = 0;
    var groups = [];
    var group;

    // loop over layers top down
    for (var i = layers.length - 1; i >= 0; i--) {
        var layer = layers[i];

        var bucket = this.buckets[layer.ref || layer.id];
        var source = bucket && bucket.source;

        // if the current layer is in a different source
        if (group && source !== group.source) g++;

        if (!groups[g]) {
            group = [];
            group.source = source;
            groups[g] = group;
        }

        group.push(this._simpleLayer(layer));
    }

    return groups;
};

/*
 * Take all the rules and declarations from the stylesheet,
 * and figure out which apply currently
 */
Style.prototype.cascade = function(options) {
    options = options || {
        transition: true
    };

    var a, b;
    var id;
    var prop;
    var layer;
    var className;
    var styleName;
    var style;
    var styleTrans;
    var constants = this.stylesheet.constants;

    // derive buckets from layers
    this.orderedBuckets = [];
    this.buckets = getbuckets({}, this.orderedBuckets, this.stylesheet.layers);
    function getbuckets(buckets, ordered, layers) {
        for (var a = 0; a < layers.length; a++) {
            var layer = layers[a];
            if (layer.layers) {
                buckets = getbuckets(buckets, ordered, layer.layers);
            }
            if (!layer.source || !layer.type) {
                continue;
            }
            var bucket = { id: layer.id };
            for (var prop in layer) {
                if ((/^style/).test(prop)) continue;
                bucket[prop] = layer[prop];
            }
            bucket.render = StyleConstant.resolve(bucket.render, constants);
            buckets[layer.id] = bucket;
            ordered.push(bucket);
        }
        return buckets;
    }

    // style class keys
    var styleNames = ['style'];
    for (className in this.classes) styleNames.push('style.' + className);

    // apply layer group inheritance resulting in a flattened array
    var flattened = flattenLayers(this.stylesheet.layers);

    // map layer ids to layer definitions for resolving refs
    var layermap = this.layermap = {};
    for (a = 0; a < flattened.length; a++) {
        layer = flattened[a];

        var newLayer = {};
        for (var k in layer) {
            if (k === 'layers') continue;
            newLayer[k] = layer[k];
        }

        layermap[layer.id] = newLayer;
        flattened[a] = newLayer;
    }

    for (a = 0; a < flattened.length; a++) {
        flattened[a] = resolveLayer(layermap, flattened[a]);
    }

    // Resolve layer references.
    function resolveLayer(layermap, layer) {
        if (!layer.ref || !layermap[layer.ref]) return layer;

        var parent = resolveLayer(layermap, layermap[layer.ref]);
        layer.render = parent.render;
        layer.type = parent.type;
        layer.filter = parent.filter;
        layer.source = parent.source;
        layer['source-layer'] = parent['source-layer'];
        layer['min-zoom'] = parent['min-zoom'];
        layer['max-zoom'] = parent['max-zoom'];

        return layer;
    }

    // Flatten composite layer structures.
    function flattenLayers(layers) {
        var flat = [];
        for (var i = 0; i < layers.length; i++) {
            flat.push(layers[i]);
            if (layers[i].layers) {
                flat.push.apply(flat, flattenLayers(layers[i].layers));
            }
        }
        return flat;
    }

    var transitions = {};
    var globalTrans = this.stylesheet.transition;

    for (a in flattened) {
        layer = flattened[a];

        id = layer.id;
        style = {};
        styleTrans = {};

        // basic cascading of styles
        for (b = 0; b < styleNames.length; b++) {
            styleName = styleNames[b];
            if (!layer[styleName]) continue;
            // set style properties
            for (prop in layer[styleName]) {
                if (prop.indexOf('transition-') === -1) {
                    style[prop] = layer[styleName][prop];
                } else {
                    styleTrans[prop.replace('transition-', '')] = layer[styleName][prop];
                }
            }
        }

        style = StyleConstant.resolve(style, constants);

        var renderType = layer.type;
        transitions[id] = {};

        for (prop in style) {
            var newDeclaration = new StyleDeclaration(renderType, prop, style[prop]);
            var oldTransition = this.transitions[id] && this.transitions[id][prop];
            var newStyleTrans = {};
            newStyleTrans.duration = styleTrans[prop] && styleTrans[prop].duration ? styleTrans[prop].duration : globalTrans && globalTrans.duration ? globalTrans.duration : 300;
            newStyleTrans.delay = styleTrans[prop] && styleTrans[prop].delay ? styleTrans[prop].delay : globalTrans && globalTrans.delay ? globalTrans.delay : 0;

            if (!options.transition) {
                newStyleTrans.duration = 0;
                newStyleTrans.delay = 0;
            }

            // Only create a new transition if the declaration changed
            if (!oldTransition || oldTransition.declaration.json !== newDeclaration.json) {
                var newTransition = new StyleTransition(newDeclaration, oldTransition, newStyleTrans);
                transitions[id][prop] = newTransition;

                // Run the animation loop until the end of the transition
                if (!newTransition.instant()) {
                    newTransition.loopID = this.animationLoop.set(newTransition.endTime - (new Date()).getTime());
                }

                if (oldTransition) {
                    this.animationLoop.cancel(oldTransition.loopID);
                }
            } else {
                transitions[id][prop] = oldTransition;
            }
        }
    }

    this.transitions = transitions;
    this.layerGroups = this._groupLayers(this.stylesheet.layers);

    this.fire('change');
};

/* This should be moved elsewhere. Localizing resources doesn't belong here */
Style.prototype.setSprite = function(sprite) {
    this.sprite = new ImageSprite(sprite);
    this.sprite.on('loaded', this.fire.bind(this, 'change'));
};

// Modify classes
Style.prototype.addClass = function(n, options) {
    if (this.classes[n]) return; // prevent unnecessary recalculation
    this.classes[n] = true;
    this.cascade(options);
};

Style.prototype.removeClass = function(n, options) {
    if (!this.classes[n]) return; // prevent unnecessary recalculation
    delete this.classes[n];
    this.cascade(options);
};

Style.prototype.hasClass = function(n) {
    return !!this.classes[n];
};

Style.prototype.setClassList = function(l, options) {
    this.classes = {};
    for (var i = 0; i < l.length; i++) {
        this.classes[l[i]] = true;
    }
    this.cascade(options);
};

Style.prototype.getClassList = function() {
    return Object.keys(this.classes);
};

Style.prototype.getLayer = function(id) {
    return this.layermap[id];
};

},{"../util/evented.js":82,"../util/util.js":87,"./calculatedstyle.js":49,"./imagesprite.js":50,"./styleconstant.js":54,"./styledeclaration.js":55,"./styletransition.js":56}],54:[function(require,module,exports){
'use strict';

var util = require('../util/util.js');

module.exports.resolve = function (properties, constants) {
    if (!constants)
        return properties;

    var result = {}, i;

    function resolve(value) {
        return typeof value === 'string' && value[0] === '@' ? constants[value] : value;
    }

    for (var key in properties) {
        var value = resolve(properties[key]);

        if (Array.isArray(value)) {
            value = value.slice();

            for (i = 0; i < value.length; i++) {
                if (value[i] in constants) {
                    value[i] = resolve(value[i]);
                }
            }
        }

        if (value.stops) {
            value = util.extend({}, value);
            value.stops = value.stops.slice();

            for (i = 0; i < value.stops.length; i++) {
                if (value.stops[i][1] in constants) {
                    value.stops[i] = [
                                value.stops[i][0],
                        resolve(value.stops[i][1])
                    ];
                }
            }
        }

        result[key] = value;
    }

    return result;
};

},{"../util/util.js":87}],55:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    reference = require('./reference'),
    parseCSSColor = require('csscolorparser').parseCSSColor;

module.exports = StyleDeclaration;

/*
 * A parsed representation of a property:value pair
 */
function StyleDeclaration(renderType, prop, value) {
    var className = 'class_' + renderType;
    var propReference = reference[className] && reference[className][prop];
    if (!propReference) return;

    this.value = this.parseValue(value, propReference.type, propReference.values);
    this.prop = prop;
    this.type = propReference.type;

    // immuatable representation of value. used for comparison
    this.json = JSON.stringify(value);

}

StyleDeclaration.prototype.calculate = function(z) {
    return typeof this.value === 'function' ? this.value(z) : this.value;
};

StyleDeclaration.prototype.parseValue = function(value, type, values) {
    if (type === 'color') {
        return parseColor(value);
    } else if (type === 'number') {
        return parseNumber(value);
    } else if (type === 'boolean') {
        return Boolean(value);
    } else if (type === 'image') {
        return String(value);
    } else if (type === 'string') {
        return String(value);
    } else if (type === 'array') {
        return parseNumberArray(value);
    } else if (type === 'enum' && Array.isArray(values)) {
        return values.indexOf(value) >= 0 ? value : undefined;
    } else {
        console.warn(type + ' is not a supported property type');
    }
};

function parseNumber(num) {
    if (num.stops) num = stopsFn(num);
    var value = +num;
    return !isNaN(value) ? value : num;
}

function parseNumberArray(array) {
    var widths = array.map(parseNumber);

    return function(z) {
        var result = [];
        for (var i = 0; i < widths.length; i++) {
            result.push(typeof widths[i] === 'function' ? widths[i](z) : widths[i]);
        }
        return result;
    };
}

var colorCache = {};

function parseColor(value) {
    if (value.stops) return stopsFn(value, true);
    if (colorCache[value]) return colorCache[value];

    var color = colorCache[value] = prepareColor(parseCSSColor(value));
    return color;
}

function stopsFn(params, color) {
    var stops = params.stops;
    var base = params.base || reference.function.base.default;

    return function(z) {

        // find the two stops which the current z is between
        var low, high;

        for (var i = 0; i < stops.length; i++) {
            var stop = stops[i];
            if (stop[0] <= z) low = stop;
            if (stop[0] > z) {
                high = stop;
                break;
            }
        }

        if (low && high) {
            var zoomDiff = high[0] - low[0],
                zoomProgress = z - low[0],

                t = base === 1 ?
                    zoomProgress / zoomDiff :
                    (Math.pow(base, zoomProgress) - 1) / (Math.pow(base, zoomDiff) - 1);

            if (color) return interpColor(parseColor(low[1]), parseColor(high[1]), t);
            else return util.interp(low[1], high[1], t);

        } else if (low) {
            if (color) return parseColor(low[1]);
            else return low[1];

        } else if (high) {
            if (color) return parseColor(high[1]);
            else return high[1];

        } else {
            if (color) return [0, 0, 0, 1];
            else return 1;
        }
    };
}

function prepareColor(c) {
    return [c[0] / 255, c[1] / 255, c[2] / 255, c[3] / 1];
}

function interpColor(from, to, t) {
    return [
        util.interp(from[0], to[0], t),
        util.interp(from[1], to[1], t),
        util.interp(from[2], to[2], t),
        util.interp(from[3], to[3], t)
    ];
}

},{"../util/util.js":87,"./reference":51,"csscolorparser":88}],56:[function(require,module,exports){
'use strict';

var util = require('../util/util.js');

module.exports = StyleTransition;

/*
 * Represents a transition between two declarations
 */
function StyleTransition(declaration, oldTransition, value) {

    this.declaration = declaration;
    this.startTime = this.endTime = (new Date()).getTime();

    var type = declaration.type;
    if (type === 'number') {
        this.interp = util.interp;
    } else if (type === 'color') {
        this.interp = interpColor;
    } else if (type === 'array') {
        this.interp = interpNumberArray;
    }

    this.oldTransition = oldTransition;
    this.duration = value.duration || 0;
    this.delay = value.delay || 0;

    if (!this.instant()) {
        this.endTime = this.startTime + this.duration + this.delay;
        this.ease = util.easeCubicInOut;
    }

    if (oldTransition && oldTransition.endTime <= this.startTime) {
        // Old transition is done running, so we can
        // delete its reference to its old transition.

        delete oldTransition.oldTransition;
    }
}

StyleTransition.prototype.instant = function() {
    return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
};

/*
 * Return the value of the transitioning property at zoom level `z` and optional time `t`
 */
StyleTransition.prototype.at = function(z, t) {

    var value = this.declaration.calculate(z);

    if (this.instant()) return value;

    t = t || Date.now();

    if (t < this.endTime) {
        var oldValue = this.oldTransition.at(z, this.startTime);
        var eased = this.ease((t - this.startTime - this.delay) / this.duration);
        value = this.interp(oldValue, value, eased);
    }

    return value;

};

function interpNumberArray(from, to, t) {
    return from.map(function(d, i) {
        return util.interp(d, to[i], t);
    });
}

function interpColor(from, to, t) {
    return [
        util.interp(from[0], to[0], t),
        util.interp(from[1], to[1], t),
        util.interp(from[2], to[2], t),
        util.interp(from[3], to[3], t)
    ];
}

},{"../util/util.js":87}],57:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = Anchor;

function Anchor(x, y, angle, scale, segment) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.scale = scale;

    if (segment !== undefined) {
        this.segment = segment;
    }
}

Anchor.prototype = Object.create(Point.prototype);

Anchor.prototype.clone = function() {
    return new Anchor(this.x, this.y, this.angle, this.scale, this.segment);
};

},{"point-geometry":95}],58:[function(require,module,exports){
'use strict';

module.exports = BinPack;
function BinPack(width, height) {
    this.width = width;
    this.height = height;
    this.free = [{ x: 0, y: 0, w: width, h: height }];
}

BinPack.prototype.release = function(rect) {
    // Simple algorithm to recursively merge the newly released cell with its
    // neighbor. This doesn't merge more than two cells at a time, and fails
    // for complicated merges.
    for (var i = 0; i < this.free.length; i++) {
        var free = this.free[i];
        if (free.y == rect.y && free.h == rect.h && free.x + free.w == rect.x) {
            free.w += rect.w;
        }
        else if (free.x == rect.x && free.w == rect.w && free.y + free.h == rect.y) {
            free.h += rect.h;
        }
        else if (rect.y == free.y && rect.h == free.h && rect.x + rect.w == free.x) {
            free.x = rect.x;
            free.w += rect.w;
        }
        else if (rect.x == free.x && rect.w == free.w && rect.y + rect.h == free.y) {
            free.y = rect.y;
            free.h += rect.h;
        } else {
            continue;
        }

        this.free.splice(i, 1);
        this.release(free);
        return;

    }
    this.free.push(rect);
};

BinPack.prototype.allocate = function(width, height) {
    // Find the smallest free rect angle
    var rect = { x: Infinity, y: Infinity, w: Infinity, h: Infinity };
    var smallest = -1;
    for (var i = 0; i < this.free.length; i++) {
        var ref = this.free[i];
        if (width <= ref.w && height <= ref.h && ref.y <= rect.y && ref.x <= rect.x) {
            rect = ref;
            smallest = i;
        }
    }

    if (smallest < 0) {
        // There's no space left for this char.
        return { x: -1, y: -1 };
    } else {
        this.free.splice(smallest, 1);

        // Shorter/Longer Axis Split Rule (SAS)
        // http://clb.demon.fi/files/RectangleBinPack.pdf p. 15
        // Ignore the dimension of R and just split long the shorter dimension
        // See Also: http://www.cs.princeton.edu/~chazelle/pubs/blbinpacking.pdf
        if (rect.w < rect.h) {
            // split horizontally
            // +--+---+
            // |__|___|  <-- b1
            // +------+  <-- b2
            if (rect.w > width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: height });
            if (rect.h > height) this.free.push({ x: rect.x, y: rect.y + height, w: rect.w, h: rect.h - height });
        } else {
            // split vertically
            // +--+---+
            // |__|   | <-- b1
            // +--|---+ <-- b2
            if (rect.w > width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: rect.h });
            if (rect.h > height) this.free.push({ x: rect.x, y: rect.y + height, w: width, h: rect.h - height });
        }

        return { x: rect.x, y: rect.y, w: width, h: height };
    }
};

},{}],59:[function(require,module,exports){
'use strict';

var rbush = require('rbush'),
    rotationRange = require('./rotationrange.js'),
    Point = require('point-geometry');

module.exports = Collision;

function Collision(zoom, tileExtent, tileSize, placementDepth) {
    this.hTree = rbush(); // tree for horizontal labels
    this.cTree = rbush(); // tree for glyphs from curved labels

    // tile pixels per screen pixels at the tile's zoom level
    this.tilePixelRatio = tileExtent / tileSize;

    this.zoom = zoom;

    // Calculate the maximum scale we can go down in our fake-3d rtree so that
    // placement still makes sense. This is calculated so that the minimum
    // placement zoom can be at most 25.5 (we use an unsigned integer x10 to
    // store the minimum zoom).
    //
    // We don't want to place labels all the way to 25.5. This lets too many
    // glyphs be placed, slowing down collision checking. Only place labels if
    // they will show up within the intended zoom range of the tile.
    placementDepth = Math.min(3, placementDepth || 1, 25.5 - this.zoom);
    this.maxPlacementScale = Math.exp(Math.LN2 * placementDepth);

    var m = 4096;
    var edge = m * this.tilePixelRatio * 2;

    var fullRange = [Math.PI * 2, 0];

    this.left = {
        anchor: new Point(0, 0),
        box: { x1: -edge, y1: -edge, x2: 0, y2: edge },
        placementRange: fullRange,
        placementScale: 0.5,
        maxScale: Infinity,
        padding: 0
    };

    this.top = {
        anchor: new Point(0, 0),
        box: { x1: -edge, y1: -edge, x2: edge, y2: 0 },
        placementRange: fullRange,
        placementScale: 0.5,
        maxScale: Infinity,
        padding: 0
    };

    this.bottom = {
        anchor: new Point(m, m),
        box: { x1: -edge, y1: 0, x2: edge, y2: edge },
        placementRange: fullRange,
        placementScale: 0.5,
        maxScale: Infinity,
        padding: 0
    };

    this.right = {
        anchor: new Point(m, m),
        box: { x1: 0, y1: -edge, x2: edge, y2: edge },
        placementRange: fullRange,
        placementScale: 0.5,
        maxScale: Infinity,
        padding: 0
    };

}

Collision.prototype.getPlacementScale = function(glyphs, minPlacementScale, avoidEdges) {

    var left = this.left;
    var right = this.right;
    var top = this.top;
    var bottom = this.bottom;

    for (var k = 0; k < glyphs.length; k++) {

        var glyph = glyphs[k];
        var box = glyph.box;
        var bbox = glyph.hBox || box;
        var anchor = glyph.anchor;
        var pad = glyph.padding;

        var minScale = Math.max(minPlacementScale, glyph.minScale);
        var maxScale = glyph.maxScale || Infinity;

        if (minScale >= maxScale) continue;

        // Compute the scaled bounding box of the unrotated glyph
        var searchBox = this.getBox(anchor, bbox, minScale, maxScale);

        var blocking = this.hTree.search(searchBox).concat(this.cTree.search(searchBox));

        if (avoidEdges) {
            if (searchBox[0] < 0) blocking.push(left);
            if (searchBox[1] < 0) blocking.push(top);
            if (searchBox[2] >= 4096) blocking.push(right);
            if (searchBox[3] >= 4096) blocking.push(bottom);
        }

        if (blocking.length) {

            var na = anchor; // new anchor
            var nb = box; // new box

            for (var l = 0; l < blocking.length; l++) {
                var oa = blocking[l].anchor; // old anchor
                var ob = blocking[l].box; // old box

                // If anchors are identical, we're going to skip the label.
                // NOTE: this isn't right because there can be glyphs with
                // the same anchor but differing box offsets.
                if (na.equals(oa)) {
                    return null;
                }

                // todo: unhardcode the 8 = tileExtent/tileSize
                var padding = Math.max(pad, blocking[l].padding) * 8;

                // Original algorithm:
                var s1 = (ob.x1 - nb.x2 - padding) / (na.x - oa.x); // scale at which new box is to the left of old box
                var s2 = (ob.x2 - nb.x1 + padding) / (na.x - oa.x); // scale at which new box is to the right of old box
                var s3 = (ob.y1 - nb.y2 - padding) / (na.y - oa.y); // scale at which new box is to the top of old box
                var s4 = (ob.y2 - nb.y1 + padding) / (na.y - oa.y); // scale at which new box is to the bottom of old box

                if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
                if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;

                var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));

                // Only update label's min scale if the glyph was restricted by a collision
                if (collisionFreeScale > minPlacementScale &&
                    collisionFreeScale > minScale &&
                    collisionFreeScale < maxScale &&
                    collisionFreeScale < blocking[l].maxScale) {
                    minPlacementScale = collisionFreeScale;
                }

                if (minPlacementScale > this.maxPlacementScale) {
                    return null;
                }
            }

        }
    }

    return minPlacementScale;
};

Collision.prototype.getPlacementRange = function(glyphs, placementScale, horizontal) {

    var placementRange = [2*Math.PI, 0];

    for (var k = 0; k < glyphs.length; k++) {
        var glyph = glyphs[k];
        var bbox = glyph.hBox || glyph.box;
        var anchor = glyph.anchor;

        var minPlacedX = anchor.x + bbox.x1 / placementScale;
        var minPlacedY = anchor.y + bbox.y1 / placementScale;
        var maxPlacedX = anchor.x + bbox.x2 / placementScale;
        var maxPlacedY = anchor.y + bbox.y2 / placementScale;

        var searchBox = [minPlacedX, minPlacedY, maxPlacedX, maxPlacedY];

        var blocking = this.hTree.search(searchBox);

        if (horizontal) {
            blocking = blocking.concat(this.cTree.search(searchBox));
        }

        for (var l = 0; l < blocking.length; l++) {
            var b = blocking[l];
            var bbox2 = b.hBox || b.box;

            var x1, x2, y1, y2, intersectX, intersectY;

            // Adjust and compare bboxes to see if the glyphs might intersect
            if (placementScale > b.placementScale) {
                x1 = b.anchor.x + bbox2.x1 / placementScale;
                y1 = b.anchor.y + bbox2.y1 / placementScale;
                x2 = b.anchor.x + bbox2.x2 / placementScale;
                y2 = b.anchor.y + bbox2.y2 / placementScale;
                intersectX = x1 < maxPlacedX && x2 > minPlacedX;
                intersectY = y1 < maxPlacedY && y2 > minPlacedY;
            } else {
                x1 = anchor.x + bbox.x1 / b.placementScale;
                y1 = anchor.y + bbox.y1 / b.placementScale;
                x2 = anchor.x + bbox.x2 / b.placementScale;
                y2 = anchor.y + bbox.y2 / b.placementScale;
                intersectX = x1 < b[2] && x2 > b[0];
                intersectY = y1 < b[3] && y2 > b[1];
            }

            // If they can't intersect, skip more expensive rotation calculation
            if (!(intersectX && intersectY)) continue;

            var scale = Math.max(placementScale, b.placementScale);
            var range = rotationRange.rotationRange(glyph, b, scale);

            placementRange[0] = Math.min(placementRange[0], range[0]);
            placementRange[1] = Math.max(placementRange[1], range[1]);
        }
    }

    return placementRange;

};

// Insert glyph placements into rtree.
Collision.prototype.insert = function(glyphs, anchor, placementScale, placementRange, horizontal) {

    var allBounds = [];

    for (var k = 0; k < glyphs.length; k++) {

        var glyph = glyphs[k];
        var bbox = glyph.hBox || glyph.box;

        var minScale = Math.max(placementScale, glyph.minScale);
        var maxScale = glyph.maxScale || Infinity;

        var bounds = this.getBox(anchor, bbox, minScale, maxScale);

        bounds.anchor = anchor;
        bounds.box = glyph.box;
        if (glyph.hBox) bounds.hBox = bbox;
        bounds.placementRange = placementRange;
        bounds.placementScale = minScale;
        bounds.maxScale = maxScale;
        bounds.padding = glyph.padding;

        allBounds.push(bounds);
    }

    (horizontal ? this.hTree : this.cTree).load(allBounds);
};

Collision.prototype.getBox = function(anchor, bbox, minScale, maxScale) {
    return [
        anchor.x + Math.min(bbox.x1 / minScale, bbox.x1 / maxScale),
        anchor.y + Math.min(bbox.y1 / minScale, bbox.y1 / maxScale),
        anchor.x + Math.max(bbox.x2 / minScale, bbox.x2 / maxScale),
        anchor.y + Math.max(bbox.y2 / minScale, bbox.y2 / maxScale)];
};

},{"./rotationrange.js":65,"point-geometry":95,"rbush":97}],60:[function(require,module,exports){
'use strict';

var BinPack = require('./binpack.js');

module.exports = GlyphAtlas;
function GlyphAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new BinPack(width, height);
    this.index = {};
    this.ids = {};
    this.data = new Uint8Array(width * height);
}

GlyphAtlas.prototype = {
    get debug() {
        return 'canvas' in this;
    },
    set debug(value) {
        if (value && !this.canvas) {
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            document.body.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
        } else if (!value && this.canvas) {
            this.canvas.parentNode.removeChild(this.canvas);
            delete this.ctx;
            delete this.canvas;
        }
    }
};

GlyphAtlas.prototype.getGlyphs = function() {
    var glyphs = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!glyphs[name]) glyphs[name] = [];
        glyphs[name].push(id);
    }

    return glyphs;
};

GlyphAtlas.prototype.getRects = function() {
    var rects = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!rects[name]) rects[name] = {};
        rects[name][id] = this.index[key];
    }

    return rects;
};

GlyphAtlas.prototype.removeGlyphs = function(id) {
    for (var key in this.ids) {

        var ids = this.ids[key];

        var pos = ids.indexOf(id);
        if (pos >= 0) ids.splice(pos, 1);
        this.ids[key] = ids;

        if (!ids.length) {
            var rect = this.index[key];

            var target = this.data;
            for (var y = 0; y < rect.h; y++) {
                var y1 = this.width * (rect.y + y) + rect.x;
                for (var x = 0; x < rect.w; x++) {
                    target[y1 + x] = 0;
                }
            }

            this.dirty = true;

            this.bin.release(rect);

            delete this.index[key];
            delete this.ids[key];
        }
    }


    this.updateTexture(this.gl);
};

GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
    if (!glyph) {
        // console.warn('missing glyph', code, String.fromCharCode(code));
        return null;
    }
    var key = name + "#" + glyph.id;

    // The glyph is already in this texture.
    if (this.index[key]) {
        if (this.ids[key].indexOf(id) < 0) {
            this.ids[key].push(id);
        }
        return this.index[key];
    }

    // The glyph bitmap has zero width.
    if (!glyph.bitmap) {
        return null;
    }

    var buffered_width = glyph.width + buffer * 2;
    var buffered_height = glyph.height + buffer * 2;

    // Add a 1px border around every image.
    var pack_width = buffered_width;
    var pack_height = buffered_height;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    pack_width += (4 - pack_width % 4);
    pack_height += (4 - pack_height % 4);

    var rect = this.bin.allocate(pack_width, pack_height);
    if (rect.x < 0) {
        console.warn('glyph bitmap overflow');
        return { glyph: glyph, rect: null };
    }

    // Add left and top glyph offsets to rect.
    rect.l = glyph.left;
    rect.t = glyph.top;

    this.index[key] = rect;
    this.ids[key] = [id];

    var target = this.data;
    var source = glyph.bitmap;
    for (var y = 0; y < buffered_height; y++) {
        var y1 = this.width * (rect.y + y) + rect.x;
        var y2 = buffered_width * y;
        for (var x = 0; x < buffered_width; x++) {
            target[y1 + x] = source[y2 + x];
        }
    }

    this.dirty = true;

    return rect;
};

GlyphAtlas.prototype.bind = function(gl) {
    this.gl = gl;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }
};

GlyphAtlas.prototype.updateTexture = function(gl) {
    this.bind(gl);
    if (this.dirty) {

        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);

        // DEBUG
        if (this.ctx) {
            var data = this.ctx.getImageData(0, 0, this.width, this.height);
            for (var i = 0, j = 0; i < this.data.length; i++, j += 4) {
                data.data[j] = this.data[i];
                data.data[j+1] = this.data[i];
                data.data[j+2] = this.data[i];
                data.data[j+3] = 255;
            }
            this.ctx.putImageData(data, 0, 0);

            this.ctx.strokeStyle = 'red';
            for (var k = 0; k < this.bin.free.length; k++) {
                var free = this.bin.free[k];
                this.ctx.strokeRect(free.x, free.y, free.w, free.h);
            }
        }
        // END DEBUG

        this.dirty = false;
    }
};

},{"./binpack.js":58}],61:[function(require,module,exports){
'use strict';

var normalizeURL = require('../util/mapbox.js').normalizeGlyphsURL;
var getArrayBuffer = require('../util/ajax.js').getArrayBuffer;
var Glyphs = require('../util/glyphs.js');
var Protobuf = require('pbf');

module.exports = GlyphSource;

function GlyphSource(url, glyphAtlas) {
    this.url = url && normalizeURL(url);
    this.glyphAtlas = glyphAtlas;
    this.stacks = {};
    this.loading = {};
}

GlyphSource.prototype.getRects = function(fontstack, glyphIDs, tileID, callback) {

    if (this.stacks[fontstack] === undefined) this.stacks[fontstack] = {};

    var rects = {};
    var glyphs = {};
    var result = { rects: rects, glyphs: glyphs };

    var stack = this.stacks[fontstack];
    var glyphAtlas = this.glyphAtlas;

    var missing = {};
    var remaining = 0;

    for (var i = 0; i < glyphIDs.length; i++) {
        var glyphID = glyphIDs[i];
        var range = Math.floor(glyphID / 256);

        if (stack[range]) {
            var glyph = stack[range].glyphs[glyphID];
            var buffer = 3;
            rects[glyphID] = glyphAtlas.addGlyph(tileID, fontstack, glyph, buffer);
            if (glyph) glyphs[glyphID] = simpleGlyph(glyph);
        } else {
            if (missing[range] === undefined) {
                missing[range] = [];
                remaining++;
            }
            missing[range].push(glyphID);
        }
    }

    if (!remaining) callback(undefined, result);

    var glyphSource = this;
    for (var r in missing) {
        this.loadRange(fontstack, r, onRangeLoaded);
    }

    function onRangeLoaded(err, range, data) {
        // TODO not be silent about errors
        if (!err) {
            var stack = glyphSource.stacks[fontstack][range] = data.stacks[fontstack];
            for (var i = 0; i < missing[range].length; i++) {
                var glyphID = missing[range][i];
                var glyph = stack.glyphs[glyphID];
                var buffer = 3;
                rects[glyphID] = glyphAtlas.addGlyph(tileID, fontstack, glyph, buffer);
                if (glyph) glyphs[glyphID] = simpleGlyph(glyph);
            }
        }
        remaining--;
        if (!remaining) callback(undefined, result);
    }
};

function simpleGlyph(glyph) {
    return {
        advance: glyph.advance,
        left: glyph.left,
        top: glyph.top
    };
}

GlyphSource.prototype.loadRange = function(fontstack, range, callback) {

    if (range * 256 >= 65280) return callback('gyphs > 65280 not supported');

    if (this.loading[fontstack] === undefined) this.loading[fontstack] = {};
    var loading = this.loading[fontstack];

    if (loading[range]) {
        loading[range].push(callback);
    } else {
        loading[range] = [callback];

        var rangeName = (range * 256) + '-' + (range * 256 + 255);
        var url = glyphUrl(fontstack, rangeName, this.url);

        getArrayBuffer(url, function(err, data) {
            var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
            for (var i = 0; i < loading[range].length; i++) {
                loading[range][i](err, range, glyphs);
            }
            delete loading[range];
        });
    }
};

function glyphUrl(fontstack, range, url, subdomains) {
    subdomains = subdomains || 'abc';

    return url
        .replace('{s}', subdomains[fontstack.length % subdomains.length])
        .replace('{fontstack}', fontstack)
        .replace('{range}', range);
}

},{"../util/ajax.js":76,"../util/glyphs.js":83,"../util/mapbox.js":84,"pbf":93}],62:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    Anchor = require('../symbol/anchor.js');

module.exports = interpolate;

var minScale = 0.5;
var minScaleArrays = {
    1: [minScale],
    2: [minScale, 2],
    4: [minScale, 4, 2, 4],
    8: [minScale, 8, 4, 8, 2, 8, 4, 8]
};


function interpolate(vertices, spacing, minScale, maxScale, tilePixelRatio, start) {

    if (minScale === undefined) minScale = 0;

    maxScale = Math.round(Math.max(Math.min(8, maxScale / 2), 1));
    spacing *= tilePixelRatio / maxScale;
    var minScales = minScaleArrays[maxScale];
    var len = minScales.length;

    var distance = 0,
        markedDistance = 0,
        added = start || 0;

    var points = [];

    for (var i = 0; i < vertices.length - 1; i++) {

        var a = vertices[i],
            b = vertices[i + 1];

        var segmentDist = a.dist(b),
            angle = b.angleTo(a);

        while (markedDistance + spacing < distance + segmentDist) {
            markedDistance += spacing;

            var t = (markedDistance - distance) / segmentDist,
                x = util.interp(a.x, b.x, t),
                y = util.interp(a.y, b.y, t),
                s = minScales[added % len];

            if (x >= 0 && x < 4096 && y >= 0 && y < 4096) {
                points.push(new Anchor(x, y, angle, s, i));
            }

            added++;
        }

        distance += segmentDist;
    }

    return points;
}

},{"../symbol/anchor.js":57,"../util/util.js":87}],63:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = {
    getIcon: getIcon,
    getGlyphs: getGlyphs
};

var minScale = 0.5; // underscale by 1 zoom level

function getIcon(anchor, image, boxScale, line, props) {

    var x = image.width / 2 / image.pixelRatio;
    var y = image.height / 2 / image.pixelRatio;

    var dx = props['icon-offset'][0];
    var dy = props['icon-offset'][1];
    var x1 = (dx - x);
    var x2 = (dx + x);
    var y1 = (dy - y);
    var y2 = (dy + y);

    var tl = new Point(x1, y1);
    var tr = new Point(x2, y1);
    var br = new Point(x2, y2);
    var bl = new Point(x1, y2);

    var angle = props['icon-rotate'] * Math.PI / 180;
    if (anchor.segment !== undefined && props['icon-rotation-alignment'] !== 'viewport') {
        var next = line[anchor.segment];
        angle += -Math.atan2(next.x - anchor.x, next.y - anchor.y) + Math.PI / 2;
    }

    if (angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle),
            matrix = [cos, -sin, sin, cos];

        tl = tl.matMult(matrix);
        tr = tr.matMult(matrix);
        bl = bl.matMult(matrix);
        br = br.matMult(matrix);

        x1 = Math.min(tl.x, tr.x, bl.x, br.x);
        x2 = Math.max(tl.x, tr.x, bl.x, br.x);
        y1 = Math.min(tl.y, tr.y, bl.y, br.y);
        y2 = Math.max(tl.y, tr.y, bl.y, br.y);
    }
    var box = {
        x1: x1 * boxScale,
        x2: x2 * boxScale,
        y1: y1 * boxScale,
        y2: y2 * boxScale
    };

    var iconBox = {
        box: box,
        anchor: anchor,
        minScale: minScale,
        maxScale: Infinity,
        padding: props['icon-padding']
    };

    var icon = {
        tl: tl,
        tr: tr,
        br: br,
        bl: bl,
        tex: image,
        angle: 0,
        anchor: anchor,
        minScale: minScale,
        maxScale: Infinity
    };

    return {
        shapes: [icon],
        boxes: [iconBox],
        minScale: anchor.scale
    };
}

function getGlyphs(anchor, origin, shaping, faces, boxScale, horizontal, line, props) {

    var maxAngleDelta = props['text-max-angle'] * Math.PI / 180;
    var rotate = props['text-rotate'] * Math.PI / 180;
    var padding = props['text-padding'];
    var alongLine = props['text-rotation-alignment'] !== 'viewport';
    var keepUpright = props['text-keep-upright'];

    var glyphs = [],
        boxes = [];

    var buffer = 3;

    for (var k = 0; k < shaping.length; k++) {
        var shape = shaping[k];
        var fontstack = faces[shape.fontstack];
        var glyph = fontstack.glyphs[shape.glyph];
        var rect = fontstack.rects[shape.glyph];

        if (!glyph) continue;

        if (!(rect && rect.w > 0 && rect.h > 0)) continue;

        var x = (origin.x + shape.x + glyph.left - buffer + rect.w / 2) * boxScale;

        var glyphInstances;
        if (anchor.segment !== undefined && alongLine) {
            glyphInstances = [];
            getSegmentGlyphs(glyphInstances, anchor, x, line, anchor.segment, 1, maxAngleDelta);
            if (keepUpright) getSegmentGlyphs(glyphInstances, anchor, x, line, anchor.segment, -1, maxAngleDelta);

        } else {
            glyphInstances = [{
                anchor: anchor,
                offset: 0,
                angle: 0,
                maxScale: Infinity,
                minScale: minScale
            }];
        }

        var x1 = origin.x + shape.x + glyph.left - buffer,
            y1 = origin.y + shape.y - glyph.top - buffer,
            x2 = x1 + rect.w,
            y2 = y1 + rect.h,

            otl = new Point(x1, y1),
            otr = new Point(x2, y1),
            obl = new Point(x1, y2),
            obr = new Point(x2, y2);

        var obox = {
                x1: boxScale * x1,
                y1: boxScale * y1,
                x2: boxScale * x2,
                y2: boxScale * y2
            };

        for (var i = 0; i < glyphInstances.length; i++) {

            var instance = glyphInstances[i],

                tl = otl,
                tr = otr,
                bl = obl,
                br = obr,
                box = obox,

                // Clamp to -90/+90 degrees
                angle = instance.angle + rotate;

            if (angle) {
                // Compute the transformation matrix.
                var sin = Math.sin(angle),
                    cos = Math.cos(angle),
                    matrix = [cos, -sin, sin, cos];

                tl = tl.matMult(matrix);
                tr = tr.matMult(matrix);
                bl = bl.matMult(matrix);
                br = br.matMult(matrix);
            }

            // Prevent label from extending past the end of the line
            var glyphMinScale = Math.max(instance.minScale, anchor.scale);

            // Remember the glyph for later insertion.
            glyphs.push({
                tl: tl,
                tr: tr,
                bl: bl,
                br: br,
                tex: rect,
                angle: (anchor.angle + rotate + instance.offset + 2 * Math.PI) % (2 * Math.PI),
                anchor: instance.anchor,
                minScale: glyphMinScale,
                maxScale: instance.maxScale
            });

            if (!instance.offset) { // not a flipped glyph
                if (angle) {
                    // Calculate the rotated glyph's bounding box offsets from the anchor point.
                    box = {
                        x1: boxScale * Math.min(tl.x, tr.x, bl.x, br.x),
                        y1: boxScale * Math.min(tl.y, tr.y, bl.y, br.y),
                        x2: boxScale * Math.max(tl.x, tr.x, bl.x, br.x),
                        y2: boxScale * Math.max(tl.y, tr.y, bl.y, br.y)
                    };
                }
                boxes.push({
                    box: box,
                    anchor: instance.anchor,
                    minScale: glyphMinScale,
                    maxScale: instance.maxScale,
                    padding: padding
                });
            }
        }
    }

    // TODO avoid creating the boxes in the first place?
    if (horizontal) boxes = [getMergedBoxes(boxes, anchor)];

    var minPlacementScale = anchor.scale;
    var minGlyphScale = Infinity;
    for (var m = 0; m < boxes.length; m++) {
        minGlyphScale = Math.min(minGlyphScale, boxes[m].minScale);
    }
    minGlyphScale = Math.max(minPlacementScale, minScale);

    return {
        boxes: boxes,
        shapes: glyphs,
        minScale: minGlyphScale
    };
}

function getSegmentGlyphs(glyphs, anchor, offset, line, segment, direction, maxAngleDelta) {
    var upsideDown = direction < 0;

    if (offset < 0)  direction *= -1;

    if (direction > 0) segment++;

    var newAnchor = anchor;
    var end = line[segment];
    var prevscale = Infinity;
    var prevAngle;

    offset = Math.abs(offset);

    var placementScale = anchor.scale;

    segment_loop:
    while (true) {
        var dist = newAnchor.dist(end);
        var scale = offset/dist;
        var angle = -Math.atan2(end.x - newAnchor.x, end.y - newAnchor.y) + direction * Math.PI / 2;
        if (upsideDown) angle += Math.PI;

        // Don't place around sharp corners
        var angleDiff = (angle - prevAngle) % (2 * Math.PI);
        if (prevAngle && Math.abs(angleDiff) > maxAngleDelta) {
            anchor.scale = prevscale;
            break;
        }

        glyphs.push({
            anchor: newAnchor,
            offset: upsideDown ? Math.PI : 0,
            minScale: scale,
            maxScale: prevscale,
            angle: (angle + 2 * Math.PI) % (2 * Math.PI)
        });

        if (scale <= placementScale) break;

        newAnchor = end;

        // skip duplicate nodes
        while (newAnchor.equals(end)) {
            segment += direction;
            end = line[segment];

            if (!end) {
                anchor.scale = scale;
                break segment_loop;
            }
        }

        var unit = end.sub(newAnchor)._unit();
        newAnchor = newAnchor.sub(unit._mult(dist));

        prevscale = scale;
        prevAngle = angle;
    }
}

function getMergedBoxes(glyphs, anchor) {
      // Collision checks between rotating and fixed labels are relatively expensive,
      // so we use one box per label, not per glyph for horizontal labels.

    var mergedglyphs = {
        box: { x1: Infinity, y1: Infinity, x2: -Infinity, y2: -Infinity },
        anchor: anchor,
        minScale: 0,
        padding: -Infinity
    };

    var box = mergedglyphs.box;

    for (var m = 0; m < glyphs.length; m++) {
        var gbox = glyphs[m].box;
        box.x1 = Math.min(box.x1, gbox.x1);
        box.y1 = Math.min(box.y1, gbox.y1);
        box.x2 = Math.max(box.x2, gbox.x2);
        box.y2 = Math.max(box.y2, gbox.y2);
        mergedglyphs.minScale = Math.max(mergedglyphs.minScale, glyphs[m].minScale);
        mergedglyphs.padding = Math.max(mergedglyphs.padding, glyphs[m].padding);
    }
    // for all horizontal labels, calculate bbox covering all rotated positions
    var x12 = box.x1 * box.x1,
        y12 = box.y1 * box.y1,
        x22 = box.x2 * box.x2,
        y22 = box.y2 * box.y2,
        diag = Math.sqrt(Math.max(x12 + y12, x12 + y22, x22 + y12, x22 + y22));

    mergedglyphs.hBox = {
        x1: -diag,
        y1: -diag,
        x2: diag,
        y2: diag
    };

    return mergedglyphs;
}

},{"point-geometry":95}],64:[function(require,module,exports){
'use strict';

var resolveTokens = require('../util/token.js');

module.exports = resolveText;

// For an array of features determine what glyph ranges need to be loaded
// and apply any text preprocessing. The remaining users of text should
// use the `textFeatures` key returned by this function rather than accessing
// feature text directly.
function resolveText(features, info, glyphs) {
    var textFeatures = [];
    var codepoints = [];

    for (var i = 0, fl = features.length; i < fl; i++) {
        var text = resolveTokens(features[i].properties, info['text-field']);
        var hastext = false;
        if (!text) continue;
        text = text.toString();

        var transform = info['text-transform'];
        if (transform === 'uppercase') {
            text = text.toLocaleUpperCase();
        } else if (transform === 'lowercase') {
            text = text.toLocaleLowerCase();
        }

        for (var j = 0, jl = text.length; j < jl; j++) {
            if (text.charCodeAt(j) <= 65533) {
                codepoints.push(text.charCodeAt(j));
                hastext = true;
            }
        }
        // Track indexes of features with text.
        if (hastext) {
            textFeatures[i] = text;
        }
    }

    // get a list of unique codepoints we are missing
    codepoints = uniq(codepoints, glyphs);

    return {
        textFeatures: textFeatures,
        codepoints: codepoints
    };
}

function uniq(ids, alreadyHave) {
    var u = [];
    var last;
    ids.sort(sortNumbers);
    for (var i = 0; i < ids.length; i++) {
        if (ids[i] !== last) {
            last = ids[i];
            if (!alreadyHave[last]) u.push(ids[i]);
        }
    }
    return u;
}

function sortNumbers(a, b) {
    return a - b;
}


},{"../util/token.js":86}],65:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    Point = require('point-geometry');

module.exports = {
    rotationRange: rotationRange,
    mergeCollisions: mergeCollisions,

    rotatingFixedCollisions: rotatingFixedCollisions,
    rotatingRotatingCollisions: rotatingRotatingCollisions,

    cornerBoxCollisions: cornerBoxCollisions,
    circleEdgeCollisions: circleEdgeCollisions,

    getCorners: getCorners,
};

/*
 * Calculate the range a box conflicts with a second box
 */
function rotationRange(inserting, blocker, scale) {

    var collisions, box;

    var a = inserting;
    var b = blocker;

    // Instead of scaling the boxes, we move the anchors
    var relativeAnchor = new Point(
        (b.anchor.x - a.anchor.x) * scale,
        (b.anchor.y - a.anchor.y) * scale);

    // Generate a list of collision interval
    if (a.hBox && b.hBox) {
        collisions = rotatingRotatingCollisions(a.box, b.box, relativeAnchor);

    } else if (a.hBox) {
        box = {
            x1: b.box.x1 + relativeAnchor.x,
            y1: b.box.y1 + relativeAnchor.y,
            x2: b.box.x2 + relativeAnchor.x,
            y2: b.box.y2 + relativeAnchor.y
        };
        collisions = rotatingFixedCollisions(a.box, box);


    } else if (b.hBox) {
        box = {
            x1: a.box.x1 - relativeAnchor.x,
            y1: a.box.y1 - relativeAnchor.y,
            x2: a.box.x2 - relativeAnchor.x,
            y2: a.box.y2 - relativeAnchor.y
        };
        collisions = rotatingFixedCollisions(b.box, box);

    } else {
        collisions = [];
    }

    // Find and return the continous are around 0 where there are no collisions
    return mergeCollisions(collisions, blocker.placementRange);
}

/*
 * Combine an array of collision ranges to form a continuous
 * range that includes 0. Collisions within the ignoreRange are ignored
 */
function mergeCollisions(collisions, ignoreRange) {

    // find continuous interval including 0 that doesn't have any collisions
    var min = 2 * Math.PI;
    var max = 0;

    for (var i = 0; i < collisions.length; i++) {
        var collision = collisions[i];

        var entryOutside = ignoreRange[0] <= collision[0] && collision[0] <= ignoreRange[1];
        var exitOutside = ignoreRange[0] <= collision[1] && collision[1] <= ignoreRange[1];

        if (entryOutside && exitOutside) {
            // no collision, since blocker is out of range
        } else if (entryOutside) {
            min = Math.min(min, ignoreRange[1]);
            max = Math.max(max, collision[1]);
        } else if (exitOutside) {
            min = Math.min(min, collision[0]);
            max = Math.max(max, ignoreRange[0]);
        } else {
            min = Math.min(min, collision[0]);
            max = Math.max(max, collision[1]);
        }
    }

    return [min, max];
}

/*
 *  Calculate collision ranges for two rotating boxes.
 */

var horizontal = new Point(1, 0);

function rotatingRotatingCollisions(a, b, anchorToAnchor) {
    var d = anchorToAnchor.mag();

    var angleBetweenAnchors = anchorToAnchor.angleWith(horizontal);

    var c = [],
        collisions = [],
        k;

    // Calculate angles at which collisions may occur
    // top/bottom
    c[0] = Math.asin((a.y2 - b.y1) / d);
    c[1] = Math.asin((a.y2 - b.y1) / d) + Math.PI;
    c[2] = 2 * Math.PI - Math.asin((-a.y1 + b.y2) / d);
    c[3] = Math.PI - Math.asin((-a.y1 + b.y2) / d);

    // left/right
    c[4] = 2 * Math.PI - Math.acos((a.x2 - b.x1) / d);
    c[5] = Math.acos((a.x2 - b.x1) / d);
    c[6] = Math.PI - Math.acos((-a.x1 + b.x2) / d);
    c[7] = Math.PI + Math.acos((-a.x1 + b.x2) / d);

    var rl = a.x2 - b.x1;
    var lr = -a.x1 + b.x2;
    var tb = a.y2 - b.y1;
    var bt = -a.y1 + b.y2;

    // Calculate the distance squared of the diagonal which will be used
    // to check if the boxes are close enough for collisions to occur at each angle
    // todo, triple check these
    var e = [];
    // top/bottom
    e[0] = rl * rl + tb * tb;
    e[1] = lr * lr + tb * tb;
    e[2] = rl * rl + bt * bt;
    e[3] = lr * lr + bt * bt;
    // left/right
    e[4] = rl * rl + tb * tb;
    e[5] = rl * rl + bt * bt;
    e[6] = lr * lr + bt * bt;
    e[7] = lr * lr + tb * tb;


    c = c.filter(function(x, i) {
        // Check if they are close enough to collide
        return !isNaN(x) && d * d <= e[i];
    }).map(function(x) {
        // So far, angles have been calulated as relative to the vector between anchors.
        // Convert the angles to angles from north.
        return (x + angleBetweenAnchors + 2 * Math.PI) % (2 * Math.PI);
    });

    // Group the collision angles by two
    // each group represents a range where the two boxes collide
    c.sort();
    for (k = 0; k < c.length; k+=2) {
        collisions.push([c[k], c[k+1]]);
    }

    return collisions;

}

/*
 *  Calculate collision ranges for a rotating box and a fixed box;
 */
function rotatingFixedCollisions(rotating, fixed) {

    var cornersR = getCorners(rotating);
    var cornersF = getCorners(fixed);

    // A collision occurs when, and only at least one corner from one of the boxes
    // is within the other box. Calculate these ranges for each corner.

    var collisions = [];

    for (var i = 0; i < 4; i++ ) {
        cornerBoxCollisions(collisions, cornersR[i], cornersF);
        cornerBoxCollisions(collisions, cornersF[i], cornersR, true);
    }

    return collisions;
}


/*
 *  Calculate the ranges for which the corner,
 *  rotatated around the anchor, is within the box;
 */
function cornerBoxCollisions(collisions, corner, boxCorners, flip) {
    var radius = corner.mag(),
        angles = [];

    // Calculate the points at which the corners intersect with the edges
    for (var i = 0, j = 3; i < 4; j = i++) {
        circleEdgeCollisions(angles, corner, radius, boxCorners[j], boxCorners[i]);
    }

    if (angles.length % 2 !== 0) {
        // TODO fix
        // This could get hit when a point intersects very close to a corner
        // and floating point issues cause only one of the entry or exit to be counted
        throw('expecting an even number of intersections');
    }

    angles.sort();

    // Group by pairs, where each represents a range where a collision occurs
    for (var k = 0; k < angles.length; k+=2) {
        collisions[k/2] = flip ?
            [2 * Math.PI - angles[k+1], 2 * Math.PI - angles[k]] : // reflect an angle around 0 degrees
            [angles[k], angles[k+1]];
    }

    return collisions;
}

/*
 * Return the intersection points of a circle and a line segment;
 */
function circleEdgeCollisions(angles, corner, radius, p1, p2) {

    var edgeX = p2.x - p1.x;
    var edgeY = p2.y - p1.y;

    var a = edgeX * edgeX + edgeY * edgeY;
    var b = (edgeX * p1.x + edgeY * p1.y) * 2;
    var c = p1.x * p1.x + p1.y * p1.y - radius * radius;

    var discriminant = b*b - 4*a*c;

    // a collision exists only if line intersects circle at two points
    if (discriminant > 0) {
        var x1 = (-b - Math.sqrt(discriminant)) / (2 * a);
        var x2 = (-b + Math.sqrt(discriminant)) / (2 * a);

        // only add points if within line segment
        // hack to handle floating point representations of 0 and 1
        if (0 < x1 && x1 < 1) {
            angles.push(getAngle(p1, p2, x1, corner));
        }

        if (0 < x2 && x2 < 1) {
            angles.push(getAngle(p1, p2, x2, corner));
        }
    }

    return angles;
}

function getAngle(p1, p2, d, corner) {
    return (-corner.angleWithSep(
        util.interp(p1.x, p2.x, d),
        util.interp(p1.y, p2.y, d)) + 2 * Math.PI) % (2 * Math.PI);
}

function getCorners(a) {
    return [
        new Point(a.x1, a.y1),
        new Point(a.x1, a.y2),
        new Point(a.x2, a.y2),
        new Point(a.x2, a.y1)
    ];
}

},{"../util/util.js":87,"point-geometry":95}],66:[function(require,module,exports){
'use strict';

module.exports = {
    shape: shape
};

function shape(text, name, stacks, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {
    var glyphs = stacks[name].glyphs;
    var glyph;

    var shaping = [];

    var x = translate[0];
    var y = translate[1];
    var id;

    for (var i = 0; i < text.length; i++) {
        id = text.charCodeAt(i);
        glyph = glyphs[id];

        if (id === 0 || !glyph) continue;

        shaping.push({
            fontstack: name,
            glyph: id,
            x: x,
            y: y
        });

        x += glyph.advance + spacing;
    }

    if (!shaping.length) return false;

    shaping = linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify);

    return shaping;
}

var breakable = { 32: true }; // Currently only breaks at regular spaces

function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify) {
    var lastSafeBreak = null;

    var lengthBeforeCurrentLine = 0;
    var lineStartIndex = 0;
    var line = 0;

    var maxLineLength = 0;

    if (maxWidth) {
        for (var i = 0; i < shaping.length; i++) {
            var shape = shaping[i];

            shape.x -= lengthBeforeCurrentLine;
            shape.y += lineHeight * line;

            if (shape.x > maxWidth && lastSafeBreak !== null) {

                var lineLength = shaping[lastSafeBreak + 1].x;
                maxLineLength = Math.max(lineLength, maxLineLength);

                for (var k = lastSafeBreak + 1; k <= i; k++) {
                    shaping[k].y += lineHeight;
                    shaping[k].x -= lineLength;
                }

                if (justify) {
                    justifyLine(shaping, glyphs, lineStartIndex, lastSafeBreak - 1, justify);
                }

                lineStartIndex = lastSafeBreak + 1;
                lastSafeBreak = null;
                lengthBeforeCurrentLine += lineLength;
                line++;
            }

            if (breakable[shape.glyph]) {
                lastSafeBreak = i;
            }
        }
    }

    maxLineLength = maxLineLength || shaping[shaping.length - 1].x;

    justifyLine(shaping, glyphs, lineStartIndex, shaping.length - 1, justify);
    align(shaping, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line);
    return shaping;
}

function justifyLine(shaping, glyphs, start, end, justify) {
    var lastAdvance = glyphs[shaping[end].glyph].advance;
    var lineIndent = (shaping[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
        shaping[j].x -= lineIndent;
    }

}

function align(shaping, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line) {
    var shiftX = (justify - horizontalAlign) * maxLineLength;
    var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight;

    for (var j = 0; j < shaping.length; j++) {
        shaping[j].x += shiftX;
        shaping[j].y += shiftY;
    }
}

},{}],67:[function(require,module,exports){
'use strict';

var Control = require('./control.js'),
    DOM = require('../../util/dom.js'),
    util = require('../../util/util.js');

module.exports = Attribution;

function Attribution() {}

Attribution.prototype = util.inherit(Control, {
    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-attrib',
            container = this._container = DOM.create('div', className, map.container);

        this._update();
        map.on('source.add', this._update.bind(this));
        map.on('source.remove', this._update.bind(this));

        map.on('moveend', this._updateEditLink.bind(this));

        return container;
    },

    _update: function() {
        var attrObj = {};
        for (var id in this._map.sources) {
            var source = this._map.sources[id];
            if (source.attribution) {
                attrObj[source.attribution] = true;
            }
        }
        var attributions = [];
        for (var i in attrObj) {
            attributions.push(i);
        }
        this._container.innerHTML = attributions.join(' | ');
        this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
        this._updateEditLink();
    },

    _updateEditLink: function() {
        if (this._editLink) {
            var center = this._map.getCenter();
            this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
                    center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
        }
    }
});

},{"../../util/dom.js":81,"../../util/util.js":87,"./control.js":68}],68:[function(require,module,exports){
'use strict';

module.exports = Control;

function Control() {}

Control.prototype = {
	addTo: function(map) {
		this._map = map;
		this._container = this.onAdd(map);
		return this;
	},

	remove: function () {
		this._container.parentNode.removeChild(this._container);
		if (this.onRemove) this.onRemove(this._map);
		this._map = null;
		return this;
	}
};

},{}],69:[function(require,module,exports){
'use strict';

var Control = require('./control.js'),
    DOM = require('../../util/dom.js'),
    util = require('../../util/util.js');

module.exports = Navigation;

function Navigation() {}

Navigation.prototype = util.inherit(Control, {
    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-nav';

        var container = this._container = DOM.create('div', className, map.container);

        this._zoomInButton = this._createButton(className + '-zoom-in', map.zoomIn.bind(map));
        this._zoomOutButton = this._createButton(className + '-zoom-out', map.zoomOut.bind(map));
        this._compass = this._createButton(className + '-compass', map.resetNorth.bind(map));

        var compassCanvas = this._compassCanvas = DOM.create('canvas', className + '-compass-canvas', this._compass);
        compassCanvas.style.cssText = 'width:26px; height:26px;';
        compassCanvas.width = 26 * 2;
        compassCanvas.height = 26 * 2;

        this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
        this._onCompassMove = this._onCompassMove.bind(this);
        this._onCompassUp = this._onCompassUp.bind(this);

        this._compassCtx = compassCanvas.getContext('2d');

        map.on('rotate', this._drawNorth.bind(this));
        this._drawNorth();

        return container;
    },

    _onCompassDown: function(e) {
        DOM.disableDrag();

        document.addEventListener('mousemove', this._onCompassMove);
        document.addEventListener('mouseup', this._onCompassUp);
        this._prevX = e.screenX;

        e.stopPropagation();
    },

    _onCompassMove: function(e) {
        var x = e.screenX,
            d = x < 2 ? -5 : // left edge of the screen, continue rotating
                x > window.screen.width - 2 ? 5 : // right edge
                (x - this._prevX) / 4;

        this._map.setBearing(this._map.getBearing() - d);
        this._prevX = e.screenX;

        e.preventDefault();
    },

    _onCompassUp: function() {
        document.removeEventListener('mousemove', this._onCompassMove);
        document.removeEventListener('mouseup', this._onCompassUp);
        DOM.enableDrag();
    },

    _createButton: function(className, fn) {
        var a = DOM.create('a', className, this._container);
        a.href = '#';
        a.addEventListener('click', function(e) {
            fn();
            e.preventDefault();
            e.stopPropagation();
        });
        a.addEventListener('dblclick', function(e) {
            e.preventDefault();
            e.stopPropagation();
        });
        return a;
    },

    _drawNorth: function() {
        var rad = 20,
            width = 8,
            center = 26,
            angle = this._map.transform.angle + (Math.PI / 2),
            ctx = this._compassCtx;

        this._compassCanvas.width = this._compassCanvas.width;

        ctx.translate(center, center);
        ctx.rotate(angle);

        ctx.beginPath();
        ctx.fillStyle = '#000';
        ctx.lineTo(0, -width);
        ctx.lineTo(-rad, 0);
        ctx.lineTo(0, width);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = '#bbb';
        ctx.moveTo(0, 0);
        ctx.lineTo(0, width);
        ctx.lineTo(rad, 0);
        ctx.lineTo(0, -width);
        ctx.fill();

        ctx.beginPath();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.moveTo(0, -width);
        ctx.lineTo(0, width);
        ctx.stroke();
    }
});

},{"../../util/dom.js":81,"../../util/util.js":87,"./control.js":68}],70:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    browser = require('../util/browser.js'),
    LatLng = require('../geo/latlng.js'),
    LatLngBounds = require('../geo/latlngbounds.js'),
    Point = require('point-geometry');

util.extend(exports, {
    isEasing: function () {
        return !!this._abortFn;
    },

    stop: function () {
        if (this._abortFn) {
            this._abortFn.call(this);
            delete this._abortFn;

            this._finishFn.call(this);
            delete this._finishFn;
        }
        return this;
    },

    _ease: function(frame, finish, options) {
        this._finishFn = finish;
        this._abortFn = browser.timed(function (t) {
            frame.call(this, options.easing(t));
            if (t === 1) {
                delete this._abortFn;
                this._finishFn.call(this);
                delete this._finishFn;
            }
        }, options.animate === false ? 0 : options.duration, this);
    },

    panBy: function(offset, options) {
        this.panTo(this.transform.center, util.extend({offset: Point.convert(offset).mult(-1)}, options));
        return this;
    },

    panTo: function(latlng, options) {
        this.stop();

        latlng = LatLng.convert(latlng);

        options = util.extend({
            duration: 500,
            easing: util.ease,
            offset: [0, 0]
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset).rotate(-tr.angle),
            from = tr.point,
            to = tr.project(latlng).sub(offset);

        if (!options.noMoveStart) {
            this.fire('movestart');
        }

        this._ease(function(k) {
            tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
            this._move();
        }, function() {
            this.fire('moveend');
        }, options);

        return this;
    },

    // Zooms to a certain zoom level with easing.
    zoomTo: function(zoom, options) {
        this.stop();

        options = util.extend({
            duration: 500
        }, options);

        options.easing = this._updateEasing(options.duration, zoom, options.easing);

        var tr = this.transform,
            around = tr.center,
            startZoom = tr.zoom;

        if (options.around) {
            around = LatLng.convert(options.around);
        } else if (options.offset) {
            around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
        }

        if (options.animate === false) options.duration = 0;

        if (!this.zooming) {
            this.zooming = true;
            this.fire('movestart');
        }

        this._ease(function(k) {
            tr.setZoomAround(util.interp(startZoom, zoom, k), around);
            this.style.animationLoop.set(300); // text fading
            this._move(true);
        }, function() {
            this.ease = null;
            if (options.duration >= 200) {
                this.zooming = false;
                this.fire('moveend');
            }
        }, options);

        if (options.duration < 200) {
            clearTimeout(this._onZoomEnd);
            this._onZoomEnd = setTimeout(function() {
                this.zooming = false;
                this._rerender();
                this.fire('moveend');
            }.bind(this), 200);
        }

        return this;
    },

    zoomIn: function(options) {
        this.zoomTo(this.getZoom() + 1, options);
    },

    zoomOut: function(options) {
        this.zoomTo(this.getZoom() - 1, options);
    },

    rotateTo: function(bearing, options) {
        this.stop();

        options = util.extend({
            duration: 500,
            easing: util.ease
        }, options);

        var tr = this.transform,
            start = this.getBearing(),
            around = tr.center;

        if (options.around) {
            around = LatLng.convert(options.around);
        } else if (options.offset) {
            around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
        }

        this.rotating = true;
        this.fire('movestart');

        this._ease(function(k) {
            tr.setBearingAround(util.interp(start, bearing, k), around);
            this._move(false, true);
        }, function() {
            this.rotating = false;
            this.fire('moveend');
        }, options);

        return this;
    },

    resetNorth: function(options) {
        return this.rotateTo(0, util.extend({duration: 1000}, options));
    },

    fitBounds: function(bounds, options) {

        options = util.extend({
            padding: 0,
            offset: [0, 0],
            maxZoom: Infinity
        }, options);

        bounds = LatLngBounds.convert(bounds);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            nw = tr.project(bounds.getNorthWest()),
            se = tr.project(bounds.getSouthEast()),
            size = se.sub(nw),
            center = tr.unproject(nw.add(se).div(2)),

            scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
            scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y,

            zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);

        return options.linear ?
            this.easeTo(center, zoom, 0, options) :
            this.flyTo(center, zoom, 0, options);
    },

    easeTo: function(latlng, zoom, bearing, options) {

        options = util.extend({
            offset: [0, 0],
            duration: 500,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset).rotate(-tr.angle),
            startZoom = this.getZoom(),
            startBearing = this.getBearing();

        latlng = LatLng.convert(latlng);
        zoom = zoom === undefined ? startZoom : zoom;
        bearing = bearing === undefined ? startBearing : bearing;

        var scale = tr.zoomScale(zoom - startZoom),
            from = tr.point,
            to = latlng ? tr.project(latlng).sub(offset.div(scale)) : tr.point,
            around;

        if (zoom !== startZoom) {
            around = tr.pointLocation(tr.centerPoint.add(to.sub(from).div(1 - 1 / scale)));
            this.zooming = true;
        }
        if (startBearing !== bearing) this.rotating = true;

        this.fire('movestart');

        this._ease(function (k) {
            if (zoom !== startZoom) {
                tr.setZoomAround(util.interp(startZoom, zoom, k), around);
            } else {
                tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
            }

            if (bearing !== startBearing) {
                tr.bearing = util.interp(startBearing, bearing, k);
            }

            this.style.animationLoop.set(300); // text fading
            this._move(zoom !== startZoom, bearing !== startBearing);
        }, function() {
            this.zooming = false;
            this.rotating = false;
            this.fire('moveend');
        }, options);

        return this;
    },

    flyTo: function(latlng, zoom, bearing, options) {

        options = util.extend({
            offset: [0, 0],
            speed: 1.2,
            curve: 1.42,
            easing: util.ease
        }, options);

        latlng = LatLng.convert(latlng);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            startZoom = this.getZoom(),
            startBearing = this.getBearing();

        zoom = zoom === undefined ? startZoom : zoom;
        bearing = bearing === undefined ? startBearing : bearing;

        var scale = tr.zoomScale(zoom - startZoom),
            from = tr.point,
            to = tr.project(latlng).sub(offset.div(scale));

        if (options.animate === false) {
            return this.setView(latlng, zoom, bearing);
        }

        var startWorldSize = tr.worldSize,
            rho = options.curve,
            V = options.speed,

            w0 = Math.max(tr.width, tr.height),
            w1 = w0 / scale,
            u1 = to.sub(from).mag(),
            rho2 = rho * rho;

        function r(i) {
            var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
            return Math.log(Math.sqrt(b * b + 1) - b);
        }

        function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
        function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
        function tanh(n) { return sinh(n) / cosh(n); }

        var r0 = r(0),
            w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
            u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
            S = (r(1) - r0) / rho;

        if (Math.abs(u1) < 0.000001) {
            if (Math.abs(w0 - w1) < 0.000001) return this;

            var k = w1 < w0 ? -1 : 1;
            S = Math.abs(Math.log(w1 / w0)) / rho;

            u = function() { return 0; };
            w = function(s) { return Math.exp(k * rho * s); };
        }

        options.duration = 1000 * S / V;

        this.zooming = true;
        if (startBearing != bearing) this.rotating = true;

        this.fire('movestart');

        this._ease(function (k) {
            var s = k * S,
                us = u(s);

            tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
            tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);

            if (bearing !== startBearing) {
                tr.bearing = util.interp(startBearing, bearing, k);
            }

            this.style.animationLoop.set(300); // text fading

            this._move(true, bearing !== startBearing);
        }, function() {
            this.zooming = false;
            this.rotating = false;
            this.fire('moveend');
        }, options);

        return this;
    },

    _updateEasing: function(duration, zoom, bezier) {
        var easing;

        if (this.ease) {
            var ease = this.ease,
                t = (Date.now() - ease.start) / ease.duration,
                speed = ease.easing(t + 0.01) - ease.easing(t),

                // Quick hack to make new bezier that is continuous with last
                x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                y = Math.sqrt(0.27 * 0.27 - x * x);

            easing = util.bezier(x, y, 0.25, 1);
        } else {
            easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
        }

        // store information on current easing
        this.ease = {
            start: (new Date()).getTime(),
            to: Math.pow(2, zoom),
            duration: duration,
            easing: easing
        };

        return easing;
    }
});

},{"../geo/latlng.js":17,"../geo/latlngbounds.js":18,"../util/browser.js":77,"../util/util.js":87,"point-geometry":95}],71:[function(require,module,exports){
'use strict';

var Interaction = require('./interaction.js');
var Point = require('point-geometry');
var util = require('../util/util.js');

module.exports = Handlers;

function Handlers(map) {

    var rotateEnd;

    var inertiaLinearity = 0.2,
        inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1);

    this.interaction = new Interaction(map.container)
        .on('click', function(e) {
            map.fire('click', e);
        })
        .on('hover', function(e) {
            map.fire('hover', e);
        })
        .on('down', function () {
            map.fire('movestart');
        })
        .on('resize', function() {
            map.stop();
            map.resize();
            map.update();
        })
        .on('pan', function(e) {
            map.stop();
            map.transform.panBy(e.offset);
            map._move();
        })
        .on('panend', function(e) {
            if (!e.inertia) map.fire('moveend');
            else {
                // convert velocity to px/s & adjust for increased initial animation speed when easing out
                var velocity = e.inertia.mult(1000 * inertiaLinearity),
                    speed = velocity.mag();

                var maxSpeed = 4000; // px/s

                if (speed >= maxSpeed) {
                    speed = maxSpeed;
                    velocity._unit()._mult(maxSpeed);
                }

                var deceleration = 8000, // px/s^2
                    duration = speed / (deceleration * inertiaLinearity),
                    offset = velocity.mult(-duration / 2).round();

                map.panBy(offset, {
                    duration: duration * 1000,
                    easing: inertiaEasing,
                    noMoveStart: true
                });
            }
        })
        .on('zoom', function(e) {
            // Scale by sigmoid of scroll wheel delta.
            var scale = 2 / (1 + Math.exp(-Math.abs(e.delta / 100)));
            if (e.delta < 0 && scale !== 0) scale = 1 / scale;

            var fromScale = map.ease && isFinite(e.delta) ? map.ease.to : map.transform.scale,
                duration = !isFinite(e.delta) ? 800 : e.source == 'trackpad' ? 0 : 300;

            map.zoomTo(map.transform.scaleZoom(fromScale * scale), {
                duration: duration,
                around: map.unproject(e.point)
            });
        })
        .on('rotate', function(e) {
            var center = map.transform.centerPoint, // Center of rotation
                startToCenter = e.start.sub(center),
                startToCenterDist = startToCenter.mag();

            // If the first click was too close to the center, move the center of rotation by 200 pixels
            // in the direction of the click.
            if (startToCenterDist < 200) {
                center = e.start.add(new Point(-200, 0)._rotate(startToCenter.angle()));
            }

            var bearingDiff = e.prev.sub(center).angleWith(e.current.sub(center)) / Math.PI * 180;
            map.transform.bearing = map.getBearing() - bearingDiff;

            map._move(false, true);

            window.clearTimeout(rotateEnd);
            rotateEnd = window.setTimeout(function() {
                map.rotating = false;
                map._rerender();
            }, 200);
        });
}

},{"../util/util.js":87,"./interaction.js":73,"point-geometry":95}],72:[function(require,module,exports){
'use strict';

module.exports = Hash;

var util = require('../util/util.js');

function Hash(map) {
    this.map = map;
    window.addEventListener('hashchange', this.onhash.bind(this), false);
    map.on('move', util.debounce(this.updateHash.bind(this), 100));
}

Hash.prototype = {
    onhash: function() {
        var loc = location.hash.replace('#', '').split('/');
        if (loc.length >= 3) {
            this.map.setView([+loc[1], +loc[2]], +loc[0], +(loc[3] || 0));
            return true;
        }
        return false;
    },

    updateHash: function() {
        var center = this.map.getCenter(),
            zoom = this.map.getZoom(),
            bearing = this.map.getBearing(),
            precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),

            hash = '#' + (Math.round(zoom * 100) / 100) +
                '/' + center.lat.toFixed(precision) +
                '/' + center.lng.toFixed(precision) +
                (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');

        window.history.replaceState('', '', hash);
    }
};

},{"../util/util.js":87}],73:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented.js'),
    browser = require('../util/browser.js'),
    Point = require('point-geometry');

module.exports = Interaction;

function Interaction(el) {
    var interaction = this;
    if (!el) return;

    var rotating = false,
        panned = false,
        firstPos = null,
        pos = null,
        inertia = null,
        now;

    function mousePos(e) {
        var rect = el.getBoundingClientRect();
        return new Point(
            e.clientX - rect.left - el.clientLeft,
            e.clientY - rect.top - el.clientTop);
    }

    el.addEventListener('contextmenu', function(ev) {
        rotating = true;
        firstPos = pos = mousePos(ev);
        ev.preventDefault();
    }, false);
    el.addEventListener('mousedown', onmousedown, false);
    document.addEventListener('mouseup', onmouseup, false);
    document.addEventListener('mousemove', onmousemove, false);
    el.addEventListener('click', onclick, false);
    scrollwheel(zoom);
    el.addEventListener('dblclick', ondoubleclick, false);
    window.addEventListener('resize', resize, false);

    function zoom(type, delta, point) {
        interaction.fire('zoom', {
            source: type,
            delta: delta,
            point: point
        });
        inertia = null;
        now = null;
    }

    function click(point) {
        interaction.fire('click', {point: point});
    }

    function hover(point) {
        interaction.fire('hover', {point: point});
    }

    function pan(point) {
        if (pos) {
            var offset = pos.sub(point);
            interaction.fire('pan', {offset: offset});

            // add an averaged version of this movement to the inertia vector
            if (inertia) {
                var duration = Date.now() - now;
                // sometimes it's 0 after some erratic paning
                if (duration) {
                    var time = duration + now;
                    inertia.push([time, point]);
                    while (inertia.length > 2 && time - inertia[0][0] > 100) inertia.shift();
                }

            } else {
                inertia = [];
            }
            now = Date.now();
            pos = point;
        }
    }

    function resize() {
        interaction.fire('resize');
    }

    function rotate(point) {
        if (pos) {
            interaction.fire('rotate', {
                start: firstPos,
                prev: pos,
                current: point
            });
            pos = point;
        }
    }

    function onmousedown(ev) {
        firstPos = pos = mousePos(ev);
        interaction.fire('down');
    }

    function onmouseup() {
        panned = pos && firstPos && (pos.x != firstPos.x || pos.y != firstPos.y);

        rotating = false;
        pos = null;

        if (inertia && inertia.length >= 2 && now > Date.now() - 100) {
            var last = inertia[inertia.length - 1],
                first = inertia[0],
                velocity = last[1].sub(first[1]).div(last[0] - first[0]);
            interaction.fire('panend',  {inertia: velocity});

        } else interaction.fire('panend');

        inertia = null;
        now = null;
    }

    function onmousemove(ev) {
        var point = mousePos(ev);

        if (rotating) { rotate(point); }
        else if (pos) pan(point);
        else {
            var target = ev.toElement;
            while (target && target != el && target.parentNode) target = target.parentNode;
            if (target == el) {
                hover(point);
            }
        }
    }

    function onclick(ev) {
        if (!panned) click(mousePos(ev));
    }

    function ondoubleclick(ev) {
        zoom('wheel', Infinity * (ev.shiftKey ? -1 : 1), mousePos(ev));
        ev.preventDefault();
    }

    function scrollwheel(callback) {
        var firefox = /Firefox/i.test(navigator.userAgent);
        var safari = /Safari/i.test(navigator.userAgent) && !/Chrom(ium|e)/i.test(navigator.userAgent);
        var time = window.performance || Date;

        el.addEventListener('wheel', wheel, false);
        el.addEventListener('mousewheel', mousewheel, false);

        var lastEvent = 0;

        var type = null;
        var typeTimeout = null;
        var initialValue = null;

        function scroll(value, ev) {
            var stamp = time.now();
            var timeDelta = stamp - lastEvent;
            lastEvent = stamp;

            var point = mousePos(ev);

            if (value !== 0 && (value % 4.000244140625) === 0) {
                // This one is definitely a mouse wheel event.
                type = 'wheel';
            } else if (value !== 0 && Math.abs(value) < 4) {
                // This one is definitely a trackpad event because it is so small.
                type = 'trackpad';
            } else if (timeDelta > 400) {
                // This is likely a new scroll action.
                type = null;
                initialValue = value;
                // Start a timeout in case this was a singular event, and dely it
                // by up to 40ms.
                typeTimeout = setTimeout(function() {
                    type = 'wheel';
                    callback(type, -initialValue, point);
                }, 40);
            } else if (type === null) {
                // This is a repeating event, but we don't know the type of event
                // just yet. If the delta per time is small, we assume it's a
                // fast trackpad; otherwise we switch into wheel mode.
                type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';

                // Make sure our delayed event isn't fired again, because we
                // accumulate the previous event (which was less than 40ms ago) into
                // this event.
                if (typeTimeout) {
                    clearTimeout(typeTimeout);
                    typeTimeout = null;
                    value += initialValue;
                }
            }

            // Only fire the callback if we actually know what type of scrolling
            // device the user uses.
            if (type !== null) {
                callback(type, -value, point);
            }
        }

        function wheel(e) {
            var deltaY = e.deltaY;
            // Firefox doubles the values on retina screens...
            if (firefox && e.deltaMode == window.WheelEvent.DOM_DELTA_PIXEL) deltaY /= browser.devicePixelRatio;
            if (e.deltaMode == window.WheelEvent.DOM_DELTA_LINE) deltaY *= 40;
            scroll(deltaY, e);
            e.preventDefault();
        }

        function mousewheel(e) {
            var deltaY = -e.wheelDeltaY;
            if (safari) deltaY = deltaY / 3;
            scroll(deltaY, e);
            e.preventDefault();
        }
    }
}

Interaction.prototype = Object.create(Evented);

},{"../util/browser.js":77,"../util/evented.js":82,"point-geometry":95}],74:[function(require,module,exports){
'use strict';

var Dispatcher = require('../util/dispatcher.js'),
    Canvas = require('../util/canvas.js'),
    util = require('../util/util.js'),
    browser = require('../util/browser.js'),
    ajax = require('../util/ajax.js'),
    Evented = require('../util/evented.js'),

    Style = require('../style/style.js'),
    AnimationLoop = require('../style/animationloop.js'),
    GLPainter = require('../render/painter.js'),

    Transform = require('../geo/transform.js'),
    Hash = require('./hash.js'),
    Handlers = require('./handlers.js'),
    Source = require('../source/source.js'),
    Easings = require('./easings.js'),
    LatLng = require('../geo/latlng.js'),
    LatLngBounds = require('../geo/latlngbounds.js'),
    Point = require('point-geometry'),
    GlyphSource = require('../symbol/glyphsource.js'),
    Attribution = require('./control/attribution.js');

// allow redefining Map here (jshint thinks it's global)
// jshint -W079

var Map = module.exports = function(options) {

    options = this.options = util.inherit(this.options, options);

    this.animationLoop = new AnimationLoop();
    this.transform = new Transform(options.minZoom, options.maxZoom);
    this.hash = options.hash && new Hash(this);

    if (options.maxBounds) {
        var b = LatLngBounds.convert(options.maxBounds);
        this.transform.latRange = [b.getSouth(), b.getNorth()];
        this.transform.lngRange = [b.getWest(), b.getEast()];
    }

    this._onStyleChange = this._onStyleChange.bind(this);
    this._updateBuckets = this._updateBuckets.bind(this);
    this.render = this.render.bind(this);

    this._setupContainer();
    this._setupPainter();

    this.handlers = options.interactive && new Handlers(this);
    this.dispatcher = new Dispatcher(Math.max(options.numWorkers, 1), this);

     // don't set position from options if set through hash
    if (!this.hash || !this.hash.onhash()) {
        this.setView(options.center, options.zoom, options.bearing);
    }

    this.sources = {};
    this.stacks = {};

    this.resize();

    if (typeof options.style === 'object') {
        this.setStyle(options.style);

    } else if (typeof options.style === 'string') {
        ajax.getJSON(options.style, function (err, data) {
            if (err) throw err;
            this.setStyle(data);
        }.bind(this));
    }

    if (options.attributionControl) this.addControl(new Attribution());
};

util.extend(Map.prototype, Evented);
util.extend(Map.prototype, Easings);
util.extend(Map.prototype, {

    options: {
        center: [0, 0],
        zoom: 0,
        bearing: 0,

        minZoom: 0,
        maxZoom: 20,
        numWorkers: browser.hardwareConcurrency - 1,

        interactive: true,
        hash: false,

        attributionControl: true
    },

    addSource: function(id, source) {
        this.sources[id] = source;
        source.id = id;
        if (source.onAdd) {
            source.onAdd(this);
        }
        if (source.enabled) source.fire('source.add', {source: source});
        return this;
    },

    removeSource: function(id) {
        var source = this.sources[id];
        if (source.onRemove) {
            source.onRemove(this);
        }
        delete this.sources[id];
        return this.fire('source.remove', {source: source});
    },

    addControl: function(control) {
        control.addTo(this);
        return this;
    },

    // Set the map's center, zoom, and bearing
    setView: function(center, zoom, bearing) {
        this.stop();

        var tr = this.transform,
            zoomChanged = tr.zoom !== +zoom,
            bearingChanged = tr.bearing !== +bearing;

        tr.center = LatLng.convert(center);
        tr.zoom = +zoom;
        tr.bearing = +bearing;

        return this
            .fire('movestart')
            ._move(zoomChanged, bearingChanged)
            .fire('moveend');
    },

    setCenter: function(center) {
        this.setView(center, this.getZoom(), this.getBearing());
    },

    setZoom: function(zoom) {
        this.setView(this.getCenter(), zoom, this.getBearing());
    },

    setBearing: function(bearing) {
        this.setView(this.getCenter(), this.getZoom(), bearing);
    },

    getCenter: function() { return this.transform.center; },
    getZoom: function() { return this.transform.zoom; },
    getBearing: function() { return this.transform.bearing; },

    // Detect the map's new width and height and resize it.
    resize: function() {
        var width = 0, height = 0;

        if (this.container) {
            width = this.container.offsetWidth || 400;
            height = this.container.offsetHeight || 300;
        }

        this.canvas.resize(width, height);

        this.transform.width = width;
        this.transform.height = height;
        this.transform._constrain();

        if (this.style && this.style.sprite) {
            this.style.sprite.resize(this.painter.gl);
        }

        this.painter.resize(width, height);

        return this
            .fire('movestart')
            ._move()
            .fire('resize')
            .fire('moveend');
    },

    getBounds: function() {
        return new LatLngBounds(
            this.transform.pointLocation(new Point(0, 0)),
            this.transform.pointLocation(this.transform.size));
    },

    project: function(latlng) {
        return this.transform.locationPoint(LatLng.convert(latlng));
    },
    unproject: function(point) {
        return this.transform.pointLocation(Point.convert(point));
    },

    featuresAt: function(point, params, callback) {
        var features = [];
        var error = null;
        var map = this;

        point = Point.convert(point);

        util.asyncEach(Object.keys(this.sources), function(id, callback) {
            var source = map.sources[id];
            source.featuresAt(point, params, function(err, result) {
                if (result) features = features.concat(result);
                if (err) error = err;
                callback();
            });
        }, function() {
            callback(error, features);
        });
        return this;
    },

    setStyle: function(style) {
        if (this.style) {
            this.style.off('change', this._onStyleChange);
        }

        if (style instanceof Style) {
            this.style = style;
        } else {
            this.style = new Style(style, this.animationLoop);
        }

        var sources = this.style.stylesheet.sources;
        for (var id in sources) {
            this.addSource(id, Source.create(sources[id]));
        }

        this.glyphSource = new GlyphSource(this.style.stylesheet.glyphs, this.painter.glyphAtlas);

        this.style.on('change', this._onStyleChange);

        this._styleDirty = true;
        this._tilesDirty = true;

        this._updateBuckets();
        this._updateGlyphs();

        this.fire('style.change');

        return this;
    },

    _move: function (zoom, rotate) {

        this.update(zoom).fire('move');

        if (zoom) this.fire('zoom');
        if (rotate) this.fire('rotate');

        return this;
    },

    // map setup code

    _setupContainer: function() {
        var id = this.options.container;
        var container = this.container = typeof id === 'string' ? document.getElementById(id) : id;
        if (container) container.classList.add('mapboxgl-map');
        this.canvas = new Canvas(this, container);
    },

    _setupPainter: function() {
        var gl = this.canvas.getWebGLContext();

        if (!gl) {
            alert('Failed to initialize WebGL');
            return;
        }

        this.painter = new GLPainter(gl, this.transform);
    },

    _contextLost: function(event) {
        event.preventDefault();
        if (this._frameId) {
            browser.cancelFrame(this._frameId);
        }
    },

    _contextRestored: function() {
        this._setupPainter();
        this.resize();
        this.update();
    },

    // Callbacks from web workers

    'debug message': function(data) {
        console.log.apply(console, data);
    },

    'alert message': function(data) {
        alert.apply(window, data);
    },

    'get sprite json': function(params, callback) {
        var sprite = this.style.sprite;
        if (sprite.loaded()) {
            callback(null, { sprite: sprite.data, retina: sprite.retina });
        } else {
            sprite.on('loaded', function() {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
            });
        }
    },

    'get glyphs': function(params, callback) {
        this.glyphSource.getRects(params.fontstack, params.codepoints, params.id, callback);
    },

    // Rendering

    update: function(updateStyle) {

        if (!this.style) return this;

        this._styleDirty = this._styleDirty || updateStyle;
        this._tilesDirty = true;

        this._rerender();

        return this;
    },

    // Call when a (re-)render of the map is required, e.g. when the user panned or zoomed,f or new data is available.
    render: function() {
        if (this._styleDirty) {
            this._styleDirty = false;
            this._updateStyle();
        }

        if (this._tilesDirty) {
            for (var id in this.sources) {
                this.sources[id].update();
            }
            this._tilesDirty = false;
        }

        this._renderGroups(this.style.layerGroups);
        this.fire('render');

        this._frameId = null;

        if (!this.animationLoop.stopped()) {
            this._styleDirty = true;
        }

        if (this._repaint || !this.animationLoop.stopped()) {
            this._rerender();
        }

        return this;
    },

    _renderGroups: function(groups) {
        this.painter.prepareBuffers();

        var i, len, group, source;

        // Render the groups
        for (i = 0, len = groups.length; i < len; i++) {
            group = groups[i];
            source = this.sources[group.source];

            if (source) {
                this.painter.clearStencil();
                source.render(group);

            } else if (group.source === undefined) {
                this.painter.draw(undefined, this.style, group, { background: true });
            }
        }
    },

    _rerender: function() {
        if (!this._frameId) {
            this._frameId = browser.frame(this.render);
        }
    },

    _onStyleChange: function () {
        this.update(true);
    },

    _updateStyle: function() {
        if (!this.style) return;
        this.style.recalculate(this.transform.zoom);
    },

    _updateGlyphs: function() {
        this.dispatcher.broadcast('set glyphs', this.style.stylesheet.glyphs);
    },

    _updateBuckets: function() {
        // Transfer a stripped down version of the style to the workers. They only
        // need the bucket information to know what features to extract from the tile.
        this.dispatcher.broadcast('set buckets', this.style.orderedBuckets);

        // clears all tiles to recalculate geometries (for changes to linecaps, linejoins, ...)
        for (var s in this.sources) {
            this.sources[s].load();
        }

        this.update();
    }
});

util.extendAll(Map.prototype, {

    // debug code
    _debug: false,
    get debug() { return this._debug; },
    set debug(value) { this._debug = value; this._rerender(); },

    // continuous repaint
    _repaint: false,
    get repaint() { return this._repaint; },
    set repaint(value) { this._repaint = value; this._rerender(); },

    // polygon antialiasing
    _antialiasing: true,
    get antialiasing() { return this._antialiasing; },
    set antialiasing(value) { this._antialiasing = value; this._rerender(); },

    // show vertices
    _vertices: false,
    get vertices() { return this._vertices; },
    set vertices(value) { this._vertices = value; this._rerender(); },

    // show vertices
    _loadNewTiles: true,
    get loadNewTiles() { return this._loadNewTiles; },
    set loadNewTiles(value) { this._loadNewTiles = value; this.update(); }
});

},{"../geo/latlng.js":17,"../geo/latlngbounds.js":18,"../geo/transform.js":19,"../render/painter.js":32,"../source/source.js":39,"../style/animationloop.js":47,"../style/style.js":53,"../symbol/glyphsource.js":61,"../util/ajax.js":76,"../util/browser.js":77,"../util/canvas.js":78,"../util/dispatcher.js":79,"../util/evented.js":82,"../util/util.js":87,"./control/attribution.js":67,"./easings.js":70,"./handlers.js":71,"./hash.js":72,"point-geometry":95}],75:[function(require,module,exports){
'use strict';

module.exports = Actor;

function Actor(target, parent) {
    this.target = target;
    this.parent = parent;
    this.callbacks = {};
    this.callbackID = 0;
    this.receive = this.receive.bind(this);
    this.target.addEventListener('message', this.receive, false);
}

Actor.prototype.receive = function(message) {
    var data = message.data,
        callback;

    if (data.type == '<response>') {
        callback = this.callbacks[data.id];
        delete this.callbacks[data.id];
        callback(data.error || null, data.data);
    } else if (typeof data.id !== 'undefined') {
        var id = data.id;
        this.parent[data.type](data.data, function response(err, data, buffers) {
            // console.warn('trying to clone', data, buffers, message.target);
            message.target.postMessage({
                type: '<response>',
                id: String(id),
                error: err ? String(err) : null,
                data: data
            }, buffers);
        });
    } else {
        this.parent[data.type](data.data);
    }
};

Actor.prototype.send = function(type, data, callback, buffers) {
    var id = null;
    if (callback) this.callbacks[id = this.callbackID++] = callback;
    this.target.postMessage({ type: type, id: String(id), data: data }, buffers);
};

},{}],76:[function(require,module,exports){
'use strict';

exports.getJSON = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            var data;
//            console.log(xhr.response);
            try { data = JSON.parse(xhr.response); }
            catch (err) { return callback(err); }
            callback(null, data);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

exports.getArrayBuffer = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            callback(null, xhr.response);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

exports.getImage = function(url, callback) {
    var img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = function() {
        callback(null, img);
    };
    img.src = url;
    img.getData = function() { return getImageData(this); };
    return img;
};

function getImageData(img) {
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    context.drawImage(img, 0, 0);
    return context.getImageData(0, 0, img.width, img.height).data;
}

},{}],77:[function(require,module,exports){
'use strict';

var frameName = (function() {
    if (window.requestAnimationFrame) return 'requestAnimationFrame';
    if (window.mozRequestAnimationFrame) return 'mozRequestAnimationFrame';
    if (window.webkitRequestAnimationFrame) return 'webkitRequestAnimationFrame';
    if (window.msRequestAnimationFrame) return 'msRequestAnimationFrame';
})();

exports.frame = function(fn) {
    return window[frameName](fn);
};

exports.cancelFrame = function(id) {
    (window.cancelRequestAnimationFrame ||
        window.mozCancelRequestAnimationFrame ||
        window.webkitCancelRequestAnimationFrame ||
        window.msCancelRequestAnimationFrame)(id);
};

exports.timed = function (fn, dur, ctx) {
    if (!dur) {
        fn.call(ctx, 1);
        return;
    }

    var abort = false,
        start = window.performance ? window.performance.now() : Date.now();

    function tick(now) {
        if (abort) return;
        if (!window.performance) now = Date.now();

        if (now >= start + dur) {
            fn.call(ctx, 1);
        } else {
            fn.call(ctx, (now - start) / dur);
            exports.frame(tick);
        }
    }

    exports.frame(tick);

    return function() { abort = true; };
};

exports.supported = function() {
    var supports = [

        function() { return typeof window !== 'undefined'; },

        function() { return typeof document !== 'undefined'; },

        function () {
            return !!(Array.prototype &&
                Array.prototype.every &&
                Array.prototype.filter &&
                Array.prototype.forEach &&
                Array.prototype.indexOf &&
                Array.prototype.lastIndexOf &&
                Array.prototype.map &&
                Array.prototype.some &&
                Array.prototype.reduce &&
                Array.prototype.reduceRight &&
                Array.isArray);
        },

        function() {
            return !!(Function.prototype && Function.prototype.bind),
                !!(Object.keys &&
                    Object.create &&
                    Object.getPrototypeOf &&
                    Object.getOwnPropertyNames &&
                    Object.isSealed &&
                    Object.isFrozen &&
                    Object.isExtensible &&
                    Object.getOwnPropertyDescriptor &&
                    Object.defineProperty &&
                    Object.defineProperties &&
                    Object.seal &&
                    Object.freeze &&
                    Object.preventExtensions);
        },

        function() {
            return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
        },

        function() {
            var canvas = document.createElement('canvas');
            if ('supportsContext' in canvas) {
                return canvas.supportsContext('webgl') || canvas.supportsContext('experimental-webgl');
            }
            return !!window.WebGLRenderingContext &&
                (!!canvas.getContext('webgl') || !!canvas.getContext('experimental-webgl'));
        },

        function() { return 'Worker' in window; }
    ];

    for (var i = 0; i < supports.length; i++) {
        if (!supports[i]()) return false;
    }
    return true;
};

exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;

Object.defineProperty(exports, 'devicePixelRatio', {
    get: function() { return window.devicePixelRatio; }
});

},{}],78:[function(require,module,exports){
'use strict';

module.exports = Canvas;

function Canvas(parent, container) {
    this.canvas = document.createElement('canvas');
    this.canvas.style.position = 'absolute';
    this.canvas.classList.add('mapboxgl-canvas');
    this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
    this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
    container.appendChild(this.canvas);
}

Canvas.prototype.resize = function(width, height) {
    var pixelRatio = window.devicePixelRatio || 1;

    // Request the required canvas size taking the pixelratio into account.
    this.canvas.width = pixelRatio * width;
    this.canvas.height = pixelRatio * height;

    // Maintain the same canvas size, potentially downscaling it for HiDPI displays
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
};

Canvas.prototype.getWebGLContext = function() {
    return this.canvas.getContext("experimental-webgl", {
        antialias: false,
        alpha: true,
        stencil: true,
        depth: false
    });
};

},{}],79:[function(require,module,exports){
'use strict';

var Actor = require('../actor.js');

var scripts = document.getElementsByTagName("script");
var workerFile = scripts[scripts.length - 1].getAttribute('src');
var absolute = workerFile.indexOf('http') !== -1;


// Manages the WebWorkers
module.exports = Dispatcher;
function Dispatcher(length, parent) {
    this.actors = [];
    this.currentActor = 0;

    var url, blob, i;

    for (i = 0; i < length; i++) {
        // due to cross domain issues we can't load it directly with the url,
        // so create a blob and object url and load that
        if (absolute) {
            blob = new Blob(['importScripts("' + workerFile + '");'], {type : 'application/javascript'});
            url = window.URL.createObjectURL(blob);
        } else {
            url = workerFile;
        }

        var worker = new Worker(url);
        var actor = new Actor(worker, parent);
        actor.name = "Worker " + i;
        this.actors.push(actor);
    }
}

Dispatcher.prototype.broadcast = function(type, data) {
    for (var i = 0; i < this.actors.length; i++) {
        this.actors[i].send(type, data);
    }
};

Dispatcher.prototype.send = function(type, data, callback, targetID, buffers) {
    if (typeof targetID !== 'number' || isNaN(targetID)) {
        // Use round robin to send requests to web workers.
        targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
    }

    this.actors[targetID].send(type, data, callback, buffers);
    return targetID;
};


},{"../actor.js":75}],80:[function(require,module,exports){
'use strict';

module.exports = {
    HTTP_URL: 'http://a.tiles.mapbox.com/v4',
    HTTPS_URL: 'https://a.tiles.mapbox.com/v4',
    FORCE_HTTPS: false,
    REQUIRE_ACCESS_TOKEN: false
};

},{}],81:[function(require,module,exports){
'use strict';

exports.create = function (tagName, className, container) {
    var el = document.createElement(tagName);
    if (className) el.className = className;
    if (container) container.appendChild(el);
    return el;
};

function preventDefault(e) {
    e.preventDefault();
}

var docEl = typeof document !== 'undefined' ? document.documentElement : {},
    selectProp =
        'userSelect' in docEl ? 'userSelect' :
        'MozUserSelect' in docEl ? 'MozUserSelect' :
        'WebkitUserSelect' in docEl ? 'WebkitUserSelect' : null,
    userSelect;

exports.disableDrag = function () {
    window.addEventListener('dragstart', preventDefault);

    if ('onselectstart' in document) window.addEventListener('selectstart', preventDefault);
    else if (selectProp) {
        userSelect = docEl.style[selectProp];
        docEl.style[selectProp] = 'none';
    }
};
exports.enableDrag = function () {
    window.removeEventListener('dragstart', preventDefault);

    if ('onselectstart' in document) window.removeEventListener('selectstart', preventDefault);
    else if (selectProp) docEl.style[selectProp] = userSelect;
};

},{}],82:[function(require,module,exports){
'use strict';

var util = require('./util.js');

module.exports = {
    on: function(type, fn) {
        this._events = this._events || {};
        this._events[type] = this._events[type] || [];
        this._events[type].push(fn);

        return this;
    },

    off: function(type, fn) {
        if (!type) {
            // clear all listeners if no arguments specified
            delete this._events;
            return this;
        }

        if (!this.listens(type)) return this;

        if (fn) {
            var idx = this._events[type].indexOf(fn);
            if (idx >= 0) {
                this._events[type].splice(idx, 1);
            }
            if (!this._events[type].length) {
                delete this._events[type];
            }
        } else {
            delete this._events[type];
        }

        return this;
    },

    fire: function(type, data) {
        if (!this.listens(type)) return this;

        data = util.extend({}, data);
        util.extend(data, {type: type, target: this});

        // make sure adding/removing listeners inside other listeners won't cause infinite loop
        var listeners = this._events[type].slice();

        for (var i = 0; i < listeners.length; i++) {
            listeners[i].call(this, data);
        }

        return this;
    },

    listens: function(type) {
        return !!(this._events && this._events[type]);
    }
};

},{"./util.js":87}],83:[function(require,module,exports){
'use strict';

module.exports = Glyphs;
function Glyphs(buffer, end) {
    // Public
    this.stacks = {};
    // Private
    this._buffer = buffer;

    var val, tag;
    if (typeof end === 'undefined') end = buffer.length;
    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;
        if (tag == 1) {
            var fontstack = this.readFontstack();
            this.stacks[fontstack.name] = fontstack;
        } else {
            // console.warn('skipping tile tag ' + tag);
            buffer.skip(val);
        }
    }
}

Glyphs.prototype.readFontstack = function() {
    var buffer = this._buffer;
    var fontstack = { glyphs: {} };

    var bytes = buffer.readVarint();
    var val, tag;
    var end = buffer.pos + bytes;
    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;

        if (tag == 1) {
            fontstack.name = buffer.readString();
        } else if (tag == 2) {
            var range = buffer.readString();
            fontstack.range = range;
        } else if (tag == 3) {
            var glyph = this.readGlyph();
            fontstack.glyphs[glyph.id] = glyph;
        } else {
            buffer.skip(val);
        }
    }

    return fontstack;
};

Glyphs.prototype.readGlyph = function() {
    var buffer = this._buffer;
    var glyph = {};

    var bytes = buffer.readVarint();
    var val, tag;
    var end = buffer.pos + bytes;
    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;

        if (tag == 1) {
            glyph.id = buffer.readVarint();
        } else if (tag == 2) {
            glyph.bitmap = buffer.readBuffer();
        } else if (tag == 3) {
            glyph.width = buffer.readVarint();
        } else if (tag == 4) {
            glyph.height = buffer.readVarint();
        } else if (tag == 5) {
            glyph.left = buffer.readSVarint();
        } else if (tag == 6) {
            glyph.top = buffer.readSVarint();
        } else if (tag == 7) {
            glyph.advance = buffer.readVarint();
        } else {
            buffer.skip(val);
        }
    }

    return glyph;
};

},{}],84:[function(require,module,exports){
'use strict';

var config = require('./config');

function normalizeURL(url, accessToken) {
    accessToken = accessToken || config.ACCESS_TOKEN;

    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
        throw new Error('An API access token is required to use Mapbox GL. ' +
            'See https://www.mapbox.com/developers/api/#access-tokens');
    }

    var https = config.FORCE_HTTPS ||
        (typeof document !== 'undefined' && 'https:' === document.location.protocol);

    url = url.replace(/^mapbox:\/\//, (https ? config.HTTPS_URL : config.HTTP_URL) + '/');
    url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';

    if (config.REQUIRE_ACCESS_TOKEN) {
        if (accessToken[0] === 's') {
            throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        url += accessToken;
    }

    return url;
}

module.exports.normalizeSourceURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\//))
        return url;

    url = normalizeURL(url + '.json', accessToken);

    // TileJSON requests need a secure flag appended to their URLs so
    // that the server knows to send SSL-ified resource references.
    if (url.indexOf('https') === 0)
        url += '&secure';

    return url;
};

module.exports.normalizeGlyphsURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\//))
        return url;

    return normalizeURL(url, accessToken);
};

},{"./config":80}],85:[function(require,module,exports){
'use strict';

/*
 * A [most-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
 * with hash lookup made possible by keeping a list of keys in parallel to
 * an array of dictionary of values
 */
module.exports = MRUCache;
function MRUCache(length, onRemove) {
    this.max = length;
    this.onRemove = onRemove;
    this.reset();
}

/*
 * Clears the cache
 */
MRUCache.prototype.reset = function() {
    this.list = {};
    this.order = [];

    return this;
};

/*
 * Add a key, value combination to the cache, trimming its size if this pushes
 * it over max length.
 */
MRUCache.prototype.add = function(key, data) {
    this.list[key] = data;
    this.order.push(key);

    if (this.order.length > this.max) {
        var removedData = this.get(this.order[0]);
        if (removedData) this.onRemove(removedData);
    }

    return this;
};

/*
 * Determine whether the value attached to `key` is present
 */
MRUCache.prototype.has = function(key) {
    return key in this.list;
};

/*
 * List all keys in the cache
 */
MRUCache.prototype.keys = function() {
    return this.order;
};

/*
 * Get the value attached to a specific key. If the key is not found,
 * returns `null`
 */
MRUCache.prototype.get = function(key) {
    if (!this.has(key)) { return null; }

    var data = this.list[key];

    delete this.list[key];
    this.order.splice(this.order.indexOf(key), 1);

    return data;
};

},{}],86:[function(require,module,exports){
'use strict';

module.exports = resolveTokens;

var tokenPattern = /{([\w-]+)}/;

function resolveTokens(properties, expression) {
    var match;
    var value;
    var text = expression;
    while ((match = text.match(tokenPattern))) {
        value = typeof properties[match[1]] === 'undefined' ? '' : properties[match[1]];
        text = text.replace(match[0], value);
    }
    return text;
}

},{}],87:[function(require,module,exports){
'use strict';

var UnitBezier = require('unitbezier');

exports.easeCubicInOut = function (t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t,
        t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
};

exports.bezier = function(p1x, p1y, p2x, p2y) {
    var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
    return function(t) {
        return bezier.solve(t);
    };
};

exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);

exports.interp = function (a, b, t) {
    return (a * (1 - t)) + (b * t);
};

exports.premultiply = function (c) {
    c[0] *= c[3];
    c[1] *= c[3];
    c[2] *= c[3];
    return c;
};

exports.asyncEach = function (array, fn, callback) {
    var remaining = array.length;
    if (remaining === 0) return callback();
    function check() { if (--remaining === 0) callback(); }
    for (var i = 0; i < array.length; i++) fn(array[i], check);
};

exports.keysDifference = function (obj, other) {
    var difference = [];
    for (var i in obj) {
        if (!(i in other)) {
            difference.push(i);
        }
    }
    return difference;
};

exports.extend = function (dest, src) {
    for (var i in src) {
        dest[i] = src[i];
    }
    return dest;
};

exports.extendAll = function (dest, src) {
    for (var i in src) {
        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
    }
    return dest;
};

exports.inherit = function (parent, props) {
    var parentProto = typeof parent === 'function' ? parent.prototype : parent,
        proto = Object.create(parentProto);
    exports.extendAll(proto, props);
    return proto;
};

exports.pick = function (src) {
    var result = {};
    for (var i = 1; i < arguments.length; i++) {
        var k = arguments[i];
        if (k in src) {
            result[k] = src[k];
        }
    }
    return result;
};

var id = 1;

exports.uniqueId = function () {
    return id++;
};

exports.throttle = function (fn, time, context) {
    var lock, args, wrapperFn, later;

    later = function () {
        // reset lock and call if queued
        lock = false;
        if (args) {
            wrapperFn.apply(context, args);
            args = false;
        }
    };

    wrapperFn = function () {
        if (lock) {
            // called too soon, queue to call later
            args = arguments;

        } else {
            // call and lock until later
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
        }
    };

    return wrapperFn;
};

exports.debounce = function(fn, time) {
    var timer, args;

    return function() {
        args = arguments;
        clearTimeout(timer);

        timer = setTimeout(function() {
            fn.apply(null, args);
        }, time);
    };
};

},{"unitbezier":98}],88:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],89:[function(require,module,exports){
var geojsonArea = require('geojson-area');

module.exports = rewind;

function rewind(gj, outer) {
    switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
            gj.features = gj.features.map(curryOuter(rewind, outer));
            return gj;
        case 'Feature':
            gj.geometry = rewind(gj.geometry, outer);
            return gj;
        case 'Polygon':
        case 'MultiPolygon':
            return correct(gj, outer);
        default:
            return gj;
    }
}

function curryOuter(a, b) {
    return function(_) { return a(_, b); };
}

function correct(_, outer) {
    if (_.type === 'Polygon') {
        _.coordinates = correctRings(_.coordinates, outer);
    } else if (_.type === 'MultiPolygon') {
        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
    }
    return _;
}

function correctRings(_, outer) {
    outer = !!outer;
    _[0] = wind(_[0], !outer);
    for (var i = 1; i < _.length; i++) {
        _[i] = wind(_[i], outer);
    }
    return _;
}

function wind(_, dir) {
    return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
    return geojsonArea.ring(_) >= 0;
}

},{"geojson-area":90}],90:[function(require,module,exports){
var wgs84 = require('wgs84');

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    if (_.type === 'Polygon') return polygonArea(_.coordinates);
    else if (_.type === 'MultiPolygon') {
        var area = 0;
        for (var i = 0; i < _.coordinates.length; i++) {
            area += polygonArea(_.coordinates[i]);
        }
        return area;
    } else {
        return null;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var area = 0;

    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

},{"wgs84":91}],91:[function(require,module,exports){
module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;

},{}],92:[function(require,module,exports){
module.exports={
  "$version": 5,
  "$root": {
    "version": {
      "required": true,
      "type": "enum",
      "values": [
        5
      ],
      "doc": "Stylesheet version number. Must be 5."
    },
    "constants": {
      "type": "constants",
      "doc": "An object of constants to be referenced in layers."
    },
    "sources": {
      "required": true,
      "type": "sources",
      "doc": "Data source specifications for layers to pull from."
    },
    "layers": {
      "required": true,
      "type": "array",
      "value": "layer",
      "doc": "An array of layers. The order of layers coincides with the order they will be drawn."
    },
    "sprite": {
      "type": "sprite",
      "doc": "Sprite definition."
    },
    "glyphs": {
      "type": "string",
      "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}."
    },
    "transition": {
      "type": "transition",
      "doc": "A global transition definition to use as a default across properties."
    }
  },
  "sprite": [{
    "type": "string",
    "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended."
  }],
  "constants": {
    "*": {
      "type": "*",
      "doc": "A constant that will be replaced verbatim in the referencing place. This can be anything, including objects and arrays. All variable names must be prefixed with an `@` symbol."
    }
  },
  "sources": {
    "*": {
      "type": "source",
      "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
    }
  },
  "source": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "vector",
        "raster",
        "geojson",
        "video"
      ],
      "doc": "The data type of the source."
    },
    "url": {
      "type": "string",
      "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
    },
    "tiles": {
      "type": "string",
      "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    "minzoom": {
      "type": "number",
      "default": 0,
      "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    "maxzoom": {
      "type": "number",
      "default": 22,
      "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    "tileSize": {
      "type": "number",
      "default": 512,
      "doc": "The minimum visual size (in px) to display tiles for this layer. Only configurable for raster layers."
    },
    "*": {
      "type": "*",
      "doc": "Other keys to configure the data source."
    }
  },
  "layer": {
    "id": {
      "type": "string",
      "doc": "Unique layer name."
    },
    "type": {
      "type": "enum",
      "values": [
        "fill",
        "line",
        "symbol",
        "raster",
        "background"
      ],
      "doc": "Rendering type of this layer."
    },
    "ref": {
      "type": "string",
      "doc": "References another layer to copy `source`, `source_layer`, `filter`, and `render` properties from. This allows the layers to share processing and be more efficient."
    },
    "source": {
      "type": "string",
      "doc": "Name of a source description to be used for this layer."
    },
    "source-layer": {
      "type": "string",
      "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
    },
    "min-zoom": {
      "type": "number",
      "doc": "The minimum zoom level on which the layer gets parsed and appears on."
    },
    "max-zoom": {
      "type": "number",
      "doc": "The maximum zoom level on which the layer gets parsed and appears on."
    },
    "interactive": {
      "type": "boolean",
      "doc": "Enable querying of feature data from this layer for interactivity.",
      "default": false
    },
    "render": {
      "type": "render",
      "doc": "Symbolizer type that should be used to visualize this layer. If unspecified or null, this layer is not treated as a symbolizer and only exists to have properties inherited to other layers using ref."
    },
    "filter": {
      "type": "filter",
      "doc": "Array or object of filters or expressions."
    },
    "layers": {
      "type": "array",
      "value": "layer",
      "doc": "If `type` is `raster`, the child layers are composited together onto the previous level layer level."
    },
    "style": {
      "type": "class",
      "doc": "Default style properties for this layer."
    },
    "style.*": {
      "type": "class",
      "doc": "Override style properties for this layer. The class name is the part after the first dot."
    }
  },
  "render": [
    "render_fill",
    "render_line",
    "render_symbol",
    "render_raster",
    "render_background"
  ],
  "render_background": {
  },
  "render_fill": {
  },
  "render_line": {
    "line-cap": {
      "type": "enum",
      "values": [
        "butt",
        "round",
        "square"
      ],
      "default": "butt",
      "doc": "The display of line endings."
    },
    "line-join": {
      "type": "enum",
      "values": [
        "bevel",
        "round",
        "miter"
      ],
      "default": "miter",
      "doc": "The display of lines when joining."
    },
    "line-miter-limit": {
      "type": "number",
      "default": 2,
      "doc": "Used to automatically convert miter joins to bevel joins for sharp angles."
    },
    "line-round-limit": {
      "type": "number",
      "default": 1,
      "doc": "Used to automatically convert round joins to miter joins for shallow angles."
    }
  },
  "render_symbol": {
    "symbol-placement": {
        "type": "enum",
        "values": [
            "point",
            "line"
        ],
        "default": "point",
        "doc": "Placement of a label relative to its geometry. `Line` can only be used on LineStrings and Polygons."
    },
    "symbol-min-distance": {
      "type": "number",
      "default": 250,
      "doc": "Minimum distance between two symbol anchors (px)"
    },
    "symbol-avoid-edges": {
        "type": "boolean",
        "default": false,
        "doc": "If true, the symbols will not cross tile edges. Symbols that cross tile edges may cause collisions in some cases. This property should be set to true if the layer does not have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
    },
    "icon-allow-overlap": {
        "type": "boolean",
        "default": false,
        "doc": "If true, the icon will be visible even if it collides with other icons and text."
    },
    "icon-ignore-placement": {
        "type": "boolean",
        "default": false,
        "doc": "If true, the icon won't affect placement of other icons and text."
    },
    "icon-optional": {
        "type": "boolean",
        "default": false,
        "doc": "If true, text can be shown without its corresponding icon."
    },
    "icon-rotation-alignment": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon when map is rotated"
    },
    "icon-max-size": {
      "type": "number",
      "default": 1,
      "doc": "The maximum amount to scale the icon by."
    },
    "icon-image": {
      "type": "string",
      "doc": "A string with {tokens} replaced, referencing the data property to pull from."
    },
    "icon-rotate": {
      "type": "number",
      "default": 0,
      "doc": "Rotates the icon clockwise by the specified number of degrees."
    },
    "icon-padding": {
      "type": "number",
      "default": 2,
      "doc": "Padding value around icon bounding box to avoid icon collisions (px)."
    },
    "icon-keep-upright": {
        "type": "boolean",
        "default": false,
        "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down"
    },
    "icon-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "doc": "Icon's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "text-rotation-alignment": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon or text when map is rotated"
    },
    "text-field": {
      "type": "string",
      "default": "",
      "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
    },
    "text-font": {
      "type": "string",
      "doc": "Font stack to use for displaying text."
    },
    "text-max-size": {
      "type": "number",
      "default": 16,
      "doc": "The maximum size text will be displayed."
    },
    "text-max-width": {
      "type": "number",
      "default": 15,
      "doc": "The maximum line width for text wrapping (em)."
    },
    "text-line-height": {
      "type": "number",
      "default": 1.2,
      "doc": "Text leading value for multi-line text."
    },
    "text-letter-spacing": {
      "type": "number",
      "default": 0,
      "doc": "Text kerning value (em)."
    },
    "text-justify": {
      "type": "enum",
      "values": [
        "center",
        "left",
        "right"
      ],
      "default": "center",
      "doc": "Text justification options."
    },
    "text-horizontal-align": {
      "type": "enum",
      "values": [
        "left",
        "center",
        "right"
      ],
      "default": "center",
      "doc": "Horizontal alignment of the text relative to the anchor."
    },
    "text-vertical-align": {
      "type": "enum",
      "values": [
        "top",
        "center",
        "bottom"
      ],
      "default": "center",
      "doc": "Vertical alignment of the text relative to the anchor."
    },
    "text-max-angle": {
      "type": "number",
      "default": 45,
      "doc": "The maximum angle change, in degrees, allowed between adjacent characters."
    },
    "text-rotate": {
      "type": "number",
      "default": 0,
      "doc": "Rotates the text clockwise by the specified number of degrees."
    },
    "text-padding": {
      "type": "number",
      "default": 2,
      "doc": "Padding value around text bounding box to avoid label collisions (px)."
    },
    "text-keep-upright": {
        "type": "boolean",
        "default": true,
        "doc": "If true, the direction of the text may be flipped to prevent it from being rendered upside-down"
    },
    "text-transform": {
      "type": "enum",
      "values": [
        "none",
        "uppercase",
        "lowercase"
      ],
      "default": "none",
      "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property."
    },
    "text-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ]
    },
    "text-allow-overlap": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the text will be visible even if it collides with other icons and labels."
    },
    "text-ignore-placement": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the text won't affect placement of other icons and labels."
    },
    "text-optional": {
        "type": "boolean",
        "default": false,
        "doc": "If true, icons can be shown without their corresponding text."
    }
  },
  "render_raster": {
    "raster-size": {
      "type": "number",
      "function": true,
      "default": 256,
      "doc": "The texture image size (in pixels) vector layers will be rasterized at. Will automatically by scaled to match the visual tile size."
    },
    "raster-blur": {
      "type": "number",
      "function": true,
      "default": 0,
      "doc": "Blur radius to apply to the raster texture before display."
    }
  },
  "filter": [
    {
      "type": "filter_expression",
      "doc": "Various filter expressions. Unless overridden by parent, these are interpreted as `AND`."
    },
    {
      "type": "array",
      "value": "filter_expression",
      "doc": "Various filter expressions. Unless overridden by parent, these are interpreted as `OR`."
    }
  ],
  "filter_expression": {
    "&": {
      "type": "filter",
      "doc": "AND operator."
    },
    "|": {
      "type": "filter",
      "doc": "OR operator."
    },
    "^": {
      "type": "filter",
      "doc": "XOR operator."
    },
    "!": {
      "type": "filter",
      "doc": "NOR operator."
    },
    "$type": {
      "type": "enum",
      "values": [
        "Point",
        "LineString",
        "Polygon"
      ],
      "doc": "Geometry type that features must match."
    },
    "*": [
      {
        "type": "filter_comparison",
        "doc": "Arbitarily named feature member. A comparison object defining a filter expression."
      },
      {
        "type": "filter_value",
        "doc": "Arbitarily named feature member. A filter_value implies the equality (string/number/boolean) or set membership operator (array)."
      }
    ]
  },
  "filter_comparison": {
    "==": {
      "type": "filter_value",
      "doc": "Equality operator."
    },
    "!=": {
      "type": "filter_value",
      "doc": "Inequality operator."
    },
    ">": {
      "type": "filter_value",
      "doc": "Greater than operator."
    },
    ">=": {
      "type": "filter_value",
      "doc": "Greater or equal than operator."
    },
    "<": {
      "type": "filter_value",
      "doc": "Less than operator."
    },
    "<=": {
      "type": "filter_value",
      "doc": "Less than or equal operator."
    },
    "in": {
      "type": "array",
      "value": "filter_primitive",
      "doc": "Set member operator."
    },
    "!in": {
      "type": "array",
      "value": "filter_primitive",
      "doc": "Not in set operator."
    }
  },
  "filter_value": [
    {
      "type": "filter_primitive"
    },
    {
      "type": "array",
      "value": "filter_primitive"
    }
  ],
  "filter_primitive": [
    {
      "type": "string"
    },
    {
      "type": "number"
    },
    {
      "type": "boolean"
    }
  ],
  "function": {
    "stops": {
      "type": "array",
      "required": true,
      "doc": "An array of stops.",
      "value": "function_stop"
    },
    "base": {
      "type": "number",
      "default": 1,
      "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    }
  },
  "function_stop": {
    "type": "array",
    "value": ["number", "color"],
    "length": 2,
    "doc": "Zoom level and value pair."
  },
  "class": [
    "class_fill",
    "class_line",
    "class_symbol",
    "class_raster",
    "class_background"
  ],
  "class_fill": {
    "fill-antialias": {
      "type": "boolean",
      "default": true,
      "function": true,
      "doc": "Whether or not the fill should be antialiased."
    },
    "fill-opacity": {
      "type": "number",
      "function": true,
      "default": 1,
      "transition": true
    },
    "fill-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "fill-outline-color": {
      "type": "color",
      "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
      "function": true,
      "transition": true
    },
    "fill-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "The geometry's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "fill-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map"
    },
    "fill-image": {
      "type": "string",
      "doc": "Name of image in sprite to use for drawing image fills."
    }
  },
  "class_line": {
    "line-opacity": {
      "type": "number",
      "function": true,
      "default": 1,
      "transition": true
    },
    "line-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "line-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "The geometry's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "line-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map"
    },
    "line-width": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true,
      "doc": "Line width (in px)"
    },
    "line-offset": {
      "type": "number",
      "default": 0,
      "doc": "Line casing where `line-offset` indicates total width. @TODO rename?",
      "function": true,
      "transition": true
    },
    "line-blur": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Line blur, in pixels."
    },
    "line-dasharray": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        1,
        -1
      ],
      "function": true,
      "transition": true
    },
    "line-image": {
      "type": "string",
      "doc": "Name of image in sprite to use for drawing image lines."
    }
  },
  "class_symbol": {
    "icon-opacity": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true
    },
    "icon-size": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true,
      "doc": "The amount to scale the icon by. 1 is original size, 3 triples the size."
    },
    "icon-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true,
      "doc": "The color of the icon. This can only be used with sdf icons."
    },
    "icon-halo-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons."
    },
    "icon-halo-width": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "How far away the halo is from the icon outline, in pixels."
    },
    "icon-halo-blur": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Fade out the halo towards the outside, in pixels."
    },
    "icon-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "An icon's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "icon-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map"
    },
    "text-opacity": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true
    },
    "text-size": {
      "type": "number",
      "default": 16,
      "function": true,
      "transition": true,
      "doc": "Font size in pixels. If unspecified, the text will be as big as allowed by the layer definition."
    },
    "text-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "text-halo-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        0
      ],
      "function": true,
      "transition": true
    },
    "text-halo-width": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "How far away the halo is from the font outline, in pixels. Max text halo width is 1/4 of the font-size (px)."
    },
    "text-halo-blur": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Fade out the halo towards the outside, in pixels."
    },
    "text-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "A label's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "text-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map"
    }
  },
  "class_raster": {
    "raster-opacity": {
      "type": "number",
      "default": 1,
      "transition": true
    },
    "raster-hue-rotate": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Rotates hues around the color wheel by the specified number of degrees."
    },
    "raster-brightness": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "raster-saturation": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true
    },
    "raster-contrast": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true
    },
    "raster-fade-duration": {
      "type": "number",
      "default": 300,
      "function": true,
      "transition": true,
      "doc": "Duration in milliseconds of the fade when a new tile is added."
    }
  },
  "class_background": {
    "background-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "background-image": {
      "type": "string"
    },
    "background-opacity": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true
    }
  },
  "transition": {
    "duration": {
      "type": "number",
      "default": 300,
      "doc": "Time in milliseconds that it takes for transitions to complete."
    },
    "delay": {
      "type": "number",
      "default": 0,
      "doc": "Time in milliseconds before a transition begins."
    }
  }
}

},{}],93:[function(require,module,exports){
(function (Buffer){
'use strict';

var ieee754 = require('ieee754');

module.exports = Protobuf;
function Protobuf(buf) {
    this.buf = buf;
    this.pos = 0;
}

Protobuf.prototype = {
    get length() { return this.buf.length; }
};

Protobuf.Varint = 0;
Protobuf.Int64 = 1;
Protobuf.Message = 2;
Protobuf.String = 2;
Protobuf.Packed = 2;
Protobuf.Int32 = 5;

Protobuf.prototype.destroy = function() {
    this.buf = null;
};

// === READING =================================================================

Protobuf.prototype.readUInt32 = function() {
    var val = this.buf.readUInt32LE(this.pos);
    this.pos += 4;
    return val;
};

Protobuf.prototype.readUInt64 = function() {
    var val = this.buf.readUInt64LE(this.pos);
    this.pos += 8;
    return val;
};

Protobuf.prototype.readDouble = function() {
    var val = ieee754.read(this.buf, this.pos, true, 52, 8);
    this.pos += 8;
    return val;
};

Protobuf.prototype.readVarint = function() {
    // TODO: bounds checking
    var pos = this.pos;
    if (this.buf[pos] <= 0x7f) {
        this.pos++;
        return this.buf[pos];
    } else if (this.buf[pos + 1] <= 0x7f) {
        this.pos += 2;
        return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] << 7);
    } else if (this.buf[pos + 2] <= 0x7f) {
        this.pos += 3;
        return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2]) << 14;
    } else if (this.buf[pos + 3] <= 0x7f) {
        this.pos += 4;
        return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2] & 0x7f) << 14 | (this.buf[pos + 3]) << 21;
    } else if (this.buf[pos + 4] <= 0x7f) {
        this.pos += 5;
        return ((this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2] & 0x7f) << 14 | (this.buf[pos + 3]) << 21) + (this.buf[pos + 4] * 268435456);
    } else {
        this.skip(Protobuf.Varint);
        return 0;
        // throw new Error("TODO: Handle 6+ byte varints");
    }
};

Protobuf.prototype.readSVarint = function() {
    var num = this.readVarint();
    if (num > 2147483647) throw new Error('TODO: Handle numbers >= 2^30');
    // zigzag encoding
    return ((num >> 1) ^ -(num & 1));
};

Protobuf.prototype.readString = function() {
    var bytes = this.readVarint();
    // TODO: bounds checking
    var chr = String.fromCharCode;
    var b = this.buf;
    var p = this.pos;
    var end = this.pos + bytes;
    var str = '';
    while (p < end) {
        if (b[p] <= 0x7F) str += chr(b[p++]);
        else if (b[p] <= 0xBF) throw new Error('Invalid UTF-8 codepoint: ' + b[p]);
        else if (b[p] <= 0xDF) str += chr((b[p++] & 0x1F) << 6 | (b[p++] & 0x3F));
        else if (b[p] <= 0xEF) str += chr((b[p++] & 0x1F) << 12 | (b[p++] & 0x3F) << 6 | (b[p++] & 0x3F));
        else if (b[p] <= 0xF7) p += 4; // We can't handle these codepoints in JS, so skip.
        else if (b[p] <= 0xFB) p += 5;
        else if (b[p] <= 0xFD) p += 6;
        else throw new Error('Invalid UTF-8 codepoint: ' + b[p]);
    }
    this.pos += bytes;
    return str;
};

Protobuf.prototype.readBuffer = function() {
    var bytes = this.readVarint();
    var buffer = this.buf.subarray(this.pos, this.pos + bytes);
    this.pos += bytes;
    return buffer;
};

Protobuf.prototype.readPacked = function(type) {
    // TODO: bounds checking
    var bytes = this.readVarint();
    var end = this.pos + bytes;
    var array = [];
    while (this.pos < end) {
        array.push(this['read' + type]());
    }
    return array;
};

Protobuf.prototype.skip = function(val) {
    // TODO: bounds checking
    var type = val & 0x7;
    switch (type) {
        /* varint */ case Protobuf.Varint: while (this.buf[this.pos++] > 0x7f); break;
        /* 64 bit */ case Protobuf.Int64: this.pos += 8; break;
        /* length */ case Protobuf.Message: var bytes = this.readVarint(); this.pos += bytes; break;
        /* 32 bit */ case Protobuf.Int32: this.pos += 4; break;
        default: this.pos += 4;//throw new Error('Unimplemented type: ' + type);
    }
};

// === WRITING =================================================================

Protobuf.prototype.writeTag = function(tag, type) {
    this.writeVarint((tag << 3) | type);
};

Protobuf.prototype.realloc = function(min) {
    var length = this.buf.length;
    while (length < this.pos + min) length *= 2;
    if (length != this.buf.length) {
        var buf = new Buffer(length);
        this.buf.copy(buf);
        this.buf = buf;
    }
};

Protobuf.prototype.finish = function() {
    return this.buf.slice(0, this.pos);
};

Protobuf.prototype.writePacked = function(type, tag, items) {
    if (!items.length) return;

    var message = new Protobuf();
    for (var i = 0; i < items.length; i++) {
        message['write' + type](items[i]);
    }
    var data = message.finish();

    this.writeTag(tag, Protobuf.Packed);
    this.writeBuffer(data);
};

Protobuf.prototype.writeUInt32 = function(val) {
    this.realloc(4);
    this.buf.writeUInt32LE(val, this.pos);
    this.pos += 4;
};

Protobuf.prototype.writeTaggedUInt32 = function(tag, val) {
    this.writeTag(tag, Protobuf.Int32);
    this.writeUInt32(val);
};

Protobuf.prototype.writeVarint = function(val) {
    val = Number(val);
    if (isNaN(val)) {
        val = 0;
    }

    if (val <= 0x7f) {
        this.realloc(1);
        this.buf[this.pos++] = val;
    } else if (val <= 0x3fff) {
        this.realloc(2);
        this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
        this.buf[this.pos++] = 0x00 | ((val >>> 7) & 0x7f);
    } else if (val <= 0x1ffffff) {
        this.realloc(3);
        this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
        this.buf[this.pos++] = 0x80 | ((val >>> 7) & 0x7f);
        this.buf[this.pos++] = 0x00 | ((val >>> 14) & 0x7f);
    } else if (val <= 0xfffffff) {
        this.realloc(4);
        this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
        this.buf[this.pos++] = 0x80 | ((val >>> 7) & 0x7f);
        this.buf[this.pos++] = 0x80 | ((val >>> 14) & 0x7f);
        this.buf[this.pos++] = 0x00 | ((val >>> 21) & 0x7f);
    } else {
        while (val > 0) {
            var b = val & 0x7f;
            val = Math.floor(val / 128);
            if (val > 0) b |= 0x80
            this.realloc(1);
            this.buf[this.pos++] = b;
        }
    }
};

Protobuf.prototype.writeTaggedVarint = function(tag, val) {
    this.writeTag(tag, Protobuf.Varint);
    this.writeVarint(val);
};

Protobuf.prototype.writeSVarint = function(val) {
    if (val >= 0) {
        this.writeVarint(val * 2);
    } else {
        this.writeVarint(val * -2 - 1);
    }
};

Protobuf.prototype.writeTaggedSVarint = function(tag, val) {
    this.writeTag(tag, Protobuf.Varint);
    this.writeSVarint(val);
};

Protobuf.prototype.writeBoolean = function(val) {
    this.writeVarint(Boolean(val));
};

Protobuf.prototype.writeTaggedBoolean = function(tag, val) {
    this.writeTaggedVarint(tag, Boolean(val));
};

Protobuf.prototype.writeString = function(str) {
    str = String(str);
    var bytes = Buffer.byteLength(str);
    this.writeVarint(bytes);
    this.realloc(bytes);
    this.buf.write(str, this.pos);
    this.pos += bytes;
};

Protobuf.prototype.writeTaggedString = function(tag, str) {
    this.writeTag(tag, Protobuf.String);
    this.writeString(str);
};

Protobuf.prototype.writeFloat = function(val) {
    this.realloc(4);
    this.buf.writeFloatLE(val, this.pos);
    this.pos += 4;
};

Protobuf.prototype.writeTaggedFloat = function(tag, val) {
    this.writeTag(tag, Protobuf.Int32);
    this.writeFloat(val);
};

Protobuf.prototype.writeDouble = function(val) {
    this.realloc(8);
    this.buf.writeDoubleLE(val, this.pos);
    this.pos += 8;
};

Protobuf.prototype.writeTaggedDouble = function(tag, val) {
    this.writeTag(tag, Protobuf.Int64);
    this.writeDouble(val);
};

Protobuf.prototype.writeBuffer = function(buffer) {
    var bytes = buffer.length;
    this.writeVarint(bytes);
    this.realloc(bytes);
    buffer.copy(this.buf, this.pos);
    this.pos += bytes;
};

Protobuf.prototype.writeTaggedBuffer = function(tag, buffer) {
    this.writeTag(tag, Protobuf.String);
    this.writeBuffer(buffer);
};

Protobuf.prototype.writeMessage = function(tag, protobuf) {
    var buffer = protobuf.finish();
    this.writeTag(tag, Protobuf.Message);
    this.writeBuffer(buffer);
};

}).call(this,require("buffer").Buffer)
},{"buffer":103,"ieee754":94}],94:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],95:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],96:[function(require,module,exports){
(function() {
  var slice = [].slice;

  function queue(parallelism) {
    var q,
        tasks = [],
        started = 0, // number of tasks that have been started (and perhaps finished)
        active = 0, // number of tasks currently being executed (started but not finished)
        remaining = 0, // number of tasks not yet finished
        popping, // inside a synchronous task callback?
        error = null,
        await = noop,
        all;

    if (!parallelism) parallelism = Infinity;

    function pop() {
      while (popping = started < tasks.length && active < parallelism) {
        var i = started++,
            t = tasks[i],
            a = slice.call(t, 1);
        a.push(callback(i));
        ++active;
        t[0].apply(null, a);
      }
    }

    function callback(i) {
      return function(e, r) {
        --active;
        if (error != null) return;
        if (e != null) {
          error = e; // ignore new tasks and squelch active callbacks
          started = remaining = NaN; // stop queued tasks from starting
          notify();
        } else {
          tasks[i] = r;
          if (--remaining) popping || pop();
          else notify();
        }
      };
    }

    function notify() {
      if (error != null) await(error);
      else if (all) await(error, tasks);
      else await.apply(null, [error].concat(tasks));
    }

    return q = {
      defer: function() {
        if (!error) {
          tasks.push(arguments);
          ++remaining;
          pop();
        }
        return q;
      },
      await: function(f) {
        await = f;
        all = false;
        if (!remaining) notify();
        return q;
      },
      awaitAll: function(f) {
        await = f;
        all = true;
        if (!remaining) notify();
        return q;
      }
    };
  }

  function noop() {}

  queue.version = "1.0.7";
  if (typeof define === "function" && define.amd) define(function() { return queue; });
  else if (typeof module === "object" && module.exports) module.exports = queue;
  else this.queue = queue;
})();

},{}],97:[function(require,module,exports){
/*
 (c) 2013, Vladimir Agafonkin
 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
 https://github.com/mourner/rbush
*/

(function () { 'use strict';

function rbush(maxEntries, format) {

    // jshint newcap: false, validthis: true
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node.bbox)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child.bbox;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = {
            children: [],
            height: 1,
            bbox: empty(),
            leaf: true
        };
        return this;
    },

    remove: function (item) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = node.children.indexOf(item);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node.bbox, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: function (a, b) { return a[0] - b[0]; },
    compareMinY: function (a, b) { return a[1] - b[1]; },

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = {
                children: items.slice(left, right + 1),
                height: 1,
                bbox: null,
                leaf: true
            };
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        // TODO eliminate recursion?

        node = {
            children: [],
            height: height,
            bbox: null
        };

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child.bbox);
                enlargement = enlargedArea(bbox, child.bbox) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode;
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item.bbox : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node.bbox, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var newNode = {
            children: node.children.splice(this._chooseSplitIndex(node, m, M)),
            height: node.height
        };

        if (node.leaf) newNode.leaf = true;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = {
            children: [node, newNode],
            height: node.height + 1
        };
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i].bbox, bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        // jshint evil: true

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
    }
};


// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    node.bbox = distBBox(node, 0, node.children.length, toBBox);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox) {
    var bbox = empty();

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(bbox, node.leaf ? toBBox(child) : child.bbox);
    }

    return bbox;
}

function empty() { return [Infinity, Infinity, -Infinity, -Infinity]; }

function extend(a, b) {
    a[0] = Math.min(a[0], b[0]);
    a[1] = Math.min(a[1], b[1]);
    a[2] = Math.max(a[2], b[2]);
    a[3] = Math.max(a[3], b[3]);
    return a;
}

function compareNodeMinX(a, b) { return a.bbox[0] - b.bbox[0]; }
function compareNodeMinY(a, b) { return a.bbox[1] - b.bbox[1]; }

function bboxArea(a)   { return (a[2] - a[0]) * (a[3] - a[1]); }
function bboxMargin(a) { return (a[2] - a[0]) + (a[3] - a[1]); }

function enlargedArea(a, b) {
    return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
           (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
}

function intersectionArea (a, b) {
    var minX = Math.max(a[0], b[0]),
        minY = Math.max(a[1], b[1]),
        maxX = Math.min(a[2], b[2]),
        maxY = Math.min(a[3], b[3]);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a[0] <= b[0] &&
           a[1] <= b[1] &&
           b[2] <= a[2] &&
           b[3] <= a[3];
}

function intersects (a, b) {
    return b[0] <= a[2] &&
           b[1] <= a[3] &&
           b[2] >= a[0] &&
           b[3] >= a[1];
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        select(arr, left, right, mid, compare);

        stack.push(left, mid, mid, right);
    }
}

// sort array between left and right (inclusive) so that the smallest k elements come first (unordered)
function select(arr, left, right, k, compare) {
    var n, i, z, s, sd, newLeft, newRight, t, j;

    while (right > left) {
        if (right - left > 600) {
            n = right - left + 1;
            i = k - left + 1;
            z = Math.log(n);
            s = 0.5 * Math.exp(2 * z / 3);
            sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? -1 : 1);
            newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
            newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
            select(arr, newLeft, newRight, k, compare);
        }

        t = arr[k];
        i = left;
        j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}


// export as AMD/CommonJS module or global variable
if (typeof define === 'function' && define.amd) define(function() { return rbush; });
else if (typeof module !== 'undefined') module.exports = rbush;
else if (typeof self !== 'undefined') self.rbush = rbush;
else window.rbush = rbush;

})();

},{}],98:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

},{}],99:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":100,"./lib/vectortilefeature.js":101,"./lib/vectortilelayer.js":102}],100:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(buffer, end) {

    this.layers = {};
    this._buffer = buffer;

    end = end || buffer.length;

    while (buffer.pos < end) {
        var val = buffer.readVarint(),
            tag = val >> 3;

        if (tag == 3) {
            var layer = this.readLayer();
            if (layer.length) this.layers[layer.name] = layer;
        } else {
            buffer.skip(val);
        }
    }
}

VectorTile.prototype.readLayer = function() {
    var buffer = this._buffer,
        bytes = buffer.readVarint(),
        end = buffer.pos + bytes,
        layer = new VectorTileLayer(buffer, end);

    buffer.pos = end;

    return layer;
};

},{"./vectortilelayer":102}],101:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(buffer, end, extent, keys, values) {

    this.properties = {};

    // Public
    this.extent = extent;
    this.type = 0;

    // Private
    this._buffer = buffer;
    this._geometry = -1;

    end = end || buffer.length;

    while (buffer.pos < end) {
        var val = buffer.readVarint(),
            tag = val >> 3;

        if (tag == 1) {
            this._id = buffer.readVarint();

        } else if (tag == 2) {
            var tagEnd = buffer.pos + buffer.readVarint();

            while (buffer.pos < tagEnd) {
                var key = keys[buffer.readVarint()];
                var value = values[buffer.readVarint()];
                this.properties[key] = value;
            }

        } else if (tag == 3) {
            this.type = buffer.readVarint();

        } else if (tag == 4) {
            this._geometry = buffer.pos;
            buffer.skip(val);

        } else {
            buffer.skip(val);
        }
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var buffer = this._buffer;
    buffer.pos = this._geometry;

    var bytes = buffer.readVarint(),
        end = buffer.pos + bytes,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (buffer.pos < end) {
        if (!length) {
            var cmd_length = buffer.readVarint();
            cmd = cmd_length & 0x7;
            length = cmd_length >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += buffer.readSVarint();
            y += buffer.readSVarint();

            if (cmd === 1) {
                // moveTo
                if (line) {
                    lines.push(line);
                }
                line = [];
            }

            line.push(new Point(x, y));
        } else if (cmd === 7) {
            // closePolygon
            line.push(line[0].clone());
        } else {
            throw new Error('unknown command ' + cmd);
        }
    }


    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var buffer = this._buffer;
    buffer.pos = this._geometry;

    var bytes = buffer.readVarint(),
        end = buffer.pos + bytes,

        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (buffer.pos < end) {
        if (!length) {
            var cmd_length = buffer.readVarint();
            cmd = cmd_length & 0x7;
            length = cmd_length >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += buffer.readSVarint();
            y += buffer.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

},{"point-geometry":95}],102:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;
function VectorTileLayer(buffer, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._buffer = buffer;
    this._keys = [];
    this._values = [];
    this._features = [];

    var val, tag;

    end = end || buffer.length;

    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;

        if (tag === 15) {
            this.version = buffer.readVarint();
        } else if (tag === 1) {
            this.name = buffer.readString();
        } else if (tag === 5) {
            this.extent = buffer.readVarint();
        } else if (tag === 2) {
            this.length++;
            this._features.push(buffer.pos);
            buffer.skip(val);

        } else if (tag === 3) {
            this._keys.push(buffer.readString());
        } else if (tag === 4) {
            this._values.push(this.readFeatureValue());
        } else {
            buffer.skip(val);
        }
    }
}

VectorTileLayer.prototype.readFeatureValue = function() {
    var buffer = this._buffer,
        value = null,
        bytes = buffer.readVarint(),
        end = buffer.pos + bytes,
        val, tag;

    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;

        if (tag == 1) {
            value = buffer.readString();
        } else if (tag == 2) {
            throw new Error('read float');
        } else if (tag == 3) {
            value = buffer.readDouble();
        } else if (tag == 4) {
            value = buffer.readVarint();
        } else if (tag == 5) {
            throw new Error('read uint');
        } else if (tag == 6) {
            value = buffer.readSVarint();
        } else if (tag == 7) {
            value = Boolean(buffer.readVarint());
        } else {
            buffer.skip(val);
        }
    }

    return value;
};

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._buffer.pos = this._features[i];
    var end = this._buffer.readVarint() + this._buffer.pos;

    return new VectorTileFeature(this._buffer, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":101}],103:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":104,"ieee754":105}],104:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],105:[function(require,module,exports){
module.exports=require(94)
},{}]},{},[22])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvYnVmZmVyLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvYnVmZmVyc2V0LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvZmlsbGVsZW1lbnRzYnVmZmVyLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvZmlsbHZlcnRleGJ1ZmZlci5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2dseXBodmVydGV4YnVmZmVyLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvaWNvbnZlcnRleGJ1ZmZlci5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2xpbmVlbGVtZW50YnVmZmVyLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvbGluZXZlcnRleGJ1ZmZlci5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL291dGxpbmVlbGVtZW50c2J1ZmZlci5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL2RhdGEvY3JlYXRlYnVja2V0LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9lbGVtZW50Z3JvdXBzLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9mZWF0dXJldHJlZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL2RhdGEvZmlsbGJ1Y2tldC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL2RhdGEvbGluZWJ1Y2tldC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL2RhdGEvcmFzdGVyYnVja2V0LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZGF0YS9zeW1ib2xidWNrZXQuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9nZW8vbGF0bG5nLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvZ2VvL2xhdGxuZ2JvdW5kcy5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL2dlby90cmFuc2Zvcm0uanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9saWIvZGVidWd0ZXh0LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvbGliL2dsbWF0cml4LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvbWFwYm94LWdsLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdiYWNrZ3JvdW5kLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdkZWJ1Zy5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3ZmlsbC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3bGluZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3cmFzdGVyLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdzeW1ib2wuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZHJhd3ZlcnRpY2VzLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2ZyYW1laGlzdG9yeS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9nbHV0aWwuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvcGFpbnRlci5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9wcmVyZW5kZXJlZC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9zaGFkZXJzLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvc291cmNlL2dlb2pzb25zb3VyY2UuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvZ2VvanNvbnRpbGUuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvZ2VvanNvbndyYXBwZXIuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvcmFzdGVydGlsZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS9zb3VyY2UuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdGlsZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS90aWxlY29vcmQuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdGlsZWdlb2pzb24uanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdmVjdG9ydGlsZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS92aWRlb3NvdXJjZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS93b3JrZXIuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zb3VyY2Uvd29ya2VydGlsZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3N0eWxlL2FuaW1hdGlvbmxvb3AuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zdHlsZS9idWNrZXRmaWx0ZXIuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zdHlsZS9jYWxjdWxhdGVkc3R5bGUuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zdHlsZS9pbWFnZXNwcml0ZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3N0eWxlL3JlZmVyZW5jZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3N0eWxlL3JlbmRlcnByb3BlcnRpZXMuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zdHlsZS9zdHlsZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3N0eWxlL3N0eWxlY29uc3RhbnQuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy9zdHlsZS9zdHlsZWRlY2xhcmF0aW9uLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvc3R5bGUvc3R5bGV0cmFuc2l0aW9uLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2FuY2hvci5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9iaW5wYWNrLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2NvbGxpc2lvbi5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9nbHlwaGF0bGFzLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2dseXBoc291cmNlLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2ludGVycG9sYXRlLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL3BsYWNlbWVudC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9yZXNvbHZldGV4dC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9yb3RhdGlvbnJhbmdlLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL3NoYXBpbmcuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy91aS9jb250cm9sL2F0dHJpYnV0aW9uLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdWkvY29udHJvbC9jb250cm9sLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdWkvY29udHJvbC9uYXZpZ2F0aW9uLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdWkvZWFzaW5ncy5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3VpL2hhbmRsZXJzLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdWkvaGFzaC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3VpL2ludGVyYWN0aW9uLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdWkvbWFwLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdXRpbC9hY3Rvci5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3V0aWwvYnJvd3Nlci9hamF4LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdXRpbC9icm93c2VyL2Jyb3dzZXIuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy91dGlsL2Jyb3dzZXIvY2FudmFzLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdXRpbC9icm93c2VyL2Rpc3BhdGNoZXIuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy91dGlsL2NvbmZpZy5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3V0aWwvZG9tLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdXRpbC9ldmVudGVkLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdXRpbC9nbHlwaHMuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy91dGlsL21hcGJveC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL2pzL3V0aWwvbXJ1Y2FjaGUuanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9qcy91dGlsL3Rva2VuLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvanMvdXRpbC91dGlsLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2Nzc2NvbG9ycGFyc2VyL2Nzc2NvbG9ycGFyc2VyLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2dlb2pzb24tcmV3aW5kL2luZGV4LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2dlb2pzb24tcmV3aW5kL25vZGVfbW9kdWxlcy9nZW9qc29uLWFyZWEvaW5kZXguanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvZ2VvanNvbi1yZXdpbmQvbm9kZV9tb2R1bGVzL2dlb2pzb24tYXJlYS9ub2RlX21vZHVsZXMvd2dzODQvaW5kZXguanMiLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL3Y1Lmpzb24iLCIvVXNlcnMvY2hlbG0vU2l0ZXMva29vcC12aXotZXhwZXJpbWVudHMvbWFwYm94LWdsL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvcGJmL2luZGV4LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3BiZi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9wb2ludC1nZW9tZXRyeS9pbmRleC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9xdWV1ZS1hc3luYy9xdWV1ZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9yYnVzaC9yYnVzaC5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy91bml0YmV6aWVyL2luZGV4LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2luZGV4LmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlLmpzIiwiL1VzZXJzL2NoZWxtL1NpdGVzL2tvb3Atdml6LWV4cGVyaW1lbnRzL21hcGJveC1nbC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcyIsIi9Vc2Vycy9jaGVsbS9TaXRlcy9rb29wLXZpei1leHBlcmltZW50cy9tYXBib3gtZ2wvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWxheWVyLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcjRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuLy8gYSBzaW1wbGUgd3JhcHBlciBhcm91bmQgYSBzaW5nbGUgYXJyYXlidWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG5cbmZ1bmN0aW9uIEJ1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuZGVmYXVsdExlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5kZWZhdWx0TGVuZ3RoO1xuICAgICAgICB0aGlzLnNldHVwVmlld3MoKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIG9ubHkgcmVjcmVhdGUgYnVmZmVycyBhZnRlciByZWNlaXZpbmcgdGhlbSBmcm9tIHdvcmtlcnMgZm9yIGJpbmRpbmcgdG8gZ2wsXG4gICAgICAgIC8vIHNvIHdlIG9ubHkgbmVlZCB0aGVzZSAyIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5hcnJheSA9IGJ1ZmZlci5hcnJheTtcbiAgICAgICAgdGhpcy5wb3MgPSBidWZmZXIucG9zO1xuICAgIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZSA9IHtcbiAgICBwb3M6IDAsXG4gICAgaXRlbVNpemU6IDQsIC8vIGJ5dGVzIGluIG9uZSBpdGVtXG4gICAgZGVmYXVsdExlbmd0aDogODE5MiwgLy8gaW5pdGlhbCBidWZmZXIgc2l6ZVxuICAgIGFycmF5VHlwZTogJ0FSUkFZX0JVRkZFUicsIC8vIGdsIGJ1ZmZlciB0eXBlXG5cbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyAvIHRoaXMuaXRlbVNpemU7XG4gICAgfSxcblxuICAgIHNldHVwVmlld3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZXQgdXAgdmlld3MgZm9yIGVhY2ggdHlwZSB0byBhZGQgZGF0YSBvZiBkaWZmZXJlbnQgdHlwZXMgdG8gdGhlIHNhbWUgYnVmZmVyXG4gICAgICAgIHRoaXMudWJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheSk7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBuZXcgSW50OEFycmF5KHRoaXMuYXJyYXkpO1xuICAgICAgICB0aGlzLnVzaG9ydHMgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheSk7XG4gICAgICAgIHRoaXMuc2hvcnRzID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheSk7XG4gICAgfSxcblxuICAgIC8vIGJpbmRzIHRoZSBidWZmZXIgdG8gYSB3ZWJnbCBjb250ZXh0XG4gICAgYmluZDogZnVuY3Rpb24oZ2wpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnbFt0aGlzLmFycmF5VHlwZV07XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEodHlwZSwgbmV3IERhdGFWaWV3KHRoaXMuYXJyYXksIDAsIHRoaXMucG9zKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgICAgICAvLyBkdW1wIGFycmF5IGJ1ZmZlciBvbmNlIGl0J3MgYm91bmQgdG8gZ2xcbiAgICAgICAgICAgIHRoaXMuYXJyYXkgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGluY3JlYXNlIHRoZSBidWZmZXIgc2l6ZSBieSA1MCUgaWYgYSBuZXcgaXRlbSBkb2Vzbid0IGZpdFxuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMucG9zICsgdGhpcy5pdGVtU2l6ZSkge1xuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGggPCB0aGlzLnBvcyArIHRoaXMuaXRlbVNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGVuZ3RoIGJ5IDUwJSBidXQga2VlcCBpdCBldmVuXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBNYXRoLnJvdW5kKHRoaXMubGVuZ3RoICogMS41IC8gMikgKiAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhcnJheSBidWZmZXJzIGNhbid0IGJlIHJlc2l6ZWQsIHNvIHdlIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIHJlc2V0IGFsbCBieXRlcyB0aGVyZVxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHZhciB1Ynl0ZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5KTtcbiAgICAgICAgICAgIHVieXRlcy5zZXQodGhpcy51Ynl0ZXMpO1xuXG4gICAgICAgICAgICB0aGlzLnNldHVwVmlld3MoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBMaW5lVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi9saW5ldmVydGV4YnVmZmVyLmpzJyk7XG52YXIgTGluZUVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL2xpbmVlbGVtZW50YnVmZmVyLmpzJyk7XG52YXIgRmlsbFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4vZmlsbHZlcnRleGJ1ZmZlci5qcycpO1xudmFyIEZpbGxFbGVtZW50QnVmZmVyID0gcmVxdWlyZSgnLi9maWxsZWxlbWVudHNidWZmZXIuanMnKTtcbnZhciBPdXRsaW5lRWxlbWVudEJ1ZmZlciA9IHJlcXVpcmUoJy4vb3V0bGluZWVsZW1lbnRzYnVmZmVyLmpzJyk7XG52YXIgR2x5cGhWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuL2dseXBodmVydGV4YnVmZmVyLmpzJyk7XG52YXIgSWNvblZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4vaWNvbnZlcnRleGJ1ZmZlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ1ZmZlcnNldCkge1xuICAgIGJ1ZmZlcnNldCA9IGJ1ZmZlcnNldCB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnbHlwaFZlcnRleDogbmV3IEdseXBoVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5nbHlwaFZlcnRleCksXG4gICAgICAgIGljb25WZXJ0ZXg6IG5ldyBJY29uVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5pY29uVmVydGV4KSxcbiAgICAgICAgZmlsbFZlcnRleDogbmV3IEZpbGxWZXJ0ZXhCdWZmZXIoYnVmZmVyc2V0LmZpbGxWZXJ0ZXgpLFxuICAgICAgICBmaWxsRWxlbWVudDogbmV3IEZpbGxFbGVtZW50QnVmZmVyKGJ1ZmZlcnNldC5maWxsRWxlbWVudCksXG4gICAgICAgIG91dGxpbmVFbGVtZW50OiBuZXcgT3V0bGluZUVsZW1lbnRCdWZmZXIoYnVmZmVyc2V0Lm91dGxpbmVFbGVtZW50KSxcbiAgICAgICAgbGluZVZlcnRleDogbmV3IExpbmVWZXJ0ZXhCdWZmZXIoYnVmZmVyc2V0LmxpbmVWZXJ0ZXgpLFxuICAgICAgICBsaW5lRWxlbWVudDogbmV3IExpbmVFbGVtZW50QnVmZmVyKGJ1ZmZlcnNldC5saW5lRWxlbWVudClcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsbEVsZW1lbnRzQnVmZmVyO1xuXG5mdW5jdGlvbiBGaWxsRWxlbWVudHNCdWZmZXIoYnVmZmVyKSB7XG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcbn1cblxuRmlsbEVsZW1lbnRzQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XG5cbkZpbGxFbGVtZW50c0J1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSA2OyAvLyBieXRlcyBwZXIgdHJpYW5nbGUgKDMgKiB1bnNpZ25lZCBzaG9ydCA9PSA2IGJ5dGVzKVxuRmlsbEVsZW1lbnRzQnVmZmVyLnByb3RvdHlwZS5hcnJheVR5cGUgPSAnRUxFTUVOVF9BUlJBWV9CVUZGRVInO1xuXG5GaWxsRWxlbWVudHNCdWZmZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICB2YXIgcG9zMiA9IHRoaXMucG9zIC8gMjtcblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDBdID0gYTtcbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDFdID0gYjtcbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDJdID0gYztcblxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsVmVydGV4QnVmZmVyO1xuXG5mdW5jdGlvbiBGaWxsVmVydGV4QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbkZpbGxWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcblxuRmlsbFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSA0OyAvLyBieXRlcyBwZXIgdmVydGV4ICgyICogc2hvcnQgPT0gNCBieXRlcylcblxuRmlsbFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAwXSA9IHg7XG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDFdID0geTtcblxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFZlcnRleEJ1ZmZlcjtcblxuZnVuY3Rpb24gR2x5cGhWZXJ0ZXhCdWZmZXIoYnVmZmVyKSB7XG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcbn1cblxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcblxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmRlZmF1bHRMZW5ndGggPSAyMDQ4ICogMTY7XG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSAxNjtcblxuLy8gQ29udmVydHMgdGhlIDAuLjJwaSB0byBhbiBpbnQxNiByYW5nZVxuR2x5cGhWZXJ0ZXhCdWZmZXIuYW5nbGVGYWN0b3IgPSAxMjggLyBNYXRoLlBJO1xuXG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oeCwgeSwgb3gsIG95LCB0eCwgdHksIGFuZ2xlLCBtaW56b29tLCByYW5nZSwgbWF4em9vbSwgbGFiZWxtaW56b29tKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zLFxuICAgICAgICBwb3MyID0gcG9zIC8gMixcbiAgICAgICAgYW5nbGVGYWN0b3IgPSBHbHlwaFZlcnRleEJ1ZmZlci5hbmdsZUZhY3RvcjtcblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICB0aGlzLnNob3J0c1twb3MyICsgMF0gPSB4O1xuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAxXSA9IHk7XG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDJdID0gTWF0aC5yb3VuZChveCAqIDY0KTsgLy8gdXNlIDEvNjQgcGl4ZWxzIGZvciBwbGFjZW1lbnRcbiAgICB0aGlzLnNob3J0c1twb3MyICsgM10gPSBNYXRoLnJvdW5kKG95ICogNjQpO1xuXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgOF0gPSBNYXRoLmZsb29yKChsYWJlbG1pbnpvb20gfHwgMCkgKiAxMCk7XG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgOV0gPSBNYXRoLmZsb29yKChtaW56b29tIHx8IDApICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDEwXSA9IE1hdGguZmxvb3IoTWF0aC5taW4obWF4em9vbSB8fCAyNSwgMjUpICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDExXSA9IE1hdGgucm91bmQoYW5nbGUgKiBhbmdsZUZhY3RvcikgJSAyNTY7XG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTJdID0gTWF0aC5tYXgoTWF0aC5yb3VuZChyYW5nZVswXSAqIGFuZ2xlRmFjdG9yKSwgMCkgJSAyNTY7XG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTNdID0gTWF0aC5taW4oTWF0aC5yb3VuZChyYW5nZVsxXSAqIGFuZ2xlRmFjdG9yKSwgMjU1KSAlIDI1NjtcblxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDE0XSA9IE1hdGguZmxvb3IodHggLyA0KTtcbiAgICB0aGlzLnVieXRlc1twb3MgKyAxNV0gPSBNYXRoLmZsb29yKHR5IC8gNCk7XG5cbiAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xufTtcblxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCwgc2hhZGVyKSB7XG4gICAgQnVmZmVyLnByb3RvdHlwZS5iaW5kLmNhbGwodGhpcywgZ2wpO1xuXG4gICAgdmFyIHN0cmlkZSA9IHRoaXMuaXRlbVNpemU7XG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgICAgMiwgZ2wuU0hPUlQsIGZhbHNlLCBzdHJpZGUsIDApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfb2Zmc2V0LCAyLCBnbC5TSE9SVCwgZmFsc2UsIHN0cmlkZSwgNCk7XG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2xhYmVsbWluem9vbSwgMSwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgOCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9taW56b29tLCAgICAgIDEsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCBzdHJpZGUsIDkpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfbWF4em9vbSwgICAgICAxLCBnbC5VTlNJR05FRF9CWVRFLCBmYWxzZSwgc3RyaWRlLCAxMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9hbmdsZSwgICAgICAgIDEsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCBzdHJpZGUsIDExKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3JhbmdlZW5kLCAgICAgMSwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgMTIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcmFuZ2VzdGFydCwgICAxLCBnbC5VTlNJR05FRF9CWVRFLCBmYWxzZSwgc3RyaWRlLCAxMyk7XG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3RleCwgMiwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgMTQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhWZXJ0ZXhCdWZmZXI7XG5cbmZ1bmN0aW9uIEdseXBoVmVydGV4QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XG5cbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZS5kZWZhdWx0TGVuZ3RoID0gMjA0OCAqIDIwO1xuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLml0ZW1TaXplID0gMjA7XG5cbi8vIENvbnZlcnRzIHRoZSAwLi4ycGkgdG8gYW4gaW50MTYgcmFuZ2VcbkdseXBoVmVydGV4QnVmZmVyLmFuZ2xlRmFjdG9yID0gMTI4IC8gTWF0aC5QSTtcblxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHgsIHksIG94LCBveSwgdHgsIHR5LCBhbmdsZSwgbWluem9vbSwgcmFuZ2UsIG1heHpvb20sIGxhYmVsbWluem9vbSkge1xuICAgIHZhciBwb3MgPSB0aGlzLnBvcyxcbiAgICAgICAgcG9zMiA9IHBvcyAvIDIsXG4gICAgICAgIGFuZ2xlRmFjdG9yID0gR2x5cGhWZXJ0ZXhCdWZmZXIuYW5nbGVGYWN0b3I7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDBdID0geDtcbiAgICB0aGlzLnNob3J0c1twb3MyICsgMV0gPSB5O1xuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAyXSA9IE1hdGgucm91bmQob3ggKiA2NCk7IC8vIHVzZSAxLzY0IHBpeGVscyBmb3IgcGxhY2VtZW50XG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDNdID0gTWF0aC5yb3VuZChveSAqIDY0KTtcblxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDhdID0gTWF0aC5mbG9vcigobGFiZWxtaW56b29tIHx8IDApICogMTApO1xuICAgIHRoaXMudWJ5dGVzW3BvcyArIDldID0gTWF0aC5mbG9vcigobWluem9vbSB8fCAwKSAqIDEwKTsgLy8gMS8xMCB6b29tIGxldmVsczogejE2ID09IDE2MC5cbiAgICB0aGlzLnVieXRlc1twb3MgKyAxMF0gPSBNYXRoLmZsb29yKE1hdGgubWluKG1heHpvb20gfHwgMjUsIDI1KSAqIDEwKTsgLy8gMS8xMCB6b29tIGxldmVsczogejE2ID09IDE2MC5cbiAgICB0aGlzLnVieXRlc1twb3MgKyAxMV0gPSBNYXRoLnJvdW5kKGFuZ2xlICogYW5nbGVGYWN0b3IpICUgMjU2O1xuICAgIHRoaXMudWJ5dGVzW3BvcyArIDEyXSA9IE1hdGgubWF4KE1hdGgucm91bmQocmFuZ2VbMF0gKiBhbmdsZUZhY3RvciksIDApICUgMjU2O1xuICAgIHRoaXMudWJ5dGVzW3BvcyArIDEzXSA9IE1hdGgubWluKE1hdGgucm91bmQocmFuZ2VbMV0gKiBhbmdsZUZhY3RvciksIDI1NSkgJSAyNTY7XG5cbiAgICB0aGlzLnNob3J0c1twb3MyICsgOF0gPSB0eDtcbiAgICB0aGlzLnNob3J0c1twb3MyICsgOV0gPSB0eTtcblxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG59O1xuXG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsLCBzaGFkZXIpIHtcbiAgICBCdWZmZXIucHJvdG90eXBlLmJpbmQuY2FsbCh0aGlzLCBnbCk7XG5cbiAgICB2YXIgc3RyaWRlID0gdGhpcy5pdGVtU2l6ZTtcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCAgICAyLCBnbC5TSE9SVCwgZmFsc2UsIHN0cmlkZSwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9vZmZzZXQsIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCA0KTtcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfbGFiZWxtaW56b29tLCAxLCBnbC5VTlNJR05FRF9CWVRFLCBmYWxzZSwgc3RyaWRlLCA4KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX21pbnpvb20sICAgICAgMSwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgOSk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9tYXh6b29tLCAgICAgIDEsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCBzdHJpZGUsIDEwKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2FuZ2xlLCAgICAgICAgMSwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgMTEpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcmFuZ2VlbmQsICAgICAxLCBnbC5VTlNJR05FRF9CWVRFLCBmYWxzZSwgc3RyaWRlLCAxMik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9yYW5nZXN0YXJ0LCAgIDEsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCBzdHJpZGUsIDEzKTtcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfdGV4LCAyLCBnbC5TSE9SVCwgZmFsc2UsIHN0cmlkZSwgMTYpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZUVsZW1lbnRCdWZmZXI7XG5cbmZ1bmN0aW9uIExpbmVFbGVtZW50QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbkxpbmVFbGVtZW50QnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XG5cbkxpbmVFbGVtZW50QnVmZmVyLnByb3RvdHlwZS5pdGVtU2l6ZSA9IDY7IC8vIGJ5dGVzIHBlciB0cmlhbmdsZSAoMyAqIHVuc2lnbmVkIHNob3J0ID09IDYgYnl0ZXMpXG5MaW5lRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUuYXJyYXlUeXBlID0gJ0VMRU1FTlRfQVJSQVlfQlVGRkVSJztcblxuTGluZUVsZW1lbnRCdWZmZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICB2YXIgcG9zMiA9IHRoaXMucG9zIC8gMjtcblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDBdID0gYTtcbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDFdID0gYjtcbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDJdID0gYztcblxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVmVydGV4QnVmZmVyO1xuXG5mdW5jdGlvbiBMaW5lVmVydGV4QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbi8vIHNjYWxlIHRoZSBleHRydXNpb24gdmVjdG9yIHNvIHRoYXQgdGhlIG5vcm1hbCBsZW5ndGggaXMgdGhpcyB2YWx1ZS5cbi8vIGNvbnRhaW5zIHRoZSBcInRleHR1cmVcIiBub3JtYWxzICgtMS4uMSkuIHRoaXMgaXMgZGlzdGluY3QgZnJvbSB0aGUgZXh0cnVkZVxuLy8gbm9ybWFscyBmb3IgbGluZSBqb2lucywgYmVjYXVzZSB0aGUgeC12YWx1ZSByZW1haW5zIDAgZm9yIHRoZSB0ZXh0dXJlXG4vLyBub3JtYWwgYXJyYXksIHdoaWxlIHRoZSBleHRydWRlIG5vcm1hbCBhY3R1YWxseSBtb3ZlcyB0aGUgdmVydGV4IHRvIGNyZWF0ZVxuLy8gdGhlIGFjdXRlL2JldmVsbGVkIGxpbmUgam9pbi5cbkxpbmVWZXJ0ZXhCdWZmZXIuZXh0cnVkZVNjYWxlID0gNjM7XG5cbkxpbmVWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcblxuTGluZVZlcnRleEJ1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSA4OyAvLyBieXRlcyBwZXIgdmVydGV4ICgyICogc2hvcnQgKyAxICogc2hvcnQgKyAyICogYnl0ZSA9IDggYnl0ZXMpXG5MaW5lVmVydGV4QnVmZmVyLnByb3RvdHlwZS5kZWZhdWx0TGVuZ3RoID0gMzI3Njg7XG5cbi8vIGFkZCBhIHZlcnRleCB0byB0aGlzIGJ1ZmZlcjtcbi8vIHgsIHkgLSB2ZXJ0ZXggcG9zaXRpb25cbi8vIGV4LCBleSAtIGV4dHJ1ZGUgbm9ybWFsXG4vLyB0eCwgdHkgLSB0ZXh0dXJlIG5vcm1hbFxuXG5MaW5lVmVydGV4QnVmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwb2ludCwgZXh0cnVkZSwgdHgsIHR5LCBsaW5lc29mYXIpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5wb3MsXG4gICAgICAgIHBvczIgPSBwb3MgLyAyLFxuICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXgsXG4gICAgICAgIGV4dHJ1ZGVTY2FsZSA9IExpbmVWZXJ0ZXhCdWZmZXIuZXh0cnVkZVNjYWxlO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAwXSA9IChNYXRoLmZsb29yKHBvaW50LngpICogMikgfCB0eDtcbiAgICB0aGlzLnNob3J0c1twb3MyICsgMV0gPSAoTWF0aC5mbG9vcihwb2ludC55KSAqIDIpIHwgdHk7XG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDJdID0gTWF0aC5yb3VuZChsaW5lc29mYXIgfHwgMCk7XG4gICAgdGhpcy5ieXRlc1twb3MgKyA2XSA9IE1hdGgucm91bmQoZXh0cnVkZVNjYWxlICogZXh0cnVkZS54KTtcbiAgICB0aGlzLmJ5dGVzW3BvcyArIDddID0gTWF0aC5yb3VuZChleHRydWRlU2NhbGUgKiBleHRydWRlLnkpO1xuXG4gICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbiAgICByZXR1cm4gaW5kZXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPdXRsaW5lRWxlbWVudHNCdWZmZXI7XG5cbmZ1bmN0aW9uIE91dGxpbmVFbGVtZW50c0J1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5PdXRsaW5lRWxlbWVudHNCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcblxuT3V0bGluZUVsZW1lbnRzQnVmZmVyLnByb3RvdHlwZS5pdGVtU2l6ZSA9IDQ7IC8vIGJ5dGVzIHBlciBsaW5lICgyICogdW5zaWduZWQgc2hvcnQgPT0gNCBieXRlcylcbk91dGxpbmVFbGVtZW50c0J1ZmZlci5wcm90b3R5cGUuYXJyYXlUeXBlID0gJ0VMRU1FTlRfQVJSQVlfQlVGRkVSJztcblxuT3V0bGluZUVsZW1lbnRzQnVmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHBvczIgPSB0aGlzLnBvcyAvIDI7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy51c2hvcnRzW3BvczIgKyAwXSA9IGE7XG4gICAgdGhpcy51c2hvcnRzW3BvczIgKyAxXSA9IGI7XG5cbiAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCdWNrZXQ7XG5cbnZhciBMaW5lQnVja2V0ID0gcmVxdWlyZSgnLi9saW5lYnVja2V0LmpzJyk7XG52YXIgRmlsbEJ1Y2tldCA9IHJlcXVpcmUoJy4vZmlsbGJ1Y2tldC5qcycpO1xudmFyIFN5bWJvbEJ1Y2tldCA9IHJlcXVpcmUoJy4vc3ltYm9sYnVja2V0LmpzJyk7XG52YXIgUmFzdGVyQnVja2V0ID0gcmVxdWlyZSgnLi9yYXN0ZXJidWNrZXQuanMnKTtcbnZhciBSZW5kZXJQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vc3R5bGUvcmVuZGVycHJvcGVydGllcy5qcycpO1xuXG5mdW5jdGlvbiBjcmVhdGVCdWNrZXQobGF5ZXIsIGJ1ZmZlcnMsIGNvbGxpc2lvbiwgaW5kaWNlcykge1xuXG4gICAgaWYgKCFSZW5kZXJQcm9wZXJ0aWVzW2xheWVyLnR5cGVdKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCd1bmtub3duIGJ1Y2tldCB0eXBlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IG5ldyBSZW5kZXJQcm9wZXJ0aWVzW2xheWVyLnR5cGVdKGxheWVyLnJlbmRlcik7XG5cbiAgICB2YXIgQnVja2V0Q2xhc3MgPVxuICAgICAgICBsYXllci50eXBlID09PSAnbGluZScgPyBMaW5lQnVja2V0IDpcbiAgICAgICAgbGF5ZXIudHlwZSA9PT0gJ2ZpbGwnID8gRmlsbEJ1Y2tldCA6XG4gICAgICAgIGxheWVyLnR5cGUgPT09ICdzeW1ib2wnID8gU3ltYm9sQnVja2V0IDpcbiAgICAgICAgbGF5ZXIudHlwZSA9PT0gJ3Jhc3RlcicgPyBSYXN0ZXJCdWNrZXQgOiBudWxsO1xuXG4gICAgdmFyIGJ1Y2tldCA9IG5ldyBCdWNrZXRDbGFzcyhpbmZvLCBidWZmZXJzLCBjb2xsaXNpb24sIGluZGljZXMpO1xuICAgIGJ1Y2tldC50eXBlID0gbGF5ZXIudHlwZTtcbiAgICBidWNrZXQuaW50ZXJhY3RpdmUgPSBsYXllci5pbnRlcmFjdGl2ZTtcbiAgICBidWNrZXQubWluWm9vbSA9IGxheWVyWydtaW4tem9vbSddO1xuICAgIGJ1Y2tldC5tYXhab29tID0gbGF5ZXJbJ21heC16b29tJ107XG5cbiAgICByZXR1cm4gYnVja2V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnRHcm91cHM7XG5cbmZ1bmN0aW9uIEVsZW1lbnRHcm91cHModmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyLCBzZWNvbmRFbGVtZW50QnVmZmVyKSB7XG5cbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IHZlcnRleEJ1ZmZlcjtcbiAgICB0aGlzLmVsZW1lbnRCdWZmZXIgPSBlbGVtZW50QnVmZmVyO1xuICAgIHRoaXMuc2Vjb25kRWxlbWVudEJ1ZmZlciA9IHNlY29uZEVsZW1lbnRCdWZmZXI7XG4gICAgdGhpcy5ncm91cHMgPSBbXTtcbn1cblxuRWxlbWVudEdyb3Vwcy5wcm90b3R5cGUubWFrZVJvb21Gb3IgPSBmdW5jdGlvbihudW1WZXJ0aWNlcykge1xuICAgIGlmICghdGhpcy5jdXJyZW50IHx8IHRoaXMuY3VycmVudC52ZXJ0ZXhMZW5ndGggKyBudW1WZXJ0aWNlcyA+IDY1NTM1KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBFbGVtZW50R3JvdXAodGhpcy52ZXJ0ZXhCdWZmZXIuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50QnVmZmVyICYmIHRoaXMuZWxlbWVudEJ1ZmZlci5pbmRleCxcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZEVsZW1lbnRCdWZmZXIgJiYgdGhpcy5zZWNvbmRFbGVtZW50QnVmZmVyLmluZGV4KTtcbiAgICAgICAgdGhpcy5ncm91cHMucHVzaCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEVsZW1lbnRHcm91cCh2ZXJ0ZXhTdGFydEluZGV4LCBlbGVtZW50U3RhcnRJbmRleCwgc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXgpICB7XG4gICAgLy8gdGhlIG9mZnNldCBpbnRvIHRoZSB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBmaXJzdCB2ZXJ0ZXggaW4gdGhpcyBncm91cFxuICAgIHRoaXMudmVydGV4U3RhcnRJbmRleCA9IHZlcnRleFN0YXJ0SW5kZXg7XG4gICAgdGhpcy5lbGVtZW50U3RhcnRJbmRleCA9IGVsZW1lbnRTdGFydEluZGV4O1xuICAgIHRoaXMuc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXggPSBzZWNvbmRFbGVtZW50U3RhcnRJbmRleDtcbiAgICB0aGlzLmVsZW1lbnRMZW5ndGggPSAwO1xuICAgIHRoaXMudmVydGV4TGVuZ3RoID0gMDtcbiAgICB0aGlzLnNlY29uZEVsZW1lbnRMZW5ndGggPSAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWF0dXJlVHJlZTtcblxuZnVuY3Rpb24gRmVhdHVyZVRyZWUoZ2V0R2VvbWV0cnksIGdldFR5cGUpIHtcblxuICAgIHRoaXMuZ2V0R2VvbWV0cnkgPSBnZXRHZW9tZXRyeTtcbiAgICB0aGlzLmdldFR5cGUgPSBnZXRUeXBlO1xuXG4gICAgdGhpcy5ydHJlZSA9IHJidXNoKDkpO1xuICAgIHRoaXMudG9CZUluc2VydGVkID0gW107XG59XG5cbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihiYm94LCBidWNrZXRfbmFtZSwgZmVhdHVyZSkge1xuICAgIGJib3guYnVja2V0ID0gYnVja2V0X25hbWU7XG4gICAgYmJveC5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICB0aGlzLnRvQmVJbnNlcnRlZC5wdXNoKGJib3gpO1xufTtcblxuLy8gYnVsayBpbnNlcnQgaW50byB0cmVlXG5GZWF0dXJlVHJlZS5wcm90b3R5cGUuX2xvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJ0cmVlLmxvYWQodGhpcy50b0JlSW5zZXJ0ZWQpO1xuICAgIHRoaXMudG9CZUluc2VydGVkID0gW107XG59O1xuXG4vLyBGaW5kcyBmZWF0dXJlcyBpbiB0aGlzIHRpbGUgYXQgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uLlxuRmVhdHVyZVRyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24oYXJncywgY2FsbGJhY2spIHtcblxuICAgIGlmICh0aGlzLnRvQmVJbnNlcnRlZC5sZW5ndGgpIHRoaXMuX2xvYWQoKTtcblxuICAgIHZhciByYWRpdXMgPSBhcmdzLnBhcmFtcyAmJiBhcmdzLnBhcmFtcy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgKj0gNDA5NiAvIGFyZ3Muc2NhbGU7XG5cbiAgICB2YXIgeCA9IGFyZ3MueCxcbiAgICAgICAgeSA9IGFyZ3MueTtcblxuICAgIHZhciBtYXRjaGluZyA9IHRoaXMucnRyZWUuc2VhcmNoKFsgeCAtIHJhZGl1cywgeSAtIHJhZGl1cywgeCArIHJhZGl1cywgeSArIHJhZGl1cyBdKTtcblxuICAgIGlmIChhcmdzLnBhcmFtcy5idWNrZXRzKSB7XG4gICAgICAgIHRoaXMucXVlcnlCdWNrZXRzKG1hdGNoaW5nLCB4LCB5LCByYWRpdXMsIGFyZ3MucGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWVyeUZlYXR1cmVzKG1hdGNoaW5nLCB4LCB5LCByYWRpdXMsIGFyZ3MucGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfVxufTtcblxuRmVhdHVyZVRyZWUucHJvdG90eXBlLnF1ZXJ5RmVhdHVyZXMgPSBmdW5jdGlvbihtYXRjaGluZywgeCwgeSwgcmFkaXVzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBtYXRjaGluZ1tpXS5mZWF0dXJlO1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0VHlwZShmZWF0dXJlKTtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeShmZWF0dXJlKTtcblxuXG4gICAgICAgIGlmIChwYXJhbXMuYnVja2V0ICYmIG1hdGNoaW5nW2ldLmJ1Y2tldCAhPT0gcGFyYW1zLmJ1Y2tldCkgY29udGludWU7XG4gICAgICAgIGlmIChwYXJhbXMudHlwZSAmJiB0eXBlICE9PSBwYXJhbXMudHlwZSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKGdlb21ldHJ5Q29udGFpbnNQb2ludChnZW9tZXRyeSwgdHlwZSwgbmV3IFBvaW50KHgsIHkpLCByYWRpdXMpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgX2J1Y2tldDogbWF0Y2hpbmdbaV0uYnVja2V0LFxuICAgICAgICAgICAgICAgIF90eXBlOiB0eXBlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXlbMF0gIT09ICdfJykge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gZmVhdHVyZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG59O1xuXG4vLyBMaXN0cyBhbGwgYnVja2V0cyB0aGF0IGF0IHRoZSBwb3NpdGlvbi5cbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5xdWVyeUJ1Y2tldHMgPSBmdW5jdGlvbihtYXRjaGluZywgeCwgeSwgcmFkaXVzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGJ1Y2tldHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChidWNrZXRzLmluZGV4T2YobWF0Y2hpbmdbaV0uYnVja2V0KSA+PSAwKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgZmVhdHVyZSA9IG1hdGNoaW5nW2ldLmZlYXR1cmU7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5nZXRUeXBlKGZlYXR1cmUpO1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KGZlYXR1cmUpO1xuICAgICAgICBpZiAoZ2VvbWV0cnlDb250YWluc1BvaW50KGdlb21ldHJ5LCB0eXBlLCBuZXcgUG9pbnQoeCwgeSksIHJhZGl1cykpIHtcbiAgICAgICAgICAgIGJ1Y2tldHMucHVzaChtYXRjaGluZ1tpXS5idWNrZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgYnVja2V0cyk7XG59O1xuXG5cbmZ1bmN0aW9uIGdlb21ldHJ5Q29udGFpbnNQb2ludChyaW5ncywgdHlwZSwgcCwgcmFkaXVzKSB7XG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50Q29udGFpbnNQb2ludChyaW5ncywgcCwgcmFkaXVzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbGluZUNvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgcmV0dXJuIHBvbHlDb250YWluc1BvaW50KHJpbmdzLCBwKSA/IHRydWUgOiBsaW5lQ29udGFpbnNQb2ludChyaW5ncywgcCwgcmFkaXVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTUwMTcyNS8zMzEzNzkuXG5mdW5jdGlvbiBkaXN0VG9TZWdtZW50U3F1YXJlZChwLCB2LCB3KSB7XG4gICAgdmFyIGwyID0gdi5kaXN0U3FyKHcpO1xuICAgIGlmIChsMiA9PT0gMCkgcmV0dXJuIHAuZGlzdFNxcih2KTtcbiAgICB2YXIgdCA9ICgocC54IC0gdi54KSAqICh3LnggLSB2LngpICsgKHAueSAtIHYueSkgKiAody55IC0gdi55KSkgLyBsMjtcbiAgICBpZiAodCA8IDApIHJldHVybiBwLmRpc3RTcXIodik7XG4gICAgaWYgKHQgPiAxKSByZXR1cm4gcC5kaXN0U3FyKHcpO1xuICAgIHJldHVybiBwLmRpc3RTcXIody5zdWIodikuX211bHQodCkuX2FkZCh2KSk7XG59XG5cbmZ1bmN0aW9uIGxpbmVDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIHtcbiAgICB2YXIgciA9IHJhZGl1cyAqIHJhZGl1cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGxpbmUgc2VnbWVudHMgdGhhdCBoYXZlIGEgZGlzdGFuY2UgPD0gcmFkaXVzXjIgdG8gcFxuICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSB0cmVhdCB0aGUgbGluZSBhcyBcImNvbnRhaW5pbmcgcG9pbnQgcFwiLlxuICAgICAgICAgICAgdmFyIHYgPSByaW5nW2otMV0sIHcgPSByaW5nW2pdO1xuICAgICAgICAgICAgaWYgKGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIDwgcikgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBwb2ludCBpbiBwb2x5Z29uIHJheSBjYXN0aW5nIGFsZ29yaXRobVxuZnVuY3Rpb24gcG9seUNvbnRhaW5zUG9pbnQocmluZ3MsIHApIHtcbiAgICB2YXIgYyA9IGZhbHNlLFxuICAgICAgICByaW5nLCBwMSwgcDI7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHJpbmdzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHJpbmcgPSByaW5nc1trXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSByaW5nLmxlbmd0aCAtIDE7IGkgPCByaW5nLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICAgICAgcDEgPSByaW5nW2ldO1xuICAgICAgICAgICAgcDIgPSByaW5nW2pdO1xuICAgICAgICAgICAgaWYgKCgocDEueSA+IHAueSkgIT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuICAgICAgICAgICAgICAgIGMgPSAhYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gcG9pbnRDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIHtcbiAgICB2YXIgciA9IHJhZGl1cyAqIHJhZGl1cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocmluZ1tqXS5kaXN0U3FyKHApIDw9IHIpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50Z3JvdXBzLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsbEJ1Y2tldDtcblxuZnVuY3Rpb24gRmlsbEJ1Y2tldChpbmZvLCBidWZmZXJzLCBwbGFjZW1lbnQsIGVsZW1lbnRHcm91cHMpIHtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XG4gICAgdGhpcy5lbGVtZW50R3JvdXBzID0gZWxlbWVudEdyb3VwcyB8fCBuZXcgRWxlbWVudEdyb3VwcyhidWZmZXJzLmZpbGxWZXJ0ZXgsIGJ1ZmZlcnMuZmlsbEVsZW1lbnQsIGJ1ZmZlcnMub3V0bGluZUVsZW1lbnQpO1xufVxuXG5GaWxsQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZmVhdHVyZS5sb2FkR2VvbWV0cnkoKSk7XG4gICAgfVxufTtcblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEZpbGwobGluZXNbaV0pO1xuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZpbGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGZpbGwgbXVzdCBoYXZlIGF0IGxlYXN0IHRocmVlIHZlcnRpY2VzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlcyB3ZSdyZSBnb2luZyB0byBwcm9kdWNlIHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcmVzaXplIHRoZSBidWZmZXIgYmVmb3JlaGFuZCwgb3IgZGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbGluZVxuICAgIC8vIHdvbid0IGZpdCBpbnRvIHRoZSBidWZmZXIgYW55bW9yZS5cbiAgICAvLyBJbiBvcmRlciB0byBiZSBhYmxlIHRvIHVzZSB0aGUgdmVydGV4IGJ1ZmZlciBmb3IgZHJhd2luZyB0aGUgYW50aWFsaWFzZWRcbiAgICAvLyBvdXRsaW5lcywgd2Ugc2VwYXJhdGUgYWxsIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGRlZ2VuZXJhdGUgKG91dC1vZi1cbiAgICAvLyB2aWV3cGxhbmUpIHZlcnRleC5cblxuICAgIHZhciBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgZ2VvbWV0cnkgYnVmZmVyIGNhbiBob2xkIGFsbCB0aGUgcmVxdWlyZWQgdmVydGljZXMuXG4gICAgdGhpcy5lbGVtZW50R3JvdXBzLm1ha2VSb29tRm9yKGxlbiArIDEpO1xuICAgIHZhciBlbGVtZW50R3JvdXAgPSB0aGlzLmVsZW1lbnRHcm91cHMuY3VycmVudDtcblxuICAgIHZhciBmaWxsVmVydGV4ID0gdGhpcy5idWZmZXJzLmZpbGxWZXJ0ZXg7XG4gICAgdmFyIGZpbGxFbGVtZW50ID0gdGhpcy5idWZmZXJzLmZpbGxFbGVtZW50O1xuICAgIHZhciBvdXRsaW5lRWxlbWVudCA9IHRoaXMuYnVmZmVycy5vdXRsaW5lRWxlbWVudDtcblxuICAgIC8vIFN0YXJ0IGFsbCBsaW5lcyB3aXRoIGEgZGVnZW5lcmF0ZSB2ZXJ0ZXhcbiAgICBlbGVtZW50R3JvdXAudmVydGV4TGVuZ3RoKys7XG5cbiAgICAvLyBXZSdyZSBnZW5lcmF0aW5nIHRyaWFuZ2xlIGZhbnMsIHNvIHdlIGFsd2F5cyBzdGFydCB3aXRoIHRoZSBmaXJzdCBjb29yZGluYXRlIGluIHRoaXMgcG9seWdvbi5cbiAgICB2YXIgZmlyc3RJbmRleCA9IGZpbGxWZXJ0ZXguaW5kZXggLSBlbGVtZW50R3JvdXAudmVydGV4U3RhcnRJbmRleCxcbiAgICAgICAgcHJldkluZGV4LCBjdXJyZW50SW5kZXgsIGN1cnJlbnRWZXJ0ZXg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGZpbGxWZXJ0ZXguaW5kZXggLSBlbGVtZW50R3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgIGZpbGxWZXJ0ZXguYWRkKGN1cnJlbnRWZXJ0ZXgueCwgY3VycmVudFZlcnRleC55KTtcbiAgICAgICAgZWxlbWVudEdyb3VwLnZlcnRleExlbmd0aCsrO1xuXG4gICAgICAgIC8vIE9ubHkgYWRkIHRyaWFuZ2xlcyB0aGF0IGhhdmUgZGlzdGluY3QgdmVydGljZXMuXG4gICAgICAgIGlmIChpID49IDIgJiYgKGN1cnJlbnRWZXJ0ZXgueCAhPT0gdmVydGljZXNbMF0ueCB8fCBjdXJyZW50VmVydGV4LnkgIT09IHZlcnRpY2VzWzBdLnkpKSB7XG4gICAgICAgICAgICBmaWxsRWxlbWVudC5hZGQoZmlyc3RJbmRleCwgcHJldkluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID49IDEpIHtcbiAgICAgICAgICAgIG91dGxpbmVFbGVtZW50LmFkZChwcmV2SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXAuc2Vjb25kRWxlbWVudExlbmd0aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkluZGV4ID0gY3VycmVudEluZGV4O1xuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmhhc0RhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLmVsZW1lbnRHcm91cHMuY3VycmVudDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50Z3JvdXBzLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZUJ1Y2tldDtcblxuZnVuY3Rpb24gTGluZUJ1Y2tldChpbmZvLCBidWZmZXJzLCBwbGFjZW1lbnQsIGVsZW1lbnRHcm91cHMpIHtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XG4gICAgdGhpcy5lbGVtZW50R3JvdXBzID0gZWxlbWVudEdyb3VwcyB8fCBuZXcgRWxlbWVudEdyb3VwcyhidWZmZXJzLmxpbmVWZXJ0ZXgsIGJ1ZmZlcnMubGluZUVsZW1lbnQpO1xufVxuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZmVhdHVyZS5sb2FkR2VvbWV0cnkoKSk7XG4gICAgfVxufTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLmluZm87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZExpbmUobGluZXNbaV0sIGluZm9bJ2xpbmUtam9pbiddLCBpbmZvWydsaW5lLWNhcCddLFxuICAgICAgICAgICAgICAgIGluZm9bJ2xpbmUtbWl0ZXItbGltaXQnXSwgaW5mb1snbGluZS1yb3VuZC1saW1pdCddKTtcbiAgICB9XG59O1xuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24odmVydGljZXMsIGpvaW4sIGNhcCwgbWl0ZXJMaW1pdCwgcm91bmRMaW1pdCkge1xuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGxpbmUgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byB2ZXJ0aWNlcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGpvaW4gPT09ICdiZXZlbCcpIG1pdGVyTGltaXQgPSAxLjA1O1xuXG4gICAgdmFyIGxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgZmlyc3RWZXJ0ZXggPSB2ZXJ0aWNlc1swXSxcbiAgICAgICAgbGFzdFZlcnRleCA9IHZlcnRpY2VzW2xlbiAtIDFdLFxuICAgICAgICBjbG9zZWQgPSBmaXJzdFZlcnRleC5lcXVhbHMobGFzdFZlcnRleCk7XG5cbiAgICB2YXIgbGluZVZlcnRleCA9IHRoaXMuYnVmZmVycy5saW5lVmVydGV4O1xuICAgIHZhciBsaW5lRWxlbWVudCA9IHRoaXMuYnVmZmVycy5saW5lRWxlbWVudDtcblxuICAgIC8vIHdlIGNvdWxkIGJlIG1vcmUgcHJlY2llcywgYnV0IGl0IHdvdWxkIG9ubHkgc2F2ZSBhIG5lZ2xpZ2libGUgYW1vdW50IG9mIHNwYWNlXG4gICAgdGhpcy5lbGVtZW50R3JvdXBzLm1ha2VSb29tRm9yKGxlbiAqIDQpO1xuICAgIHZhciBlbGVtZW50R3JvdXAgPSB0aGlzLmVsZW1lbnRHcm91cHMuY3VycmVudDtcbiAgICB2YXIgdmVydGV4U3RhcnRJbmRleCA9IGVsZW1lbnRHcm91cC52ZXJ0ZXhTdGFydEluZGV4O1xuXG4gICAgaWYgKGxlbiA9PSAyICYmIGNsb3NlZCkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ2EgbGluZSBtYXkgbm90IGhhdmUgY29pbmNpZGVudCBwb2ludHMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiZWdpbkNhcCA9IGNhcCxcbiAgICAgICAgZW5kQ2FwID0gY2xvc2VkID8gJ2J1dHQnIDogY2FwLFxuICAgICAgICBmbGlwID0gMSxcbiAgICAgICAgZGlzdGFuY2UgPSAwLFxuICAgICAgICBjdXJyZW50VmVydGV4LCBwcmV2VmVydGV4LCAgbmV4dFZlcnRleCwgcHJldk5vcm1hbCwgIG5leHROb3JtYWw7XG5cbiAgICAvLyB0aGUgbGFzdCB0aHJlZSB2ZXJ0aWNlcyBhZGRlZFxuICAgIHZhciBlMSwgZTIsIGUzO1xuXG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbbGVuIC0gMl07XG4gICAgICAgIG5leHROb3JtYWwgPSBmaXJzdFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICBuZXh0VmVydGV4ID0gY2xvc2VkICYmIGkgPT09IGxlbiAtIDEgP1xuICAgICAgICAgICAgdmVydGljZXNbMV0gOiAvLyBpZiB0aGUgbGluZSBpcyBjbG9zZWQsIHdlIHRyZWF0IHRoZSBsYXN0IHZlcnRleCBsaWtlIHRoZSBmaXJzdFxuICAgICAgICAgICAgdmVydGljZXNbaSArIDFdOyAvLyBqdXN0IHRoZSBuZXh0IHZlcnRleFxuXG4gICAgICAgIC8vIGlmIHR3byBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBleGlzdCwgc2tpcCB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgaWYgKG5leHRWZXJ0ZXggJiYgdmVydGljZXNbaV0uZXF1YWxzKG5leHRWZXJ0ZXgpKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobmV4dE5vcm1hbCkgcHJldk5vcm1hbCA9IG5leHROb3JtYWw7XG4gICAgICAgIGlmIChjdXJyZW50VmVydGV4KSBwcmV2VmVydGV4ID0gY3VycmVudFZlcnRleDtcblxuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgYWxvbmcgdGhlIGxpbmUgdGhlIGN1cnJlbnRWZXJ0ZXggaXNcbiAgICAgICAgaWYgKHByZXZWZXJ0ZXgpIGRpc3RhbmNlICs9IGN1cnJlbnRWZXJ0ZXguZGlzdChwcmV2VmVydGV4KTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5vcm1hbCB0b3dhcmRzIHRoZSBuZXh0IHZlcnRleCBpbiB0aGlzIGxpbmUuIEluIGNhc2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmV4dCB2ZXJ0ZXgsIHByZXRlbmQgdGhhdCB0aGUgbGluZSBpcyBjb250aW51aW5nIHN0cmFpZ2h0LFxuICAgICAgICAvLyBtZWFuaW5nIHRoYXQgd2UgYXJlIGp1c3QgdXNpbmcgdGhlIHByZXZpb3VzIG5vcm1hbC5cbiAgICAgICAgbmV4dE5vcm1hbCA9IG5leHRWZXJ0ZXggPyBuZXh0VmVydGV4LnN1YihjdXJyZW50VmVydGV4KS5fdW5pdCgpLl9wZXJwKCkgOiBwcmV2Tm9ybWFsO1xuXG4gICAgICAgIC8vIElmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBwcmV2aW91cyBub3JtYWwsIHRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiBhXG4gICAgICAgIC8vIG5vbi1jbG9zZWQgbGluZSwgc28gd2UncmUgZG9pbmcgYSBzdHJhaWdodCBcImpvaW5cIi5cbiAgICAgICAgcHJldk5vcm1hbCA9IHByZXZOb3JtYWwgfHwgbmV4dE5vcm1hbDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG5vcm1hbCBvZiB0aGUgam9pbiBleHRydXNpb24uIEl0IGlzIHRoZSBhbmdsZSBiaXNlY3RvclxuICAgICAgICAvLyBvZiB0aGUgc2VnbWVudHMgYmV0d2VlbiB0aGUgcHJldmlvdXMgbGluZSBhbmQgdGhlIG5leHQgbGluZS5cbiAgICAgICAgdmFyIGpvaW5Ob3JtYWwgPSBwcmV2Tm9ybWFsLmFkZChuZXh0Tm9ybWFsKS5fdW5pdCgpO1xuXG4gICAgICAgIC8qICBqb2luTm9ybWFsICAgICBwcmV2Tm9ybWFsXG4gICAgICAgICAqICAgICAgICAgICAgIOKGliAgICAgIOKGkVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAuX19fX19fX18uIHByZXZWZXJ0ZXhcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiBuZXh0Tm9ybWFsICDihpAgIHwgIGN1cnJlbnRWZXJ0ZXhcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgbmV4dFZlcnRleCAhXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBtaXRlciAodGhlIHJhdGlvIG9mIHRoZSBtaXRlciB0byB0aGUgd2lkdGgpLlxuICAgICAgICAvLyBGaW5kIHRoZSBjb3NpbmUgb2YgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIG5leHQgYW5kIGpvaW4gbm9ybWFsc1xuICAgICAgICAvLyB1c2luZyBkb3QgcHJvZHVjdC4gVGhlIGludmVyc2Ugb2YgdGhhdCBpcyB0aGUgbWl0ZXIgbGVuZ3RoLlxuICAgICAgICB2YXIgY29zSGFsZkFuZ2xlID0gam9pbk5vcm1hbC54ICogbmV4dE5vcm1hbC54ICsgam9pbk5vcm1hbC55ICogbmV4dE5vcm1hbC55O1xuICAgICAgICB2YXIgbWl0ZXJMZW5ndGggPSAxIC8gY29zSGFsZkFuZ2xlO1xuXG4gICAgICAgIC8vIFdoZXRoZXIgYW55IHZlcnRpY2VzIGhhdmUgYmVlblxuICAgICAgICB2YXIgc3RhcnRPZkxpbmUgPSBlMSA9PT0gdW5kZWZpbmVkIHx8IGUyID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gVGhlIGpvaW4gaWYgYSBtaWRkbGUgdmVydGV4LCBvdGhlcndpc2UgdGhlIGNhcC5cbiAgICAgICAgdmFyIG1pZGRsZVZlcnRleCA9IHByZXZWZXJ0ZXggJiYgbmV4dFZlcnRleDtcbiAgICAgICAgdmFyIGN1cnJlbnRKb2luID0gbWlkZGxlVmVydGV4ID8gam9pbiA6IG5leHRWZXJ0ZXggPyBiZWdpbkNhcCA6IGVuZENhcDtcblxuICAgICAgICBpZiAobWlkZGxlVmVydGV4ICYmIGN1cnJlbnRKb2luID09PSAncm91bmQnICYmIG1pdGVyTGVuZ3RoIDwgcm91bmRMaW1pdCkge1xuICAgICAgICAgICAgY3VycmVudEpvaW4gPSAnbWl0ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnbWl0ZXInICYmIG1pdGVyTGVuZ3RoID4gbWl0ZXJMaW1pdCkge1xuICAgICAgICAgICAgY3VycmVudEpvaW4gPSAnYmV2ZWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnYmV2ZWwnKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBleHRydWRlIGxlbmd0aCBpcyA2MyAvIDI1NiA9IDQgdGltZXMgdGhlIHdpZHRoIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICAvLyBzbyBpZiBtaXRlckxlbmd0aCA+PSA0IHdlIG5lZWQgdG8gZHJhdyBhIGRpZmZlcmVudCB0eXBlIG9mIGJldmVsIHdoZXJlLlxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gNCkgY3VycmVudEpvaW4gPSAnZmxpcGJldmVsJztcblxuICAgICAgICAgICAgLy8gSWYgdGhlIG1pdGVyTGVuZ3RoIGlzIHJlYWxseSBzbWFsbCBhbmQgdGhlIGxpbmUgYmV2ZWwgd291bGRuJ3QgYmUgdmlzaWJsZSxcbiAgICAgICAgICAgIC8vIGp1c3QgZHJhdyBhIG1pdGVyIGpvaW4gdG8gc2F2ZSBhIHRyaWFuZ2xlLlxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoIDwgbWl0ZXJMaW1pdCkgY3VycmVudEpvaW4gPSAnbWl0ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWl0ZXJlZCBqb2luc1xuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdtaXRlcicpIHtcbiAgICAgICAgICAgIC8vIHNjYWxlIHRoZSB1bml0IHZlY3RvciBieSB0aGUgbWl0ZXIgbGVuZ3RoXG4gICAgICAgICAgICBqb2luTm9ybWFsLl9tdWx0KG1pdGVyTGVuZ3RoKTtcbiAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgoam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdmbGlwYmV2ZWwnKSB7XG4gICAgICAgICAgICAvLyBtaXRlciBpcyB0b28gYmlnLCBmbGlwIHRoZSBkaXJlY3Rpb24gdG8gbWFrZSBhIGJldmVsZWQgam9pblxuXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAvLyBBbG1vc3QgcGFyYWxsZWwgbGluZXNcbiAgICAgICAgICAgICAgICBmbGlwID0gLWZsaXA7XG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbCA9IG5leHROb3JtYWw7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGJldmVsTGVuZ3RoID0gbWl0ZXJMZW5ndGggKiBwcmV2Tm9ybWFsLmFkZChuZXh0Tm9ybWFsKS5tYWcoKSAvIHByZXZOb3JtYWwuc3ViKG5leHROb3JtYWwpLm1hZygpO1xuICAgICAgICAgICAgICAgIGpvaW5Ob3JtYWwuX3BlcnAoKS5fbXVsdChmbGlwICogYmV2ZWxMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZsaXAgPSAtZmxpcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgoam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgIC8vIEFsbCBvdGhlciB0eXBlcyBvZiBqb2luc1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0QSwgb2Zmc2V0QjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2JldmVsJykge1xuICAgICAgICAgICAgICAgIHZhciBkaXIgPSBwcmV2Tm9ybWFsLnggKiBuZXh0Tm9ybWFsLnkgLSBwcmV2Tm9ybWFsLnkgKiBuZXh0Tm9ybWFsLng7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IC1NYXRoLnNxcnQobWl0ZXJMZW5ndGggKiBtaXRlckxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChmbGlwICogZGlyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRCID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRBID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QiA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnc3F1YXJlJykge1xuICAgICAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXRCID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QSA9IG9mZnNldEIgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYSBidXR0IG9yIGEgc3F1YXJlIGNhcCBvciBiZXZlbFxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgocHJldk5vcm1hbCwgb2Zmc2V0QSwgb2Zmc2V0QiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgcm91bmQgY2FwIG9yIGxpbmVqb2luIGF0IGVuZCBvZiBzZWdtZW50XG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZMaW5lICYmIGN1cnJlbnRKb2luID09PSAncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgYWRkQ3VycmVudFZlcnRleChwcmV2Tm9ybWFsLCAxLCAxLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2VnbWVudCBpbmNsdWRlIGNhcCBhcmUgZG9uZSwgdW5zZXQgdmVydGljZXMgdG8gZGlzY29ubmVjdCBzZWdtZW50cy5cbiAgICAgICAgICAgIC8vIE9yIGxlYXZlIHRoZW0gdG8gY3JlYXRlIGEgYmV2ZWwuXG4gICAgICAgICAgICBpZiAoc3RhcnRPZkxpbmUgfHwgY3VycmVudEpvaW4gIT09ICdiZXZlbCcpIHtcbiAgICAgICAgICAgICAgICBlMSA9IGUyID0gLTE7XG4gICAgICAgICAgICAgICAgZmxpcCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCByb3VuZCBjYXAgYmVmb3JlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChzdGFydE9mTGluZSAmJiBiZWdpbkNhcCA9PT0gJ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgobmV4dE5vcm1hbCwgLTEsIC0xLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50IHdpdGggYSBidXR0IG9yIHNxdWFyZSBjYXAgb3IgYmV2ZWxcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgYWRkQ3VycmVudFZlcnRleChuZXh0Tm9ybWFsLCAtb2Zmc2V0QSwgLW9mZnNldEIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqIEFkZHMgdHdvIHZlcnRpY2VzIHRvIHRoZSBidWZmZXIgdGhhdCBhcmVcbiAgICAgKiBub3JtYWwgYW5kIC1ub3JtYWwgZnJvbSB0aGUgY3VycmVudFZlcnRleC5cbiAgICAgKlxuICAgICAqIGVuZEJveCBtb3ZlcyB0aGUgZXh0cnVkZSBvbmUgdW5pdCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXG4gICAgICogdG8gY3JlYXRlIHNxdWFyZSBvciByb3VuZCBjYXAuXG4gICAgICpcbiAgICAgKiBlbmRMZWZ0IGFuZCBlbmRSaWdodCBzaGlmdHMgdGhlIGV4dHJ1ZGUgYWxvbmcgdGhlIGxpbmVcbiAgICAgKiBlbmRMZWZ0ID09PSAxIG1vdmVzIHRoZSBleHRydWRlIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpbmVcbiAgICAgKiBlbmRMZWZ0ID09PSAtMSBtb3ZlcyB0aGUgZXh0cnVkZSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRDdXJyZW50VmVydGV4KG5vcm1hbCwgZW5kTGVmdCwgZW5kUmlnaHQsIHJvdW5kKSB7XG5cbiAgICAgICAgdmFyIHR4ID0gcm91bmQgPyAxIDogMDtcbiAgICAgICAgdmFyIGV4dHJ1ZGU7XG5cbiAgICAgICAgZXh0cnVkZSA9IG5vcm1hbC5tdWx0KGZsaXApO1xuICAgICAgICBpZiAoZW5kTGVmdCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kTGVmdCkpO1xuICAgICAgICBlMyA9IGxpbmVWZXJ0ZXguYWRkKGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIHR4LCAwLCBkaXN0YW5jZSkgLSB2ZXJ0ZXhTdGFydEluZGV4O1xuICAgICAgICBpZiAoZTEgPj0gMCAmJiBlMiA+PSAwKSB7XG4gICAgICAgICAgICBsaW5lRWxlbWVudC5hZGQoZTEsIGUyLCBlMyk7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXAuZWxlbWVudExlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIGUxID0gZTI7XG4gICAgICAgIGUyID0gZTM7XG5cbiAgICAgICAgZXh0cnVkZSA9IG5vcm1hbC5tdWx0KC1mbGlwKTtcbiAgICAgICAgaWYgKGVuZFJpZ2h0KSBleHRydWRlLl9zdWIobm9ybWFsLnBlcnAoKS5fbXVsdChlbmRSaWdodCkpO1xuICAgICAgICBlMyA9IGxpbmVWZXJ0ZXguYWRkKGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIHR4LCAxLCBkaXN0YW5jZSkgLSB2ZXJ0ZXhTdGFydEluZGV4O1xuICAgICAgICBpZiAoZTEgPj0gMCAmJiBlMiA+PSAwKSB7XG4gICAgICAgICAgICBsaW5lRWxlbWVudC5hZGQoZTEsIGUyLCBlMyk7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXAuZWxlbWVudExlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIGUxID0gZTI7XG4gICAgICAgIGUyID0gZTM7XG5cbiAgICAgICAgZWxlbWVudEdyb3VwLnZlcnRleExlbmd0aCArPSAyO1xuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmhhc0RhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLmVsZW1lbnRHcm91cHMuY3VycmVudDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFzdGVyQnVja2V0O1xuXG5mdW5jdGlvbiBSYXN0ZXJCdWNrZXQoaW5mbykge1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50Z3JvdXBzLmpzJyk7XG52YXIgQW5jaG9yID0gcmVxdWlyZSgnLi4vc3ltYm9sL2FuY2hvci5qcycpO1xudmFyIGludGVycG9sYXRlID0gcmVxdWlyZSgnLi4vc3ltYm9sL2ludGVycG9sYXRlLmpzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIHJlc29sdmVUb2tlbnMgPSByZXF1aXJlKCcuLi91dGlsL3Rva2VuLmpzJyk7XG52YXIgUGxhY2VtZW50ID0gcmVxdWlyZSgnLi4vc3ltYm9sL3BsYWNlbWVudC5qcycpO1xudmFyIFNoYXBpbmcgPSByZXF1aXJlKCcuLi9zeW1ib2wvc2hhcGluZy5qcycpO1xudmFyIHJlc29sdmVUZXh0ID0gcmVxdWlyZSgnLi4vc3ltYm9sL3Jlc29sdmV0ZXh0LmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sQnVja2V0O1xuXG52YXIgZnVsbFJhbmdlID0gWzIgKiBNYXRoLlBJICwgMF07XG5cbmZ1bmN0aW9uIFN5bWJvbEJ1Y2tldChpbmZvLCBidWZmZXJzLCBjb2xsaXNpb24sIGVsZW1lbnRHcm91cHMpIHtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XG4gICAgdGhpcy5jb2xsaXNpb24gPSBjb2xsaXNpb247XG5cbiAgICBpZiAoaW5mb1snc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcbiAgICAgICAgaWYgKCFpbmZvLmhhc093blByb3BlcnR5KCd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCcpKSB7XG4gICAgICAgICAgICBpbmZvWyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID0gJ21hcCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmZvLmhhc093blByb3BlcnR5KCdpY29uLXJvdGF0aW9uLWFsaWdubWVudCcpKSB7XG4gICAgICAgICAgICBpbmZvWydpY29uLXJvdGF0aW9uLWFsaWdubWVudCddID0gJ21hcCc7XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvWydzeW1ib2wtYXZvaWQtZWRnZXMnXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRHcm91cHMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50R3JvdXBzID0gZWxlbWVudEdyb3VwcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsZW1lbnRHcm91cHMgPSB7XG4gICAgICAgICAgICB0ZXh0OiBuZXcgRWxlbWVudEdyb3VwcyhidWZmZXJzLmdseXBoVmVydGV4KSxcbiAgICAgICAgICAgIGljb246IG5ldyBFbGVtZW50R3JvdXBzKGJ1ZmZlcnMuaWNvblZlcnRleClcbiAgICAgICAgfTtcbiAgICB9XG59XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuaW5mbztcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIHZhciB0ZXh0RmVhdHVyZXMgPSB0aGlzLnRleHRGZWF0dXJlcztcblxuICAgIHZhciBob3Jpem9udGFsQWxpZ24gPSAwLjU7XG4gICAgaWYgKGluZm9bJ3RleHQtaG9yaXpvbnRhbC1hbGlnbiddID09PSAncmlnaHQnKSBob3Jpem9udGFsQWxpZ24gPSAxO1xuICAgIGVsc2UgaWYgKGluZm9bJ3RleHQtaG9yaXpvbnRhbC1hbGlnbiddID09PSAnbGVmdCcpIGhvcml6b250YWxBbGlnbiA9IDA7XG5cbiAgICB2YXIgdmVydGljYWxBbGlnbiA9IDAuNTtcbiAgICBpZiAoaW5mb1sndGV4dC12ZXJ0aWNhbC1hbGlnbiddID09PSAnYm90dG9tJykgdmVydGljYWxBbGlnbiA9IDE7XG4gICAgZWxzZSBpZiAoaW5mb1sndGV4dC12ZXJ0aWNhbC1hbGlnbiddID09PSAndG9wJykgdmVydGljYWxBbGlnbiA9IDA7XG5cbiAgICB2YXIganVzdGlmeSA9IDAuNTtcbiAgICBpZiAoaW5mb1sndGV4dC1qdXN0aWZ5J10gPT09ICdyaWdodCcpIGp1c3RpZnkgPSAxO1xuICAgIGVsc2UgaWYgKGluZm9bJ3RleHQtanVzdGlmeSddID09PSAnbGVmdCcpIGp1c3RpZnkgPSAwO1xuXG4gICAgdmFyIG9uZUVtID0gMjQ7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBpbmZvWyd0ZXh0LWxpbmUtaGVpZ2h0J10gKiBvbmVFbTtcbiAgICB2YXIgbWF4V2lkdGggPSBpbmZvWydzeW1ib2wtcGxhY2VtZW50J10gIT09ICdsaW5lJyAmJiBpbmZvWyd0ZXh0LW1heC13aWR0aCddICogb25lRW07XG4gICAgdmFyIHNwYWNpbmcgPSBpbmZvWyd0ZXh0LWxldHRlci1zcGFjaW5nJ10gKiBvbmVFbTtcbiAgICB2YXIgZm9udHN0YWNrID0gaW5mb1sndGV4dC1mb250J107XG4gICAgdmFyIHRleHRPZmZzZXQgPSBbaW5mb1sndGV4dC1vZmZzZXQnXVswXSAqIG9uZUVtLCBpbmZvWyd0ZXh0LW9mZnNldCddWzFdICogb25lRW1dO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBmZWF0dXJlcy5sZW5ndGg7IGsrKykge1xuXG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNba107XG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dEZlYXR1cmVzW2tdO1xuICAgICAgICB2YXIgbGluZXMgPSBmZWF0dXJlLmxvYWRHZW9tZXRyeSgpO1xuXG4gICAgICAgIHZhciBzaGFwaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBzaGFwaW5nID0gU2hhcGluZy5zaGFwZSh0ZXh0LCBmb250c3RhY2ssIHRoaXMuc3RhY2tzLCBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCBzcGFjaW5nLCB0ZXh0T2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWFnZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zcHJpdGUgJiYgdGhpcy5pbmZvWydpY29uLWltYWdlJ10pIHtcbiAgICAgICAgICAgIGltYWdlID0gdGhpcy5zcHJpdGVbcmVzb2x2ZVRva2VucyhmZWF0dXJlLnByb3BlcnRpZXMsIGluZm9bJ2ljb24taW1hZ2UnXSldO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXRjaCBnbHlwaCB0ZXggb2JqZWN0LiBUT0RPIGNoYW5nZVxuICAgICAgICAgICAgICAgIGltYWdlLncgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBpbWFnZS5oID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLnNkZikgdGhpcy5lbGVtZW50R3JvdXBzLnNkZkljb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2hhcGluZyAmJiAhaW1hZ2UpIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUobGluZXMsIHRoaXMuc3RhY2tzLCBzaGFwaW5nLCBpbWFnZSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYnlTY2FsZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuc2NhbGUgLSBiLnNjYWxlO1xufVxuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihsaW5lcywgZmFjZXMsIHNoYXBpbmcsIGltYWdlKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLmluZm87XG4gICAgdmFyIGNvbGxpc2lvbiA9IHRoaXMuY29sbGlzaW9uO1xuXG4gICAgdmFyIG1pblNjYWxlID0gMC41O1xuICAgIHZhciBnbHlwaFNpemUgPSAyNDtcblxuICAgIHZhciBob3Jpem9udGFsVGV4dCA9IGluZm9bJ3RleHQtcm90YXRpb24tYWxpZ25tZW50J10gPT09ICd2aWV3cG9ydCcsXG4gICAgICAgIGhvcml6b250YWxJY29uID0gaW5mb1snaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ3ZpZXdwb3J0JyxcbiAgICAgICAgZm9udFNjYWxlID0gaW5mb1sndGV4dC1tYXgtc2l6ZSddIC8gZ2x5cGhTaXplLFxuICAgICAgICB0ZXh0Qm94U2NhbGUgPSBjb2xsaXNpb24udGlsZVBpeGVsUmF0aW8gKiBmb250U2NhbGUsXG4gICAgICAgIGljb25Cb3hTY2FsZSA9IGNvbGxpc2lvbi50aWxlUGl4ZWxSYXRpbyAqIGluZm9bJ2ljb24tbWF4LXNpemUnXSxcbiAgICAgICAgaWNvbldpdGhvdXRUZXh0ID0gaW5mb1sndGV4dC1vcHRpb25hbCddIHx8ICFzaGFwaW5nLFxuICAgICAgICB0ZXh0V2l0aG91dEljb24gPSBpbmZvWydpY29uLW9wdGlvbmFsJ10gfHwgIWltYWdlLFxuICAgICAgICBhdm9pZEVkZ2VzID0gaW5mb1snc3ltYm9sLWF2b2lkLWVkZ2VzJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgdmFyIGFuY2hvcnM7XG5cbiAgICAgICAgaWYgKGluZm9bJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAvLyBMaW5lIGxhYmVsc1xuICAgICAgICAgICAgYW5jaG9ycyA9IGludGVycG9sYXRlKGxpbmUsIGluZm9bJ3N5bWJvbC1taW4tZGlzdGFuY2UnXSwgbWluU2NhbGUsIGNvbGxpc2lvbi5tYXhQbGFjZW1lbnRTY2FsZSwgY29sbGlzaW9uLnRpbGVQaXhlbFJhdGlvKTtcblxuICAgICAgICAgICAgLy8gU29ydCBhbmNob3JzIGJ5IHNlZ21lbnQgc28gdGhhdCB3ZSBjYW4gc3RhcnQgcGxhY2VtZW50IHdpdGggdGhlXG4gICAgICAgICAgICAvLyBhbmNob3JzIHRoYXQgY2FuIGJlIHNob3duIGF0IHRoZSBsb3dlc3Qgem9vbSBsZXZlbHMuXG4gICAgICAgICAgICBhbmNob3JzLnNvcnQoYnlTY2FsZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBvaW50IGxhYmVsc1xuICAgICAgICAgICAgYW5jaG9ycyA9IFtuZXcgQW5jaG9yKGxpbmVbMF0ueCwgbGluZVswXS55LCAwLCBtaW5TY2FsZSldO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGNvcnJlY3QgYXNjZW5kZXIgaGVpZ2h0LlxuICAgICAgICB2YXIgb3JpZ2luID0gbmV3IFBvaW50KDAsIC0xNyk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGFuY2hvcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzW2pdO1xuICAgICAgICAgICAgdmFyIGluc2lkZSA9ICEoYW5jaG9yLnggPCAwIHx8IGFuY2hvci54ID4gNDA5NiB8fCBhbmNob3IueSA8IDAgfHwgYW5jaG9yLnkgPiA0MDk2KTtcblxuICAgICAgICAgICAgaWYgKGF2b2lkRWRnZXMgJiYgIWluc2lkZSkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGVzIGF0IHdoaWNoIHRoZSB0ZXh0IGFuZCBpY29ucyBjYW4gYmUgZmlyc3Qgc2hvd24gd2l0aG91dCBvdmVybGFwXG4gICAgICAgICAgICB2YXIgZ2x5cGg7XG4gICAgICAgICAgICB2YXIgaWNvbjtcbiAgICAgICAgICAgIHZhciBnbHlwaFNjYWxlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpY29uU2NhbGUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc2hhcGluZykge1xuICAgICAgICAgICAgICAgIGdseXBoID0gUGxhY2VtZW50LmdldEdseXBocyhhbmNob3IsIG9yaWdpbiwgc2hhcGluZywgZmFjZXMsIHRleHRCb3hTY2FsZSwgaG9yaXpvbnRhbFRleHQsIGxpbmUsIGluZm8pO1xuICAgICAgICAgICAgICAgIGdseXBoU2NhbGUgPSBpbmZvWyd0ZXh0LWFsbG93LW92ZXJsYXAnXSA/IGdseXBoLm1pblNjYWxlXG4gICAgICAgICAgICAgICAgICAgIDogY29sbGlzaW9uLmdldFBsYWNlbWVudFNjYWxlKGdseXBoLmJveGVzLCBnbHlwaC5taW5TY2FsZSwgYXZvaWRFZGdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFnbHlwaFNjYWxlICYmICFpY29uV2l0aG91dFRleHQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBpY29uID0gUGxhY2VtZW50LmdldEljb24oYW5jaG9yLCBpbWFnZSwgaWNvbkJveFNjYWxlLCBsaW5lLCBpbmZvKTtcbiAgICAgICAgICAgICAgICBpY29uU2NhbGUgPSBpbmZvWydpY29uLWFsbG93LW92ZXJsYXAnXSA/IGljb24ubWluU2NhbGVcbiAgICAgICAgICAgICAgICAgICAgOiBjb2xsaXNpb24uZ2V0UGxhY2VtZW50U2NhbGUoaWNvbi5ib3hlcywgaWNvbi5taW5TY2FsZSwgYXZvaWRFZGdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpY29uU2NhbGUgJiYgIXRleHRXaXRob3V0SWNvbikgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaWNvbldpdGhvdXRUZXh0ICYmICF0ZXh0V2l0aG91dEljb24pIHtcbiAgICAgICAgICAgICAgICBpY29uU2NhbGUgPSBnbHlwaFNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRleHRXaXRob3V0SWNvbiAmJiBnbHlwaFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhTY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgaWNvblNjYWxlKSB7XG4gICAgICAgICAgICAgICAgaWNvblNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3RhdGlvbiByYW5nZXMgaXQgaXMgc2FmZSB0byBzaG93IHRoZSBnbHlwaHNcbiAgICAgICAgICAgIHZhciBnbHlwaFJhbmdlID0gKCFnbHlwaFNjYWxlIHx8IGluZm9bJ3RleHQtYWxsb3ctb3ZlcmxhcCddKSA/IGZ1bGxSYW5nZVxuICAgICAgICAgICAgICAgIDogY29sbGlzaW9uLmdldFBsYWNlbWVudFJhbmdlKGdseXBoLmJveGVzLCBnbHlwaFNjYWxlLCBob3Jpem9udGFsVGV4dCk7XG4gICAgICAgICAgICB2YXIgaWNvblJhbmdlID0gKCFpY29uU2NhbGUgfHwgaW5mb1snaWNvbi1hbGxvdy1vdmVybGFwJ10pID8gZnVsbFJhbmdlXG4gICAgICAgICAgICAgICAgOiBjb2xsaXNpb24uZ2V0UGxhY2VtZW50UmFuZ2UoaWNvbi5ib3hlcywgaWNvblNjYWxlLCBob3Jpem9udGFsSWNvbik7XG5cbiAgICAgICAgICAgIHZhciBtYXhSYW5nZSA9IFtcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihpY29uUmFuZ2VbMF0sIGdseXBoUmFuZ2VbMF0pLFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KGljb25SYW5nZVsxXSwgZ2x5cGhSYW5nZVsxXSldO1xuXG4gICAgICAgICAgICBpZiAoIWljb25XaXRob3V0VGV4dCAmJiAhdGV4dFdpdGhvdXRJY29uKSB7XG4gICAgICAgICAgICAgICAgaWNvblJhbmdlID0gZ2x5cGhSYW5nZSA9IG1heFJhbmdlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGV4dFdpdGhvdXRJY29uKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhSYW5nZSA9IG1heFJhbmdlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaWNvbldpdGhvdXRUZXh0KSB7XG4gICAgICAgICAgICAgICAgaWNvblJhbmdlID0gbWF4UmFuZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluc2VydCBmaW5hbCBwbGFjZW1lbnQgaW50byBjb2xsaXNpb24gdHJlZSBhbmQgYWRkIGdseXBocy9pY29ucyB0byBidWZmZXJzXG4gICAgICAgICAgICBpZiAoZ2x5cGhTY2FsZSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5mb1sndGV4dC1pZ25vcmUtcGxhY2VtZW50J10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uLmluc2VydChnbHlwaC5ib3hlcywgYW5jaG9yLCBnbHlwaFNjYWxlLCBnbHlwaFJhbmdlLCBob3Jpem9udGFsVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHRoaXMuYWRkU3ltYm9scyh0aGlzLmJ1ZmZlcnMuZ2x5cGhWZXJ0ZXgsIHRoaXMuZWxlbWVudEdyb3Vwcy50ZXh0LCBnbHlwaC5zaGFwZXMsIGdseXBoU2NhbGUsIGdseXBoUmFuZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWNvblNjYWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvWydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24uaW5zZXJ0KGljb24uYm94ZXMsIGFuY2hvciwgaWNvblNjYWxlLCBpY29uUmFuZ2UsIGhvcml6b250YWxJY29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluc2lkZSkgdGhpcy5hZGRTeW1ib2xzKHRoaXMuYnVmZmVycy5pY29uVmVydGV4LCB0aGlzLmVsZW1lbnRHcm91cHMuaWNvbiwgaWNvbi5zaGFwZXMsIGljb25TY2FsZSwgaWNvblJhbmdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRTeW1ib2xzID0gZnVuY3Rpb24oYnVmZmVyLCBlbGVtZW50R3JvdXBzLCBzeW1ib2xzLCBzY2FsZSwgcGxhY2VtZW50UmFuZ2UpIHtcblxuICAgIHZhciB6b29tID0gdGhpcy5jb2xsaXNpb24uem9vbTtcblxuICAgIGVsZW1lbnRHcm91cHMubWFrZVJvb21Gb3IoMCk7XG4gICAgdmFyIGVsZW1lbnRHcm91cCA9IGVsZW1lbnRHcm91cHMuY3VycmVudDtcblxuICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjIgKyB6b29tO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzeW1ib2xzLmxlbmd0aDsgaysrKSB7XG5cbiAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNba10sXG4gICAgICAgICAgICB0bCA9IHN5bWJvbC50bCxcbiAgICAgICAgICAgIHRyID0gc3ltYm9sLnRyLFxuICAgICAgICAgICAgYmwgPSBzeW1ib2wuYmwsXG4gICAgICAgICAgICBiciA9IHN5bWJvbC5icixcbiAgICAgICAgICAgIHRleCA9IHN5bWJvbC50ZXgsXG4gICAgICAgICAgICBhbmdsZSA9IHN5bWJvbC5hbmdsZSxcbiAgICAgICAgICAgIGFuY2hvciA9IHN5bWJvbC5hbmNob3IsXG5cblxuICAgICAgICAgICAgbWluWm9vbSA9IE1hdGgubWF4KHpvb20gKyBNYXRoLmxvZyhzeW1ib2wubWluU2NhbGUpIC8gTWF0aC5MTjIsIHBsYWNlbWVudFpvb20pLFxuICAgICAgICAgICAgbWF4Wm9vbSA9IE1hdGgubWluKHpvb20gKyBNYXRoLmxvZyhzeW1ib2wubWF4U2NhbGUpIC8gTWF0aC5MTjIsIDI1KTtcblxuICAgICAgICBpZiAobWF4Wm9vbSA8PSBtaW5ab29tKSBjb250aW51ZTtcblxuICAgICAgICAvLyBMb3dlciBtaW4gem9vbSBzbyB0aGF0IHdoaWxlIGZhZGluZyBvdXQgdGhlIGxhYmVsIGl0IGNhbiBiZSBzaG93biBvdXRzaWRlIG9mIGNvbGxpc2lvbi1mcmVlIHpvb20gbGV2ZWxzXG4gICAgICAgIGlmIChtaW5ab29tID09PSBwbGFjZW1lbnRab29tKSBtaW5ab29tID0gMDtcblxuICAgICAgICAvLyBmaXJzdCB0cmlhbmdsZVxuICAgICAgICBidWZmZXIuYWRkKGFuY2hvci54LCBhbmNob3IueSwgdGwueCwgdGwueSwgdGV4LngsIHRleC55LCBhbmdsZSwgbWluWm9vbSwgcGxhY2VtZW50UmFuZ2UsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICBidWZmZXIuYWRkKGFuY2hvci54LCBhbmNob3IueSwgdHIueCwgdHIueSwgdGV4LnggKyB0ZXgudywgdGV4LnksIGFuZ2xlLCBtaW5ab29tLCBwbGFjZW1lbnRSYW5nZSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yLngsIGFuY2hvci55LCBibC54LCBibC55LCB0ZXgueCwgdGV4LnkgKyB0ZXguaCwgYW5nbGUsIG1pblpvb20sIHBsYWNlbWVudFJhbmdlLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcblxuICAgICAgICAvLyBzZWNvbmQgdHJpYW5nbGVcbiAgICAgICAgYnVmZmVyLmFkZChhbmNob3IueCwgYW5jaG9yLnksIHRyLngsIHRyLnksIHRleC54ICsgdGV4LncsIHRleC55LCBhbmdsZSwgbWluWm9vbSwgcGxhY2VtZW50UmFuZ2UsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICBidWZmZXIuYWRkKGFuY2hvci54LCBhbmNob3IueSwgYmwueCwgYmwueSwgdGV4LngsIHRleC55ICsgdGV4LmgsIGFuZ2xlLCBtaW5ab29tLCBwbGFjZW1lbnRSYW5nZSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yLngsIGFuY2hvci55LCBici54LCBici55LCB0ZXgueCArIHRleC53LCB0ZXgueSArIHRleC5oLCBhbmdsZSwgbWluWm9vbSwgcGxhY2VtZW50UmFuZ2UsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuXG4gICAgICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGggKz0gNjtcbiAgICB9XG5cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24odGlsZSwgYWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpcnN0ZG9uZSA9IGZhbHNlO1xuICAgIHZhciBmaXJzdGVycjtcbiAgICB0aGlzLmdldFRleHREZXBlbmRlbmNpZXModGlsZSwgYWN0b3IsIGRvbmUpO1xuICAgIHRoaXMuZ2V0SWNvbkRlcGVuZGVuY2llcyh0aWxlLCBhY3RvciwgZG9uZSk7XG4gICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgaWYgKGVyciB8fCBmaXJzdGRvbmUpIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGZpcnN0ZG9uZSA9IHRydWU7XG4gICAgICAgIGZpcnN0ZXJyID0gZXJyO1xuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuZ2V0SWNvbkRlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKHRpbGUsIGFjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBidWNrZXQgPSB0aGlzO1xuICAgIGlmICh0aGlzLmluZm9bJ2ljb24taW1hZ2UnXSkge1xuICAgICAgICBpZiAoU3ltYm9sQnVja2V0LnNwcml0ZSkge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBTeW1ib2xCdWNrZXQuc3ByaXRlO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdG9yLnNlbmQoJ2dldCBzcHJpdGUganNvbicsIHt9LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBTeW1ib2xCdWNrZXQuc3ByaXRlID0gYnVja2V0LnNwcml0ZSA9IGRhdGEuc3ByaXRlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5nZXRUZXh0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24odGlsZSwgYWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICB2YXIgaW5mbyA9IHRoaXMuaW5mbztcblxuICAgIGlmICh0aWxlLnN0YWNrcyA9PT0gdW5kZWZpbmVkKSB0aWxlLnN0YWNrcyA9IHt9O1xuICAgIHZhciBzdGFja3MgPSB0aGlzLnN0YWNrcyA9IHRpbGUuc3RhY2tzO1xuICAgIHZhciBmb250c3RhY2sgPSBpbmZvWyd0ZXh0LWZvbnQnXTtcbiAgICBpZiAoc3RhY2tzW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFja3NbZm9udHN0YWNrXSA9IHsgZ2x5cGhzOiB7fSwgcmVjdHM6IHt9IH07XG4gICAgfVxuICAgIHZhciBzdGFjayA9IHN0YWNrc1tmb250c3RhY2tdO1xuXG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVGV4dChmZWF0dXJlcywgaW5mbywgc3RhY2suZ2x5cGhzKTtcbiAgICB0aGlzLnRleHRGZWF0dXJlcyA9IGRhdGEudGV4dEZlYXR1cmVzO1xuXG4gICAgYWN0b3Iuc2VuZCgnZ2V0IGdseXBocycsIHtcbiAgICAgICAgaWQ6IHRpbGUuaWQsXG4gICAgICAgIGZvbnRzdGFjazogZm9udHN0YWNrLFxuICAgICAgICBjb2RlcG9pbnRzOiBkYXRhLmNvZGVwb2ludHNcbiAgICB9LCBmdW5jdGlvbihlcnIsIG5ld3N0YWNrKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuXG4gICAgICAgIHZhciBuZXdnbHlwaHMgPSBuZXdzdGFjay5nbHlwaHM7XG4gICAgICAgIHZhciBuZXdyZWN0cyA9IG5ld3N0YWNrLnJlY3RzO1xuICAgICAgICB2YXIgZ2x5cGhzID0gc3RhY2suZ2x5cGhzO1xuICAgICAgICB2YXIgcmVjdHMgPSBzdGFjay5yZWN0cztcblxuICAgICAgICBmb3IgKHZhciBjb2RlcG9pbnQgaW4gbmV3Z2x5cGhzKSB7XG4gICAgICAgICAgICBnbHlwaHNbY29kZXBvaW50XSA9IG5ld2dseXBoc1tjb2RlcG9pbnRdO1xuICAgICAgICAgICAgcmVjdHNbY29kZXBvaW50XSA9IG5ld3JlY3RzW2NvZGVwb2ludF07XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5oYXNEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5lbGVtZW50R3JvdXBzLnRleHQuY3VycmVudCB8fCAhIXRoaXMuZWxlbWVudEdyb3Vwcy5pY29uLmN1cnJlbnQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhdExuZztcblxuZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nKSB7XG4gICAgaWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcbiAgICB9XG4gICAgdGhpcy5sYXQgPSArbGF0O1xuICAgIHRoaXMubG5nID0gK2xuZztcbn1cblxuXG4vLyBjb25zdHJ1Y3RzIExhdExuZyBmcm9tIGFuIGFycmF5IGlmIG5lY2Vzc2FyeVxuXG5MYXRMbmcuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF0TG5nQm91bmRzO1xuXG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi9sYXRsbmcuanMnKTtcblxuZnVuY3Rpb24gTGF0TG5nQm91bmRzKHN3LCBuZSkge1xuICAgIGlmICghc3cpIHJldHVybjtcblxuICAgIHZhciBsYXRsbmdzID0gbmUgPyBbc3csIG5lXSA6IHN3O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XG4gICAgfVxufVxuXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xuXG4gICAgLy8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQgb3IgYm91bmRzXG4gICAgZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBzdyA9IHRoaXMuX3N3LFxuICAgICAgICAgICAgbmUgPSB0aGlzLl9uZSxcbiAgICAgICAgICAgIHN3MiwgbmUyO1xuXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcbiAgICAgICAgICAgIHN3MiA9IG9iajtcbiAgICAgICAgICAgIG5lMiA9IG9iajtcblxuICAgICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xuICAgICAgICAgICAgc3cyID0gb2JqLl9zdztcbiAgICAgICAgICAgIG5lMiA9IG9iai5fbmU7XG5cbiAgICAgICAgICAgIGlmICghc3cyIHx8ICFuZTIpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqID8gdGhpcy5leHRlbmQoTGF0TG5nLmNvbnZlcnQob2JqKSB8fCBMYXRMbmdCb3VuZHMuY29udmVydChvYmopKSA6IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3ICYmICFuZSkge1xuICAgICAgICAgICAgdGhpcy5fc3cgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xuICAgICAgICAgICAgdGhpcy5fbmUgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xuICAgICAgICAgICAgc3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcbiAgICAgICAgICAgIG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XG4gICAgICAgICAgICBuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExhdExuZygodGhpcy5fc3cubGF0ICsgdGhpcy5fbmUubGF0KSAvIDIsICh0aGlzLl9zdy5sbmcgKyB0aGlzLl9uZS5sbmcpIC8gMik7XG4gICAgfSxcblxuICAgIGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3c7IH0sXG4gICAgZ2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uZTsgfSxcbiAgICBnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7IH0sXG4gICAgZ2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpOyB9LFxuXG4gICAgZ2V0V2VzdDogIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N3LmxuZzsgfSxcbiAgICBnZXRTb3V0aDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3cubGF0OyB9LFxuICAgIGdldEVhc3Q6ICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uZS5sbmc7IH0sXG4gICAgZ2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25lLmxhdDsgfVxufTtcblxuLy8gY29uc3RydWN0cyBMYXRMbmdCb3VuZHMgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcbkxhdExuZ0JvdW5kcy5jb252ZXJ0ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykgcmV0dXJuIGE7XG4gICAgcmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoYSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi9sYXRsbmcuanMnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG4vLyBBIHNpbmdsZSB0cmFuc2Zvcm0sIGdlbmVyYWxseSB1c2VkIGZvciBhIHNpbmdsZSB0aWxlIHRvIGJlIHNjYWxlZCwgcm90YXRlZCwgYW5kIHpvb21lZC5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG1pblpvb20sIG1heFpvb20pIHtcbiAgICB0aGlzLnRpbGVTaXplID0gNTEyOyAvLyBjb25zdGFudFxuXG4gICAgdGhpcy5fbWluWm9vbSA9IG1pblpvb20gfHwgMDtcbiAgICB0aGlzLl9tYXhab29tID0gbWF4Wm9vbSB8fCAyMjtcblxuICAgIHRoaXMubGF0UmFuZ2UgPSBbLTg1LjA1MTEzLCA4NS4wNTExM107XG5cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy56b29tID0gMDtcbiAgICB0aGlzLmNlbnRlciA9IG5ldyBMYXRMbmcoMCwgMCk7XG4gICAgdGhpcy5hbmdsZSA9IDA7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gICAgZ2V0IG1pblpvb20oKSB7IHJldHVybiB0aGlzLl9taW5ab29tOyB9LFxuICAgIHNldCBtaW5ab29tKHpvb20pIHtcbiAgICAgICAgdGhpcy5fbWluWm9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuem9vbSA9IE1hdGgubWF4KHRoaXMuem9vbSwgem9vbSk7XG4gICAgfSxcblxuICAgIGdldCBtYXhab29tKCkgeyByZXR1cm4gdGhpcy5fbWF4Wm9vbTsgfSxcbiAgICBzZXQgbWF4Wm9vbSh6b29tKSB7XG4gICAgICAgIHRoaXMuX21heFpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnpvb20gPSBNYXRoLm1pbih0aGlzLnpvb20sIHpvb20pO1xuICAgIH0sXG5cbiAgICBnZXQgd29ybGRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZSAqIHRoaXMuc2NhbGU7XG4gICAgfSxcblxuICAgIGdldCBjZW50ZXJQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZS5fZGl2KDIpO1xuICAgIH0sXG5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGdldCBiZWFyaW5nKCkge1xuICAgICAgICByZXR1cm4gLXRoaXMuYW5nbGUgLyBNYXRoLlBJICogMTgwO1xuICAgIH0sXG4gICAgc2V0IGJlYXJpbmcoYmVhcmluZykge1xuICAgICAgICAvLyBjb25maW5lIHRoZSBhbmdsZSB0byB3aXRoaW4gWy0xODAsMTgwXVxuICAgICAgICBiZWFyaW5nID0gKCgoKGJlYXJpbmcgKyAxODApICUgMzYwKSArIDM2MCkgJSAzNjApIC0gMTgwO1xuICAgICAgICB0aGlzLmFuZ2xlID0gLWJlYXJpbmcgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH0sXG5cbiAgICBnZXQgem9vbSgpIHsgcmV0dXJuIHRoaXMuX3pvb207IH0sXG4gICAgc2V0IHpvb20oem9vbSkge1xuICAgICAgICB6b29tID0gTWF0aC5taW4oTWF0aC5tYXgoem9vbSwgdGhpcy5taW5ab29tKSwgdGhpcy5tYXhab29tKTtcbiAgICAgICAgdGhpcy5fem9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLnpvb21TY2FsZSh6b29tKTtcbiAgICAgICAgdGhpcy50aWxlWm9vbSA9IE1hdGguZmxvb3Ioem9vbSk7XG4gICAgICAgIHRoaXMuem9vbUZyYWN0aW9uID0gem9vbSAtIHRoaXMudGlsZVpvb207XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICB6b29tU2NhbGU6IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pOyB9LFxuICAgIHNjYWxlWm9vbTogZnVuY3Rpb24oc2NhbGUpIHsgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yOyB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24obGF0bG5nLCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMubG5nWChsYXRsbmcubG5nLCB3b3JsZFNpemUpLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxhdGxuZy5sYXQsIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRMbmcoXG4gICAgICAgICAgICB0aGlzLnlMYXQocG9pbnQueSwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueExuZyhwb2ludC54LCB3b3JsZFNpemUpKTtcbiAgICB9LFxuXG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLmxuZ1godGhpcy5jZW50ZXIubG5nKTsgfSxcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMubGF0WSh0aGlzLmNlbnRlci5sYXQpOyB9LFxuXG4gICAgZ2V0IHBvaW50KCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIC8vIGxhdC9sb24gPC0+IGFic29sdXRlIHBpeGVsIGNvb3JkcyBjb252ZXJ0aW9uXG4gICAgbG5nWDogZnVuY3Rpb24obG9uLCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuICgxODAgKyBsb24pICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcbiAgICAvLyBsYXRpdHVkZSB0byBhYnNvbHV0ZSB5IGNvb3JkXG4gICAgbGF0WTogZnVuY3Rpb24obGF0LCB3b3JsZFNpemUpIHtcbiAgICAgICAgdmFyIHkgPSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSk7XG4gICAgICAgIHJldHVybiAoMTgwIC0geSkgKiAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKSAvIDM2MDtcbiAgICB9LFxuXG4gICAgeExuZzogZnVuY3Rpb24oeCwgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiB4ICogMzYwIC8gKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLSAxODA7XG4gICAgfSxcbiAgICB5TGF0OiBmdW5jdGlvbih5LCB3b3JsZFNpemUpIHtcbiAgICAgICAgdmFyIHkyID0gMTgwIC0geSAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpO1xuICAgICAgICByZXR1cm4gMzYwIC8gTWF0aC5QSSAqIE1hdGguYXRhbihNYXRoLmV4cCh5MiAqIE1hdGguUEkgLyAxODApKSAtIDkwO1xuICAgIH0sXG5cbiAgICBwYW5CeTogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuY2VudGVyUG9pbnQuX2FkZChvZmZzZXQpO1xuICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMucG9pbnRMb2NhdGlvbihwb2ludCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICBzZXRab29tQXJvdW5kOiBmdW5jdGlvbih6b29tLCBjZW50ZXIpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmxvY2F0aW9uUG9pbnQoY2VudGVyKSxcbiAgICAgICAgICAgIHAxID0gdGhpcy5zaXplLl9zdWIocCksXG4gICAgICAgICAgICBsYXRsbmcgPSB0aGlzLnBvaW50TG9jYXRpb24ocDEpO1xuICAgICAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnBhbkJ5KHAxLnN1Yih0aGlzLmxvY2F0aW9uUG9pbnQobGF0bG5nKSkpO1xuICAgIH0sXG5cbiAgICBzZXRCZWFyaW5nQXJvdW5kOiBmdW5jdGlvbihiZWFyaW5nLCBjZW50ZXIpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMubG9jYXRpb25Qb2ludChjZW50ZXIpLnN1Yih0aGlzLmNlbnRlclBvaW50KTtcbiAgICAgICAgdGhpcy5wYW5CeShvZmZzZXQpO1xuICAgICAgICB0aGlzLmJlYXJpbmcgPSBiZWFyaW5nO1xuICAgICAgICB0aGlzLnBhbkJ5KG9mZnNldC5tdWx0KC0xKSk7XG4gICAgfSxcblxuICAgIGxvY2F0aW9uUG9pbnQ6IGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICB2YXIgcCA9IHRoaXMucHJvamVjdChsYXRsbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXJQb2ludC5fc3ViKHRoaXMucG9pbnQuX3N1YihwKS5fcm90YXRlKHRoaXMuYW5nbGUpKTtcbiAgICB9LFxuXG4gICAgcG9pbnRMb2NhdGlvbjogZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgcDIgPSB0aGlzLmNlbnRlclBvaW50Ll9zdWIocCkuX3JvdGF0ZSgtdGhpcy5hbmdsZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnVucHJvamVjdCh0aGlzLnBvaW50LnN1YihwMikpO1xuICAgIH0sXG5cbiAgICBsb2NhdGlvbkNvb3JkaW5hdGU6IGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICB2YXIgayA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20pIC8gdGhpcy53b3JsZFNpemU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2x1bW46IHRoaXMubG5nWChsYXRsbmcubG5nKSAqIGssXG4gICAgICAgICAgICByb3c6IHRoaXMubGF0WShsYXRsbmcubGF0KSAqIGssXG4gICAgICAgICAgICB6b29tOiB0aGlzLnRpbGVab29tXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBvaW50Q29vcmRpbmF0ZTogZnVuY3Rpb24odGlsZUNlbnRlciwgcCkge1xuICAgICAgICB2YXIgem9vbUZhY3RvciA9IHRoaXMuem9vbVNjYWxlKHRoaXMuem9vbUZyYWN0aW9uKSxcbiAgICAgICAgICAgIGt0ID0gdGhpcy56b29tU2NhbGUodGhpcy50aWxlWm9vbSAtIHRpbGVDZW50ZXIuem9vbSksXG4gICAgICAgICAgICBwMiA9IHRoaXMuY2VudGVyUG9pbnQuX3N1YihwKS5fcm90YXRlKC10aGlzLmFuZ2xlKS5fZGl2KHRoaXMudGlsZVNpemUgKiB6b29tRmFjdG9yKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uOiB0aWxlQ2VudGVyLmNvbHVtbiAqIGt0IC0gcDIueCxcbiAgICAgICAgICAgIHJvdzogdGlsZUNlbnRlci5yb3cgKiBrdCAtIHAyLnksXG4gICAgICAgICAgICB6b29tOiB0aGlzLnRpbGVab29tXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9jb25zdHJhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2VudGVyKSByZXR1cm47XG5cbiAgICAgICAgdmFyIG1pblksIG1heFksIG1pblgsIG1heFgsIHN5LCBzeCwgeDIsIHkyLFxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuc2l6ZTtcblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgICAgbWluWSA9IHRoaXMubGF0WSh0aGlzLmxhdFJhbmdlWzFdKTtcbiAgICAgICAgICAgIG1heFkgPSB0aGlzLmxhdFkodGhpcy5sYXRSYW5nZVswXSk7XG4gICAgICAgICAgICBzeSA9IG1heFkgLSBtaW5ZIDwgc2l6ZS55ID8gc2l6ZS55IC8gKG1heFkgLSBtaW5ZKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgICAgbWluWCA9IHRoaXMubG5nWCh0aGlzLmxuZ1JhbmdlWzBdKTtcbiAgICAgICAgICAgIG1heFggPSB0aGlzLmxuZ1godGhpcy5sbmdSYW5nZVsxXSk7XG4gICAgICAgICAgICBzeCA9IG1heFggLSBtaW5YIDwgc2l6ZS54ID8gc2l6ZS54IC8gKG1heFggLSBtaW5YKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBob3cgbXVjaCB0aGUgbWFwIHNob3VsZCBzY2FsZSB0byBmaXQgdGhlIHNjcmVlbiBpbnRvIGdpdmVuIGxhdGl0dWRlL2xvbmdpdHVkZSByYW5nZXNcbiAgICAgICAgdmFyIHMgPSBNYXRoLm1heChzeCB8fCAwLCBzeSB8fCAwKTtcblxuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgc3ggPyAobWF4WCArIG1pblgpIC8gMiA6IHRoaXMueCxcbiAgICAgICAgICAgICAgICBzeSA/IChtYXhZICsgbWluWSkgLyAyIDogdGhpcy55KSk7XG4gICAgICAgICAgICB0aGlzLnpvb20gKz0gdGhpcy5zY2FsZVpvb20ocyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnksXG4gICAgICAgICAgICAgICAgaDIgPSBzaXplLnkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeSAtIGgyIDwgbWluWSkgeTIgPSBtaW5ZICsgaDI7XG4gICAgICAgICAgICBpZiAoeSArIGgyID4gbWF4WSkgeTIgPSBtYXhZIC0gaDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICAgICAgdzIgPSBzaXplLnggLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAtIHcyIDwgbWluWCkgeDIgPSBtaW5YICsgdzI7XG4gICAgICAgICAgICBpZiAoeCArIHcyID4gbWF4WCkgeDIgPSBtYXhYIC0gdzI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW4gdGhlIG1hcCBpZiB0aGUgc2NyZWVuIGdvZXMgb2ZmIHRoZSByYW5nZVxuICAgICAgICBpZiAoeDIgIT09IHVuZGVmaW5lZCB8fCB5MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICB4MiAhPT0gdW5kZWZpbmVkID8geDIgOiB0aGlzLngsXG4gICAgICAgICAgICAgICAgeTIgIT09IHVuZGVmaW5lZCA/IHkyIDogdGhpcy55KSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLy8gRm9udCBkYXRhIEZyb20gSGVyc2hleSBTaW1wbGV4IEZvbnRcbi8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9oZXJzaGV5L1xudmFyIHNpbXBsZXhfZm9udCA9IHtcbiAgICBcIiBcIjogWzE2LCBbXV0sXG4gICAgXCIhXCI6IFsxMCwgWzUsIDIxLCA1LCA3LCAtMSwgLTEsIDUsIDIsIDQsIDEsIDUsIDAsIDYsIDEsIDUsIDJdXSxcbiAgICBcIlxcXCJcIjogWzE2LCBbNCwgMjEsIDQsIDE0LCAtMSwgLTEsIDEyLCAyMSwgMTIsIDE0XV0sXG4gICAgXCIjXCI6IFsyMSwgWzExLCAyNSwgNCwgLTcsIC0xLCAtMSwgMTcsIDI1LCAxMCwgLTcsIC0xLCAtMSwgNCwgMTIsIDE4LCAxMiwgLTEsIC0xLCAzLCA2LCAxNywgNl1dLFxuICAgIFwiJFwiOiBbMjAsIFs4LCAyNSwgOCwgLTQsIC0xLCAtMSwgMTIsIDI1LCAxMiwgLTQsIC0xLCAtMSwgMTcsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjEsIDUsIDIwLCAzLCAxOCwgMywgMTYsIDQsIDE0LCA1LCAxMywgNywgMTIsIDEzLCAxMCwgMTUsIDksIDE2LCA4LCAxNywgNiwgMTcsIDMsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgMywgM11dLFxuICAgIFwiJVwiOiBbMjQsIFsyMSwgMjEsIDMsIDAsIC0xLCAtMSwgOCwgMjEsIDEwLCAxOSwgMTAsIDE3LCA5LCAxNSwgNywgMTQsIDUsIDE0LCAzLCAxNiwgMywgMTgsIDQsIDIwLCA2LCAyMSwgOCwgMjEsIDEwLCAyMCwgMTMsIDE5LCAxNiwgMTksIDE5LCAyMCwgMjEsIDIxLCAtMSwgLTEsIDE3LCA3LCAxNSwgNiwgMTQsIDQsIDE0LCAyLCAxNiwgMCwgMTgsIDAsIDIwLCAxLCAyMSwgMywgMjEsIDUsIDE5LCA3LCAxNywgN11dLFxuICAgIFwiJlwiOiBbMjYsIFsyMywgMTIsIDIzLCAxMywgMjIsIDE0LCAyMSwgMTQsIDIwLCAxMywgMTksIDExLCAxNywgNiwgMTUsIDMsIDEzLCAxLCAxMSwgMCwgNywgMCwgNSwgMSwgNCwgMiwgMywgNCwgMywgNiwgNCwgOCwgNSwgOSwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNiwgMTQsIDE4LCAxMywgMjAsIDExLCAyMSwgOSwgMjAsIDgsIDE4LCA4LCAxNiwgOSwgMTMsIDExLCAxMCwgMTYsIDMsIDE4LCAxLCAyMCwgMCwgMjIsIDAsIDIzLCAxLCAyMywgMl1dLFxuICAgIFwiJ1wiOiBbMTAsIFs1LCAxOSwgNCwgMjAsIDUsIDIxLCA2LCAyMCwgNiwgMTgsIDUsIDE2LCA0LCAxNV1dLFxuICAgIFwiKFwiOiBbMTQsIFsxMSwgMjUsIDksIDIzLCA3LCAyMCwgNSwgMTYsIDQsIDExLCA0LCA3LCA1LCAyLCA3LCAtMiwgOSwgLTUsIDExLCAtN11dLFxuICAgIFwiKVwiOiBbMTQsIFszLCAyNSwgNSwgMjMsIDcsIDIwLCA5LCAxNiwgMTAsIDExLCAxMCwgNywgOSwgMiwgNywgLTIsIDUsIC01LCAzLCAtN11dLFxuICAgIFwiKlwiOiBbMTYsIFs4LCAyMSwgOCwgOSwgLTEsIC0xLCAzLCAxOCwgMTMsIDEyLCAtMSwgLTEsIDEzLCAxOCwgMywgMTJdXSxcbiAgICBcIitcIjogWzI2LCBbMTMsIDE4LCAxMywgMCwgLTEsIC0xLCA0LCA5LCAyMiwgOV1dLFxuICAgIFwiLFwiOiBbMTAsIFs2LCAxLCA1LCAwLCA0LCAxLCA1LCAyLCA2LCAxLCA2LCAtMSwgNSwgLTMsIDQsIC00XV0sXG4gICAgXCItXCI6IFsyNiwgWzQsIDksIDIyLCA5XV0sXG4gICAgXCIuXCI6IFsxMCwgWzUsIDIsIDQsIDEsIDUsIDAsIDYsIDEsIDUsIDJdXSxcbiAgICBcIi9cIjogWzIyLCBbMjAsIDI1LCAyLCAtN11dLFxuICAgIFwiMFwiOiBbMjAsIFs5LCAyMSwgNiwgMjAsIDQsIDE3LCAzLCAxMiwgMywgOSwgNCwgNCwgNiwgMSwgOSwgMCwgMTEsIDAsIDE0LCAxLCAxNiwgNCwgMTcsIDksIDE3LCAxMiwgMTYsIDE3LCAxNCwgMjAsIDExLCAyMSwgOSwgMjFdXSxcbiAgICBcIjFcIjogWzIwLCBbNiwgMTcsIDgsIDE4LCAxMSwgMjEsIDExLCAwXV0sXG4gICAgXCIyXCI6IFsyMCwgWzQsIDE2LCA0LCAxNywgNSwgMTksIDYsIDIwLCA4LCAyMSwgMTIsIDIxLCAxNCwgMjAsIDE1LCAxOSwgMTYsIDE3LCAxNiwgMTUsIDE1LCAxMywgMTMsIDEwLCAzLCAwLCAxNywgMF1dLFxuICAgIFwiM1wiOiBbMjAsIFs1LCAyMSwgMTYsIDIxLCAxMCwgMTMsIDEzLCAxMywgMTUsIDEyLCAxNiwgMTEsIDE3LCA4LCAxNywgNiwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNF1dLFxuICAgIFwiNFwiOiBbMjAsIFsxMywgMjEsIDMsIDcsIDE4LCA3LCAtMSwgLTEsIDEzLCAyMSwgMTMsIDBdXSxcbiAgICBcIjVcIjogWzIwLCBbMTUsIDIxLCA1LCAyMSwgNCwgMTIsIDUsIDEzLCA4LCAxNCwgMTEsIDE0LCAxNCwgMTMsIDE2LCAxMSwgMTcsIDgsIDE3LCA2LCAxNiwgMywgMTQsIDEsIDExLCAwLCA4LCAwLCA1LCAxLCA0LCAyLCAzLCA0XV0sXG4gICAgXCI2XCI6IFsyMCwgWzE2LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDEwLCAyMSwgNywgMjAsIDUsIDE3LCA0LCAxMiwgNCwgNywgNSwgMywgNywgMSwgMTAsIDAsIDExLCAwLCAxNCwgMSwgMTYsIDMsIDE3LCA2LCAxNywgNywgMTYsIDEwLCAxNCwgMTIsIDExLCAxMywgMTAsIDEzLCA3LCAxMiwgNSwgMTAsIDQsIDddXSxcbiAgICBcIjdcIjogWzIwLCBbMTcsIDIxLCA3LCAwLCAtMSwgLTEsIDMsIDIxLCAxNywgMjFdXSxcbiAgICBcIjhcIjogWzIwLCBbOCwgMjEsIDUsIDIwLCA0LCAxOCwgNCwgMTYsIDUsIDE0LCA3LCAxMywgMTEsIDEyLCAxNCwgMTEsIDE2LCA5LCAxNywgNywgMTcsIDQsIDE2LCAyLCAxNSwgMSwgMTIsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDQsIDMsIDcsIDQsIDksIDYsIDExLCA5LCAxMiwgMTMsIDEzLCAxNSwgMTQsIDE2LCAxNiwgMTYsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjFdXSxcbiAgICBcIjlcIjogWzIwLCBbMTYsIDE0LCAxNSwgMTEsIDEzLCA5LCAxMCwgOCwgOSwgOCwgNiwgOSwgNCwgMTEsIDMsIDE0LCAzLCAxNSwgNCwgMTgsIDYsIDIwLCA5LCAyMSwgMTAsIDIxLCAxMywgMjAsIDE1LCAxOCwgMTYsIDE0LCAxNiwgOSwgMTUsIDQsIDEzLCAxLCAxMCwgMCwgOCwgMCwgNSwgMSwgNCwgM11dLFxuICAgIFwiOlwiOiBbMTAsIFs1LCAxNCwgNCwgMTMsIDUsIDEyLCA2LCAxMywgNSwgMTQsIC0xLCAtMSwgNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiO1wiOiBbMTAsIFs1LCAxNCwgNCwgMTMsIDUsIDEyLCA2LCAxMywgNSwgMTQsIC0xLCAtMSwgNiwgMSwgNSwgMCwgNCwgMSwgNSwgMiwgNiwgMSwgNiwgLTEsIDUsIC0zLCA0LCAtNF1dLFxuICAgIFwiPFwiOiBbMjQsIFsyMCwgMTgsIDQsIDksIDIwLCAwXV0sXG4gICAgXCI9XCI6IFsyNiwgWzQsIDEyLCAyMiwgMTIsIC0xLCAtMSwgNCwgNiwgMjIsIDZdXSxcbiAgICBcIj5cIjogWzI0LCBbNCwgMTgsIDIwLCA5LCA0LCAwXV0sXG4gICAgXCI/XCI6IFsxOCwgWzMsIDE2LCAzLCAxNywgNCwgMTksIDUsIDIwLCA3LCAyMSwgMTEsIDIxLCAxMywgMjAsIDE0LCAxOSwgMTUsIDE3LCAxNSwgMTUsIDE0LCAxMywgMTMsIDEyLCA5LCAxMCwgOSwgNywgLTEsIC0xLCA5LCAyLCA4LCAxLCA5LCAwLCAxMCwgMSwgOSwgMl1dLFxuICAgIFwiQFwiOiBbMjcsIFsxOCwgMTMsIDE3LCAxNSwgMTUsIDE2LCAxMiwgMTYsIDEwLCAxNSwgOSwgMTQsIDgsIDExLCA4LCA4LCA5LCA2LCAxMSwgNSwgMTQsIDUsIDE2LCA2LCAxNywgOCwgLTEsIC0xLCAxMiwgMTYsIDEwLCAxNCwgOSwgMTEsIDksIDgsIDEwLCA2LCAxMSwgNSwgLTEsIC0xLCAxOCwgMTYsIDE3LCA4LCAxNywgNiwgMTksIDUsIDIxLCA1LCAyMywgNywgMjQsIDEwLCAyNCwgMTIsIDIzLCAxNSwgMjIsIDE3LCAyMCwgMTksIDE4LCAyMCwgMTUsIDIxLCAxMiwgMjEsIDksIDIwLCA3LCAxOSwgNSwgMTcsIDQsIDE1LCAzLCAxMiwgMywgOSwgNCwgNiwgNSwgNCwgNywgMiwgOSwgMSwgMTIsIDAsIDE1LCAwLCAxOCwgMSwgMjAsIDIsIDIxLCAzLCAtMSwgLTEsIDE5LCAxNiwgMTgsIDgsIDE4LCA2LCAxOSwgNV1dLFxuICAgIFwiQVwiOiBbMTgsIFs5LCAyMSwgMSwgMCwgLTEsIC0xLCA5LCAyMSwgMTcsIDAsIC0xLCAtMSwgNCwgNywgMTQsIDddXSxcbiAgICBcIkJcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEzLCAyMSwgMTYsIDIwLCAxNywgMTksIDE4LCAxNywgMTgsIDE1LCAxNywgMTMsIDE2LCAxMiwgMTMsIDExLCAtMSwgLTEsIDQsIDExLCAxMywgMTEsIDE2LCAxMCwgMTcsIDksIDE4LCA3LCAxOCwgNCwgMTcsIDIsIDE2LCAxLCAxMywgMCwgNCwgMF1dLFxuICAgIFwiQ1wiOiBbMjEsIFsxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDVdXSxcbiAgICBcIkRcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDExLCAyMSwgMTQsIDIwLCAxNiwgMTgsIDE3LCAxNiwgMTgsIDEzLCAxOCwgOCwgMTcsIDUsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDQsIDBdXSxcbiAgICBcIkVcIjogWzE5LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE3LCAyMSwgLTEsIC0xLCA0LCAxMSwgMTIsIDExLCAtMSwgLTEsIDQsIDAsIDE3LCAwXV0sXG4gICAgXCJGXCI6IFsxOCwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxNywgMjEsIC0xLCAtMSwgNCwgMTEsIDEyLCAxMV1dLFxuICAgIFwiR1wiOiBbMjEsIFsxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE4LCA4LCAtMSwgLTEsIDEzLCA4LCAxOCwgOF1dLFxuICAgIFwiSFwiOiBbMjIsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCAxOCwgMjEsIDE4LCAwLCAtMSwgLTEsIDQsIDExLCAxOCwgMTFdXSxcbiAgICBcIklcIjogWzgsIFs0LCAyMSwgNCwgMF1dLFxuICAgIFwiSlwiOiBbMTYsIFsxMiwgMjEsIDEyLCA1LCAxMSwgMiwgMTAsIDEsIDgsIDAsIDYsIDAsIDQsIDEsIDMsIDIsIDIsIDUsIDIsIDddXSxcbiAgICBcIktcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgMTgsIDIxLCA0LCA3LCAtMSwgLTEsIDksIDEyLCAxOCwgMF1dLFxuICAgIFwiTFwiOiBbMTcsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAwLCAxNiwgMF1dLFxuICAgIFwiTVwiOiBbMjQsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTIsIDAsIC0xLCAtMSwgMjAsIDIxLCAxMiwgMCwgLTEsIC0xLCAyMCwgMjEsIDIwLCAwXV0sXG4gICAgXCJOXCI6IFsyMiwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxOCwgMCwgLTEsIC0xLCAxOCwgMjEsIDE4LCAwXV0sXG4gICAgXCJPXCI6IFsyMiwgWzksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE5LCA4LCAxOSwgMTMsIDE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjFdXSxcbiAgICBcIlBcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEzLCAyMSwgMTYsIDIwLCAxNywgMTksIDE4LCAxNywgMTgsIDE0LCAxNywgMTIsIDE2LCAxMSwgMTMsIDEwLCA0LCAxMF1dLFxuICAgIFwiUVwiOiBbMjIsIFs5LCAyMSwgNywgMjAsIDUsIDE4LCA0LCAxNiwgMywgMTMsIDMsIDgsIDQsIDUsIDUsIDMsIDcsIDEsIDksIDAsIDEzLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA1LCAxOSwgOCwgMTksIDEzLCAxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxLCAtMSwgLTEsIDEyLCA0LCAxOCwgLTJdXSxcbiAgICBcIlJcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEzLCAyMSwgMTYsIDIwLCAxNywgMTksIDE4LCAxNywgMTgsIDE1LCAxNywgMTMsIDE2LCAxMiwgMTMsIDExLCA0LCAxMSwgLTEsIC0xLCAxMSwgMTEsIDE4LCAwXV0sXG4gICAgXCJTXCI6IFsyMCwgWzE3LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDgsIDIxLCA1LCAyMCwgMywgMTgsIDMsIDE2LCA0LCAxNCwgNSwgMTMsIDcsIDEyLCAxMywgMTAsIDE1LCA5LCAxNiwgOCwgMTcsIDYsIDE3LCAzLCAxNSwgMSwgMTIsIDAsIDgsIDAsIDUsIDEsIDMsIDNdXSxcbiAgICBcIlRcIjogWzE2LCBbOCwgMjEsIDgsIDAsIC0xLCAtMSwgMSwgMjEsIDE1LCAyMV1dLFxuICAgIFwiVVwiOiBbMjIsIFs0LCAyMSwgNCwgNiwgNSwgMywgNywgMSwgMTAsIDAsIDEyLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA2LCAxOCwgMjFdXSxcbiAgICBcIlZcIjogWzE4LCBbMSwgMjEsIDksIDAsIC0xLCAtMSwgMTcsIDIxLCA5LCAwXV0sXG4gICAgXCJXXCI6IFsyNCwgWzIsIDIxLCA3LCAwLCAtMSwgLTEsIDEyLCAyMSwgNywgMCwgLTEsIC0xLCAxMiwgMjEsIDE3LCAwLCAtMSwgLTEsIDIyLCAyMSwgMTcsIDBdXSxcbiAgICBcIlhcIjogWzIwLCBbMywgMjEsIDE3LCAwLCAtMSwgLTEsIDE3LCAyMSwgMywgMF1dLFxuICAgIFwiWVwiOiBbMTgsIFsxLCAyMSwgOSwgMTEsIDksIDAsIC0xLCAtMSwgMTcsIDIxLCA5LCAxMV1dLFxuICAgIFwiWlwiOiBbMjAsIFsxNywgMjEsIDMsIDAsIC0xLCAtMSwgMywgMjEsIDE3LCAyMSwgLTEsIC0xLCAzLCAwLCAxNywgMF1dLFxuICAgIFwiW1wiOiBbMTQsIFs0LCAyNSwgNCwgLTcsIC0xLCAtMSwgNSwgMjUsIDUsIC03LCAtMSwgLTEsIDQsIDI1LCAxMSwgMjUsIC0xLCAtMSwgNCwgLTcsIDExLCAtN11dLFxuICAgIFwiXFxcXFwiOiBbMTQsIFswLCAyMSwgMTQsIC0zXV0sXG4gICAgXCJdXCI6IFsxNCwgWzksIDI1LCA5LCAtNywgLTEsIC0xLCAxMCwgMjUsIDEwLCAtNywgLTEsIC0xLCAzLCAyNSwgMTAsIDI1LCAtMSwgLTEsIDMsIC03LCAxMCwgLTddXSxcbiAgICBcIl5cIjogWzE2LCBbNiwgMTUsIDgsIDE4LCAxMCwgMTUsIC0xLCAtMSwgMywgMTIsIDgsIDE3LCAxMywgMTIsIC0xLCAtMSwgOCwgMTcsIDgsIDBdXSxcbiAgICBcIl9cIjogWzE2LCBbMCwgLTIsIDE2LCAtMl1dLFxuICAgIFwiYFwiOiBbMTAsIFs2LCAyMSwgNSwgMjAsIDQsIDE4LCA0LCAxNiwgNSwgMTUsIDYsIDE2LCA1LCAxN11dLFxuICAgIFwiYVwiOiBbMTksIFsxNSwgMTQsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImJcIjogWzE5LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMTEsIDYsIDEzLCA4LCAxNCwgMTEsIDE0LCAxMywgMTMsIDE1LCAxMSwgMTYsIDgsIDE2LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA4LCAwLCA2LCAxLCA0LCAzXV0sXG4gICAgXCJjXCI6IFsxOCwgWzE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImRcIjogWzE5LCBbMTUsIDIxLCAxNSwgMCwgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJlXCI6IFsxOCwgWzMsIDgsIDE1LCA4LCAxNSwgMTAsIDE0LCAxMiwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImZcIjogWzEyLCBbMTAsIDIxLCA4LCAyMSwgNiwgMjAsIDUsIDE3LCA1LCAwLCAtMSwgLTEsIDIsIDE0LCA5LCAxNF1dLFxuICAgIFwiZ1wiOiBbMTksIFsxNSwgMTQsIDE1LCAtMiwgMTQsIC01LCAxMywgLTYsIDExLCAtNywgOCwgLTcsIDYsIC02LCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImhcIjogWzE5LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMTAsIDcsIDEzLCA5LCAxNCwgMTIsIDE0LCAxNCwgMTMsIDE1LCAxMCwgMTUsIDBdXSxcbiAgICBcImlcIjogWzgsIFszLCAyMSwgNCwgMjAsIDUsIDIxLCA0LCAyMiwgMywgMjEsIC0xLCAtMSwgNCwgMTQsIDQsIDBdXSxcbiAgICBcImpcIjogWzEwLCBbNSwgMjEsIDYsIDIwLCA3LCAyMSwgNiwgMjIsIDUsIDIxLCAtMSwgLTEsIDYsIDE0LCA2LCAtMywgNSwgLTYsIDMsIC03LCAxLCAtN11dLFxuICAgIFwia1wiOiBbMTcsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCAxNCwgMTQsIDQsIDQsIC0xLCAtMSwgOCwgOCwgMTUsIDBdXSxcbiAgICBcImxcIjogWzgsIFs0LCAyMSwgNCwgMF1dLFxuICAgIFwibVwiOiBbMzAsIFs0LCAxNCwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMCwgLTEsIC0xLCAxNSwgMTAsIDE4LCAxMywgMjAsIDE0LCAyMywgMTQsIDI1LCAxMywgMjYsIDEwLCAyNiwgMF1dLFxuICAgIFwiblwiOiBbMTksIFs0LCAxNCwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMF1dLFxuICAgIFwib1wiOiBbMTksIFs4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzLCAxNiwgNiwgMTYsIDgsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0XV0sXG4gICAgXCJwXCI6IFsxOSwgWzQsIDE0LCA0LCAtNywgLTEsIC0xLCA0LCAxMSwgNiwgMTMsIDgsIDE0LCAxMSwgMTQsIDEzLCAxMywgMTUsIDExLCAxNiwgOCwgMTYsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDgsIDAsIDYsIDEsIDQsIDNdXSxcbiAgICBcInFcIjogWzE5LCBbMTUsIDE0LCAxNSwgLTcsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiclwiOiBbMTMsIFs0LCAxNCwgNCwgMCwgLTEsIC0xLCA0LCA4LCA1LCAxMSwgNywgMTMsIDksIDE0LCAxMiwgMTRdXSxcbiAgICBcInNcIjogWzE3LCBbMTQsIDExLCAxMywgMTMsIDEwLCAxNCwgNywgMTQsIDQsIDEzLCAzLCAxMSwgNCwgOSwgNiwgOCwgMTEsIDcsIDEzLCA2LCAxNCwgNCwgMTQsIDMsIDEzLCAxLCAxMCwgMCwgNywgMCwgNCwgMSwgMywgM11dLFxuICAgIFwidFwiOiBbMTIsIFs1LCAyMSwgNSwgNCwgNiwgMSwgOCwgMCwgMTAsIDAsIC0xLCAtMSwgMiwgMTQsIDksIDE0XV0sXG4gICAgXCJ1XCI6IFsxOSwgWzQsIDE0LCA0LCA0LCA1LCAxLCA3LCAwLCAxMCwgMCwgMTIsIDEsIDE1LCA0LCAtMSwgLTEsIDE1LCAxNCwgMTUsIDBdXSxcbiAgICBcInZcIjogWzE2LCBbMiwgMTQsIDgsIDAsIC0xLCAtMSwgMTQsIDE0LCA4LCAwXV0sXG4gICAgXCJ3XCI6IFsyMiwgWzMsIDE0LCA3LCAwLCAtMSwgLTEsIDExLCAxNCwgNywgMCwgLTEsIC0xLCAxMSwgMTQsIDE1LCAwLCAtMSwgLTEsIDE5LCAxNCwgMTUsIDBdXSxcbiAgICBcInhcIjogWzE3LCBbMywgMTQsIDE0LCAwLCAtMSwgLTEsIDE0LCAxNCwgMywgMF1dLFxuICAgIFwieVwiOiBbMTYsIFsyLCAxNCwgOCwgMCwgLTEsIC0xLCAxNCwgMTQsIDgsIDAsIDYsIC00LCA0LCAtNiwgMiwgLTcsIDEsIC03XV0sXG4gICAgXCJ6XCI6IFsxNywgWzE0LCAxNCwgMywgMCwgLTEsIC0xLCAzLCAxNCwgMTQsIDE0LCAtMSwgLTEsIDMsIDAsIDE0LCAwXV0sXG4gICAgXCJ7XCI6IFsxNCwgWzksIDI1LCA3LCAyNCwgNiwgMjMsIDUsIDIxLCA1LCAxOSwgNiwgMTcsIDcsIDE2LCA4LCAxNCwgOCwgMTIsIDYsIDEwLCAtMSwgLTEsIDcsIDI0LCA2LCAyMiwgNiwgMjAsIDcsIDE4LCA4LCAxNywgOSwgMTUsIDksIDEzLCA4LCAxMSwgNCwgOSwgOCwgNywgOSwgNSwgOSwgMywgOCwgMSwgNywgMCwgNiwgLTIsIDYsIC00LCA3LCAtNiwgLTEsIC0xLCA2LCA4LCA4LCA2LCA4LCA0LCA3LCAyLCA2LCAxLCA1LCAtMSwgNSwgLTMsIDYsIC01LCA3LCAtNiwgOSwgLTddXSxcbiAgICBcInxcIjogWzgsIFs0LCAyNSwgNCwgLTddXSxcbiAgICBcIn1cIjogWzE0LCBbNSwgMjUsIDcsIDI0LCA4LCAyMywgOSwgMjEsIDksIDE5LCA4LCAxNywgNywgMTYsIDYsIDE0LCA2LCAxMiwgOCwgMTAsIC0xLCAtMSwgNywgMjQsIDgsIDIyLCA4LCAyMCwgNywgMTgsIDYsIDE3LCA1LCAxNSwgNSwgMTMsIDYsIDExLCAxMCwgOSwgNiwgNywgNSwgNSwgNSwgMywgNiwgMSwgNywgMCwgOCwgLTIsIDgsIC00LCA3LCAtNiwgLTEsIC0xLCA4LCA4LCA2LCA2LCA2LCA0LCA3LCAyLCA4LCAxLCA5LCAtMSwgOSwgLTMsIDgsIC01LCA3LCAtNiwgNSwgLTddXSxcbiAgICBcIn5cIjogWzI0LCBbMywgNiwgMywgOCwgNCwgMTEsIDYsIDEyLCA4LCAxMiwgMTAsIDExLCAxNCwgOCwgMTYsIDcsIDE4LCA3LCAyMCwgOCwgMjEsIDEwLCAtMSwgLTEsIDMsIDgsIDQsIDEwLCA2LCAxMSwgOCwgMTEsIDEwLCAxMCwgMTQsIDcsIDE2LCA2LCAxOCwgNiwgMjAsIDcsIDIxLCAxMCwgMjEsIDEyXV0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHRWZXJ0aWNlcyh0ZXh0LCBsZWZ0LCBiYXNlbGluZSwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDE7XG5cbiAgICB2YXIgc3Ryb2tlcyA9IFtdLFxuICAgICAgICBpLCBsZW4sIGosIGxlbjIsIGdseXBoLCBkYXRhLCB4LCB5LCBwcmV2O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBnbHlwaCA9IHNpbXBsZXhfZm9udFt0ZXh0W2ldXTtcbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG4gICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSBnbHlwaFsxXS5sZW5ndGg7IGogPCBsZW4yOyBqICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChnbHlwaFsxXVtqXSA9PT0gLTEgJiYgZ2x5cGhbMV1baiArIDFdID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBsZWZ0ICsgZ2x5cGhbMV1bal0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICB5ID0gYmFzZWxpbmUgLSBnbHlwaFsxXVtqICsgMV0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VzLnB1c2gocHJldi54LCBwcmV2LnksIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ID0ge3g6IHgsIHk6IHl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnQgKz0gZ2x5cGhbMF0gKiBzY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Ryb2tlcztcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcbiAqIEBhdXRob3IgQ29saW4gTWFjS2VuemllIElWXG4gKiBAdmVyc2lvbiAyLjIuMFxuICovXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cbihmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjt2YXIgdD17fTt0eXBlb2YgZXhwb3J0cz09XCJ1bmRlZmluZWRcIj90eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBkZWZpbmUuYW1kPT1cIm9iamVjdFwiJiZkZWZpbmUuYW1kPyh0LmV4cG9ydHM9e30sZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZXhwb3J0c30pKTp0LmV4cG9ydHM9dHlwZW9mIHdpbmRvdyE9XCJ1bmRlZmluZWRcIj93aW5kb3c6ZTp0LmV4cG9ydHM9ZXhwb3J0cyxmdW5jdGlvbihlKXtpZighdCl2YXIgdD0xZS02O2lmKCFuKXZhciBuPXR5cGVvZiBGbG9hdDMyQXJyYXkhPVwidW5kZWZpbmVkXCI/RmxvYXQzMkFycmF5OkFycmF5O2lmKCFyKXZhciByPU1hdGgucmFuZG9tO3ZhciBpPXt9O2kuc2V0TWF0cml4QXJyYXlUeXBlPWZ1bmN0aW9uKGUpe249ZX0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLmdsTWF0cml4PWkpO3ZhciBzPXt9O3MuY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oMik7cmV0dXJuIGVbMF09MCxlWzFdPTAsZX0scy5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbigyKTtyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVsxXSx0fSxzLmZyb21WYWx1ZXM9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgbigyKTtyZXR1cm4gclswXT1lLHJbMV09dCxyfSxzLmNvcHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlfSxzLnNldD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dCxlWzFdPW4sZX0scy5hZGQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0rblswXSxlWzFdPXRbMV0rblsxXSxlfSxzLnN1YnRyYWN0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdLW5bMF0sZVsxXT10WzFdLW5bMV0sZX0scy5zdWI9cy5zdWJ0cmFjdCxzLm11bHRpcGx5PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdKm5bMF0sZVsxXT10WzFdKm5bMV0sZX0scy5tdWw9cy5tdWx0aXBseSxzLmRpdmlkZT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXS9uWzBdLGVbMV09dFsxXS9uWzFdLGV9LHMuZGl2PXMuZGl2aWRlLHMubWluPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT1NYXRoLm1pbih0WzBdLG5bMF0pLGVbMV09TWF0aC5taW4odFsxXSxuWzFdKSxlfSxzLm1heD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09TWF0aC5tYXgodFswXSxuWzBdKSxlWzFdPU1hdGgubWF4KHRbMV0sblsxXSksZX0scy5zY2FsZT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXSpuLGVbMV09dFsxXSpuLGV9LHMuc2NhbGVBbmRBZGQ9ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIGVbMF09dFswXStuWzBdKnIsZVsxXT10WzFdK25bMV0qcixlfSxzLmRpc3RhbmNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXS1lWzBdLHI9dFsxXS1lWzFdO3JldHVybiBNYXRoLnNxcnQobipuK3Iqcil9LHMuZGlzdD1zLmRpc3RhbmNlLHMuc3F1YXJlZERpc3RhbmNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXS1lWzBdLHI9dFsxXS1lWzFdO3JldHVybiBuKm4rcipyfSxzLnNxckRpc3Q9cy5zcXVhcmVkRGlzdGFuY2Uscy5sZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV07cmV0dXJuIE1hdGguc3FydCh0KnQrbipuKX0scy5sZW49cy5sZW5ndGgscy5zcXVhcmVkTGVuZ3RoPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdO3JldHVybiB0KnQrbipufSxzLnNxckxlbj1zLnNxdWFyZWRMZW5ndGgscy5uZWdhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT0tdFswXSxlWzFdPS10WzFdLGV9LHMubm9ybWFsaXplPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT1uKm4rcipyO3JldHVybiBpPjAmJihpPTEvTWF0aC5zcXJ0KGkpLGVbMF09dFswXSppLGVbMV09dFsxXSppKSxlfSxzLmRvdD1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdKnRbMF0rZVsxXSp0WzFdfSxzLmNyb3NzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdKm5bMV0tdFsxXSpuWzBdO3JldHVybiBlWzBdPWVbMV09MCxlWzJdPXIsZX0scy5sZXJwPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXRbMF0scz10WzFdO3JldHVybiBlWzBdPWkrciooblswXS1pKSxlWzFdPXMrciooblsxXS1zKSxlfSxzLnJhbmRvbT1mdW5jdGlvbihlLHQpe3Q9dHx8MTt2YXIgbj1yKCkqMipNYXRoLlBJO3JldHVybiBlWzBdPU1hdGguY29zKG4pKnQsZVsxXT1NYXRoLnNpbihuKSp0LGV9LHMudHJhbnNmb3JtTWF0Mj1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV07cmV0dXJuIGVbMF09blswXSpyK25bMl0qaSxlWzFdPW5bMV0qcituWzNdKmksZX0scy50cmFuc2Zvcm1NYXQyZD1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV07cmV0dXJuIGVbMF09blswXSpyK25bMl0qaStuWzRdLGVbMV09blsxXSpyK25bM10qaStuWzVdLGV9LHMudHJhbnNmb3JtTWF0Mz1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV07cmV0dXJuIGVbMF09blswXSpyK25bM10qaStuWzZdLGVbMV09blsxXSpyK25bNF0qaStuWzddLGV9LHMudHJhbnNmb3JtTWF0ND1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV07cmV0dXJuIGVbMF09blswXSpyK25bNF0qaStuWzEyXSxlWzFdPW5bMV0qcituWzVdKmkrblsxM10sZX0scy5mb3JFYWNoPWZ1bmN0aW9uKCl7dmFyIGU9cy5jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24odCxuLHIsaSxzLG8pe3ZhciB1LGE7bnx8KG49Mikscnx8KHI9MCksaT9hPU1hdGgubWluKGkqbityLHQubGVuZ3RoKTphPXQubGVuZ3RoO2Zvcih1PXI7dTxhO3UrPW4pZVswXT10W3VdLGVbMV09dFt1KzFdLHMoZSxlLG8pLHRbdV09ZVswXSx0W3UrMV09ZVsxXTtyZXR1cm4gdH19KCkscy5zdHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJ2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpXCJ9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS52ZWMyPXMpO3ZhciBvPXt9O28uY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oMyk7cmV0dXJuIGVbMF09MCxlWzFdPTAsZVsyXT0wLGV9LG8uY2xvbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG4oMyk7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbMV0sdFsyXT1lWzJdLHR9LG8uZnJvbVZhbHVlcz1mdW5jdGlvbihlLHQscil7dmFyIGk9bmV3IG4oMyk7cmV0dXJuIGlbMF09ZSxpWzFdPXQsaVsyXT1yLGl9LG8uY29weT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlfSxvLnNldD1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gZVswXT10LGVbMV09bixlWzJdPXIsZX0sby5hZGQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0rblswXSxlWzFdPXRbMV0rblsxXSxlWzJdPXRbMl0rblsyXSxlfSxvLnN1YnRyYWN0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdLW5bMF0sZVsxXT10WzFdLW5bMV0sZVsyXT10WzJdLW5bMl0sZX0sby5zdWI9by5zdWJ0cmFjdCxvLm11bHRpcGx5PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdKm5bMF0sZVsxXT10WzFdKm5bMV0sZVsyXT10WzJdKm5bMl0sZX0sby5tdWw9by5tdWx0aXBseSxvLmRpdmlkZT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXS9uWzBdLGVbMV09dFsxXS9uWzFdLGVbMl09dFsyXS9uWzJdLGV9LG8uZGl2PW8uZGl2aWRlLG8ubWluPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT1NYXRoLm1pbih0WzBdLG5bMF0pLGVbMV09TWF0aC5taW4odFsxXSxuWzFdKSxlWzJdPU1hdGgubWluKHRbMl0sblsyXSksZX0sby5tYXg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPU1hdGgubWF4KHRbMF0sblswXSksZVsxXT1NYXRoLm1heCh0WzFdLG5bMV0pLGVbMl09TWF0aC5tYXgodFsyXSxuWzJdKSxlfSxvLnNjYWxlPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdKm4sZVsxXT10WzFdKm4sZVsyXT10WzJdKm4sZX0sby5zY2FsZUFuZEFkZD1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gZVswXT10WzBdK25bMF0qcixlWzFdPXRbMV0rblsxXSpyLGVbMl09dFsyXStuWzJdKnIsZX0sby5kaXN0YW5jZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0tZVswXSxyPXRbMV0tZVsxXSxpPXRbMl0tZVsyXTtyZXR1cm4gTWF0aC5zcXJ0KG4qbityKnIraSppKX0sby5kaXN0PW8uZGlzdGFuY2Usby5zcXVhcmVkRGlzdGFuY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLWVbMF0scj10WzFdLWVbMV0saT10WzJdLWVbMl07cmV0dXJuIG4qbityKnIraSppfSxvLnNxckRpc3Q9by5zcXVhcmVkRGlzdGFuY2Usby5sZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV0scj1lWzJdO3JldHVybiBNYXRoLnNxcnQodCp0K24qbityKnIpfSxvLmxlbj1vLmxlbmd0aCxvLnNxdWFyZWRMZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV0scj1lWzJdO3JldHVybiB0KnQrbipuK3Iqcn0sby5zcXJMZW49by5zcXVhcmVkTGVuZ3RoLG8ubmVnYXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09LXRbMF0sZVsxXT0tdFsxXSxlWzJdPS10WzJdLGV9LG8ubm9ybWFsaXplPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9bipuK3IqcitpKmk7cmV0dXJuIHM+MCYmKHM9MS9NYXRoLnNxcnQocyksZVswXT10WzBdKnMsZVsxXT10WzFdKnMsZVsyXT10WzJdKnMpLGV9LG8uZG90PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF0qdFswXStlWzFdKnRbMV0rZVsyXSp0WzJdfSxvLmNyb3NzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz1uWzBdLHU9blsxXSxhPW5bMl07cmV0dXJuIGVbMF09aSphLXMqdSxlWzFdPXMqby1yKmEsZVsyXT1yKnUtaSpvLGV9LG8ubGVycD1mdW5jdGlvbihlLHQsbixyKXt2YXIgaT10WzBdLHM9dFsxXSxvPXRbMl07cmV0dXJuIGVbMF09aStyKihuWzBdLWkpLGVbMV09cytyKihuWzFdLXMpLGVbMl09bytyKihuWzJdLW8pLGV9LG8ucmFuZG9tPWZ1bmN0aW9uKGUsdCl7dD10fHwxO3ZhciBuPXIoKSoyKk1hdGguUEksaT1yKCkqMi0xLHM9TWF0aC5zcXJ0KDEtaSppKSp0O3JldHVybiBlWzBdPU1hdGguY29zKG4pKnMsZVsxXT1NYXRoLnNpbihuKSpzLGVbMl09aSp0LGV9LG8udHJhbnNmb3JtTWF0ND1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdO3JldHVybiBlWzBdPW5bMF0qcituWzRdKmkrbls4XSpzK25bMTJdLGVbMV09blsxXSpyK25bNV0qaStuWzldKnMrblsxM10sZVsyXT1uWzJdKnIrbls2XSppK25bMTBdKnMrblsxNF0sZX0sby50cmFuc2Zvcm1NYXQzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl07cmV0dXJuIGVbMF09cipuWzBdK2kqblszXStzKm5bNl0sZVsxXT1yKm5bMV0raSpuWzRdK3Mqbls3XSxlWzJdPXIqblsyXStpKm5bNV0rcypuWzhdLGV9LG8udHJhbnNmb3JtUXVhdD1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89blswXSx1PW5bMV0sYT1uWzJdLGY9blszXSxsPWYqcit1KnMtYSppLGM9ZippK2Eqci1vKnMsaD1mKnMrbyppLXUqcixwPS1vKnItdSppLWEqcztyZXR1cm4gZVswXT1sKmYrcCotbytjKi1hLWgqLXUsZVsxXT1jKmYrcCotdStoKi1vLWwqLWEsZVsyXT1oKmYrcCotYStsKi11LWMqLW8sZX0sby5mb3JFYWNoPWZ1bmN0aW9uKCl7dmFyIGU9by5jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24odCxuLHIsaSxzLG8pe3ZhciB1LGE7bnx8KG49Mykscnx8KHI9MCksaT9hPU1hdGgubWluKGkqbityLHQubGVuZ3RoKTphPXQubGVuZ3RoO2Zvcih1PXI7dTxhO3UrPW4pZVswXT10W3VdLGVbMV09dFt1KzFdLGVbMl09dFt1KzJdLHMoZSxlLG8pLHRbdV09ZVswXSx0W3UrMV09ZVsxXSx0W3UrMl09ZVsyXTtyZXR1cm4gdH19KCksby5zdHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJ2ZWMzKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIsIFwiK2VbMl0rXCIpXCJ9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS52ZWMzPW8pO3ZhciB1PXt9O3UuY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oNCk7cmV0dXJuIGVbMF09MCxlWzFdPTAsZVsyXT0wLGVbM109MCxlfSx1LmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuKDQpO3JldHVybiB0WzBdPWVbMF0sdFsxXT1lWzFdLHRbMl09ZVsyXSx0WzNdPWVbM10sdH0sdS5mcm9tVmFsdWVzPWZ1bmN0aW9uKGUsdCxyLGkpe3ZhciBzPW5ldyBuKDQpO3JldHVybiBzWzBdPWUsc1sxXT10LHNbMl09cixzWzNdPWksc30sdS5jb3B5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGVbM109dFszXSxlfSx1LnNldD1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBlWzBdPXQsZVsxXT1uLGVbMl09cixlWzNdPWksZX0sdS5hZGQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0rblswXSxlWzFdPXRbMV0rblsxXSxlWzJdPXRbMl0rblsyXSxlWzNdPXRbM10rblszXSxlfSx1LnN1YnRyYWN0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdLW5bMF0sZVsxXT10WzFdLW5bMV0sZVsyXT10WzJdLW5bMl0sZVszXT10WzNdLW5bM10sZX0sdS5zdWI9dS5zdWJ0cmFjdCx1Lm11bHRpcGx5PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdKm5bMF0sZVsxXT10WzFdKm5bMV0sZVsyXT10WzJdKm5bMl0sZVszXT10WzNdKm5bM10sZX0sdS5tdWw9dS5tdWx0aXBseSx1LmRpdmlkZT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXS9uWzBdLGVbMV09dFsxXS9uWzFdLGVbMl09dFsyXS9uWzJdLGVbM109dFszXS9uWzNdLGV9LHUuZGl2PXUuZGl2aWRlLHUubWluPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT1NYXRoLm1pbih0WzBdLG5bMF0pLGVbMV09TWF0aC5taW4odFsxXSxuWzFdKSxlWzJdPU1hdGgubWluKHRbMl0sblsyXSksZVszXT1NYXRoLm1pbih0WzNdLG5bM10pLGV9LHUubWF4PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT1NYXRoLm1heCh0WzBdLG5bMF0pLGVbMV09TWF0aC5tYXgodFsxXSxuWzFdKSxlWzJdPU1hdGgubWF4KHRbMl0sblsyXSksZVszXT1NYXRoLm1heCh0WzNdLG5bM10pLGV9LHUuc2NhbGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0qbixlWzFdPXRbMV0qbixlWzJdPXRbMl0qbixlWzNdPXRbM10qbixlfSx1LnNjYWxlQW5kQWRkPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBlWzBdPXRbMF0rblswXSpyLGVbMV09dFsxXStuWzFdKnIsZVsyXT10WzJdK25bMl0qcixlWzNdPXRbM10rblszXSpyLGV9LHUuZGlzdGFuY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLWVbMF0scj10WzFdLWVbMV0saT10WzJdLWVbMl0scz10WzNdLWVbM107cmV0dXJuIE1hdGguc3FydChuKm4rcipyK2kqaStzKnMpfSx1LmRpc3Q9dS5kaXN0YW5jZSx1LnNxdWFyZWREaXN0YW5jZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0tZVswXSxyPXRbMV0tZVsxXSxpPXRbMl0tZVsyXSxzPXRbM10tZVszXTtyZXR1cm4gbipuK3IqcitpKmkrcypzfSx1LnNxckRpc3Q9dS5zcXVhcmVkRGlzdGFuY2UsdS5sZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV0scj1lWzJdLGk9ZVszXTtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtuKm4rcipyK2kqaSl9LHUubGVuPXUubGVuZ3RoLHUuc3F1YXJlZExlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXSxyPWVbMl0saT1lWzNdO3JldHVybiB0KnQrbipuK3IqcitpKml9LHUuc3FyTGVuPXUuc3F1YXJlZExlbmd0aCx1Lm5lZ2F0ZT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPS10WzBdLGVbMV09LXRbMV0sZVsyXT0tdFsyXSxlWzNdPS10WzNdLGV9LHUubm9ybWFsaXplPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPW4qbityKnIraSppK3MqcztyZXR1cm4gbz4wJiYobz0xL01hdGguc3FydChvKSxlWzBdPXRbMF0qbyxlWzFdPXRbMV0qbyxlWzJdPXRbMl0qbyxlWzNdPXRbM10qbyksZX0sdS5kb3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXSp0WzBdK2VbMV0qdFsxXStlWzJdKnRbMl0rZVszXSp0WzNdfSx1LmxlcnA9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9dFswXSxzPXRbMV0sbz10WzJdLHU9dFszXTtyZXR1cm4gZVswXT1pK3IqKG5bMF0taSksZVsxXT1zK3IqKG5bMV0tcyksZVsyXT1vK3IqKG5bMl0tbyksZVszXT11K3IqKG5bM10tdSksZX0sdS5yYW5kb209ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD10fHwxLGVbMF09cigpLGVbMV09cigpLGVbMl09cigpLGVbM109cigpLHUubm9ybWFsaXplKGUsZSksdS5zY2FsZShlLGUsdCksZX0sdS50cmFuc2Zvcm1NYXQ0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdO3JldHVybiBlWzBdPW5bMF0qcituWzRdKmkrbls4XSpzK25bMTJdKm8sZVsxXT1uWzFdKnIrbls1XSppK25bOV0qcytuWzEzXSpvLGVbMl09blsyXSpyK25bNl0qaStuWzEwXSpzK25bMTRdKm8sZVszXT1uWzNdKnIrbls3XSppK25bMTFdKnMrblsxNV0qbyxlfSx1LnRyYW5zZm9ybVF1YXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPW5bMF0sdT1uWzFdLGE9blsyXSxmPW5bM10sbD1mKnIrdSpzLWEqaSxjPWYqaSthKnItbypzLGg9ZipzK28qaS11KnIscD0tbypyLXUqaS1hKnM7cmV0dXJuIGVbMF09bCpmK3AqLW8rYyotYS1oKi11LGVbMV09YypmK3AqLXUraCotby1sKi1hLGVbMl09aCpmK3AqLWErbCotdS1jKi1vLGV9LHUuZm9yRWFjaD1mdW5jdGlvbigpe3ZhciBlPXUuY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKHQsbixyLGkscyxvKXt2YXIgdSxhO258fChuPTQpLHJ8fChyPTApLGk/YT1NYXRoLm1pbihpKm4rcix0Lmxlbmd0aCk6YT10Lmxlbmd0aDtmb3IodT1yO3U8YTt1Kz1uKWVbMF09dFt1XSxlWzFdPXRbdSsxXSxlWzJdPXRbdSsyXSxlWzNdPXRbdSszXSxzKGUsZSxvKSx0W3VdPWVbMF0sdFt1KzFdPWVbMV0sdFt1KzJdPWVbMl0sdFt1KzNdPWVbM107cmV0dXJuIHR9fSgpLHUuc3RyPWZ1bmN0aW9uKGUpe3JldHVyblwidmVjNChcIitlWzBdK1wiLCBcIitlWzFdK1wiLCBcIitlWzJdK1wiLCBcIitlWzNdK1wiKVwifSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUudmVjND11KTt2YXIgYT17fTthLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKDQpO3JldHVybiBlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTEsZX0sYS5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbig0KTtyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVsxXSx0WzJdPWVbMl0sdFszXT1lWzNdLHR9LGEuY29weT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlWzNdPXRbM10sZX0sYS5pZGVudGl0eT1mdW5jdGlvbihlKXtyZXR1cm4gZVswXT0xLGVbMV09MCxlWzJdPTAsZVszXT0xLGV9LGEudHJhbnNwb3NlPWZ1bmN0aW9uKGUsdCl7aWYoZT09PXQpe3ZhciBuPXRbMV07ZVsxXT10WzJdLGVbMl09bn1lbHNlIGVbMF09dFswXSxlWzFdPXRbMl0sZVsyXT10WzFdLGVbM109dFszXTtyZXR1cm4gZX0sYS5pbnZlcnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89bipzLWkqcjtyZXR1cm4gbz8obz0xL28sZVswXT1zKm8sZVsxXT0tcipvLGVbMl09LWkqbyxlWzNdPW4qbyxlKTpudWxsfSxhLmFkam9pbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdO3JldHVybiBlWzBdPXRbM10sZVsxXT0tdFsxXSxlWzJdPS10WzJdLGVbM109bixlfSxhLmRldGVybWluYW50PWZ1bmN0aW9uKGUpe3JldHVybiBlWzBdKmVbM10tZVsyXSplWzFdfSxhLm11bHRpcGx5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9blswXSxhPW5bMV0sZj1uWzJdLGw9blszXTtyZXR1cm4gZVswXT1yKnUraSpmLGVbMV09ciphK2kqbCxlWzJdPXMqdStvKmYsZVszXT1zKmErbypsLGV9LGEubXVsPWEubXVsdGlwbHksYS5yb3RhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT1NYXRoLnNpbihuKSxhPU1hdGguY29zKG4pO3JldHVybiBlWzBdPXIqYStpKnUsZVsxXT1yKi11K2kqYSxlWzJdPXMqYStvKnUsZVszXT1zKi11K28qYSxlfSxhLnNjYWxlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9blswXSxhPW5bMV07cmV0dXJuIGVbMF09cip1LGVbMV09aSphLGVbMl09cyp1LGVbM109byphLGV9LGEuc3RyPWZ1bmN0aW9uKGUpe3JldHVyblwibWF0MihcIitlWzBdK1wiLCBcIitlWzFdK1wiLCBcIitlWzJdK1wiLCBcIitlWzNdK1wiKVwifSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUubWF0Mj1hKTt2YXIgZj17fTtmLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKDYpO3JldHVybiBlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTEsZVs0XT0wLGVbNV09MCxlfSxmLmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuKDYpO3JldHVybiB0WzBdPWVbMF0sdFsxXT1lWzFdLHRbMl09ZVsyXSx0WzNdPWVbM10sdFs0XT1lWzRdLHRbNV09ZVs1XSx0fSxmLmNvcHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZVszXT10WzNdLGVbNF09dFs0XSxlWzVdPXRbNV0sZX0sZi5pZGVudGl0eT1mdW5jdGlvbihlKXtyZXR1cm4gZVswXT0xLGVbMV09MCxlWzJdPTAsZVszXT0xLGVbNF09MCxlWzVdPTAsZX0sZi5pbnZlcnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89dFs0XSx1PXRbNV0sYT1uKnMtcippO3JldHVybiBhPyhhPTEvYSxlWzBdPXMqYSxlWzFdPS1yKmEsZVsyXT0taSphLGVbM109biphLGVbNF09KGkqdS1zKm8pKmEsZVs1XT0ocipvLW4qdSkqYSxlKTpudWxsfSxmLmRldGVybWluYW50PWZ1bmN0aW9uKGUpe3JldHVybiBlWzBdKmVbM10tZVsxXSplWzJdfSxmLm11bHRpcGx5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9dFs0XSxhPXRbNV0sZj1uWzBdLGw9blsxXSxjPW5bMl0saD1uWzNdLHA9bls0XSxkPW5bNV07cmV0dXJuIGVbMF09cipmK2kqYyxlWzFdPXIqbCtpKmgsZVsyXT1zKmYrbypjLGVbM109cypsK28qaCxlWzRdPWYqdStjKmErcCxlWzVdPWwqdStoKmErZCxlfSxmLm11bD1mLm11bHRpcGx5LGYucm90YXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9dFs0XSxhPXRbNV0sZj1NYXRoLnNpbihuKSxsPU1hdGguY29zKG4pO3JldHVybiBlWzBdPXIqbCtpKmYsZVsxXT0tcipmK2kqbCxlWzJdPXMqbCtvKmYsZVszXT0tcypmK2wqbyxlWzRdPWwqdStmKmEsZVs1XT1sKmEtZip1LGV9LGYuc2NhbGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW5bMF0saT1uWzFdO3JldHVybiBlWzBdPXRbMF0qcixlWzFdPXRbMV0qaSxlWzJdPXRbMl0qcixlWzNdPXRbM10qaSxlWzRdPXRbNF0qcixlWzVdPXRbNV0qaSxlfSxmLnRyYW5zbGF0ZT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGVbM109dFszXSxlWzRdPXRbNF0rblswXSxlWzVdPXRbNV0rblsxXSxlfSxmLnN0cj1mdW5jdGlvbihlKXtyZXR1cm5cIm1hdDJkKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIsIFwiK2VbMl0rXCIsIFwiK2VbM10rXCIsIFwiK2VbNF0rXCIsIFwiK2VbNV0rXCIpXCJ9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS5tYXQyZD1mKTt2YXIgbD17fTtsLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKDkpO3JldHVybiBlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTAsZVs0XT0xLGVbNV09MCxlWzZdPTAsZVs3XT0wLGVbOF09MSxlfSxsLmZyb21NYXQ0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGVbM109dFs0XSxlWzRdPXRbNV0sZVs1XT10WzZdLGVbNl09dFs4XSxlWzddPXRbOV0sZVs4XT10WzEwXSxlfSxsLmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuKDkpO3JldHVybiB0WzBdPWVbMF0sdFsxXT1lWzFdLHRbMl09ZVsyXSx0WzNdPWVbM10sdFs0XT1lWzRdLHRbNV09ZVs1XSx0WzZdPWVbNl0sdFs3XT1lWzddLHRbOF09ZVs4XSx0fSxsLmNvcHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZVszXT10WzNdLGVbNF09dFs0XSxlWzVdPXRbNV0sZVs2XT10WzZdLGVbN109dFs3XSxlWzhdPXRbOF0sZX0sbC5pZGVudGl0eT1mdW5jdGlvbihlKXtyZXR1cm4gZVswXT0xLGVbMV09MCxlWzJdPTAsZVszXT0wLGVbNF09MSxlWzVdPTAsZVs2XT0wLGVbN109MCxlWzhdPTEsZX0sbC50cmFuc3Bvc2U9ZnVuY3Rpb24oZSx0KXtpZihlPT09dCl7dmFyIG49dFsxXSxyPXRbMl0saT10WzVdO2VbMV09dFszXSxlWzJdPXRbNl0sZVszXT1uLGVbNV09dFs3XSxlWzZdPXIsZVs3XT1pfWVsc2UgZVswXT10WzBdLGVbMV09dFszXSxlWzJdPXRbNl0sZVszXT10WzFdLGVbNF09dFs0XSxlWzVdPXRbN10sZVs2XT10WzJdLGVbN109dFs1XSxlWzhdPXRbOF07cmV0dXJuIGV9LGwuaW52ZXJ0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPXRbNF0sdT10WzVdLGE9dFs2XSxmPXRbN10sbD10WzhdLGM9bCpvLXUqZixoPS1sKnMrdSphLHA9ZipzLW8qYSxkPW4qYytyKmgraSpwO3JldHVybiBkPyhkPTEvZCxlWzBdPWMqZCxlWzFdPSgtbCpyK2kqZikqZCxlWzJdPSh1KnItaSpvKSpkLGVbM109aCpkLGVbNF09KGwqbi1pKmEpKmQsZVs1XT0oLXUqbitpKnMpKmQsZVs2XT1wKmQsZVs3XT0oLWYqbityKmEpKmQsZVs4XT0obypuLXIqcykqZCxlKTpudWxsfSxsLmFkam9pbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89dFs0XSx1PXRbNV0sYT10WzZdLGY9dFs3XSxsPXRbOF07cmV0dXJuIGVbMF09bypsLXUqZixlWzFdPWkqZi1yKmwsZVsyXT1yKnUtaSpvLGVbM109dSphLXMqbCxlWzRdPW4qbC1pKmEsZVs1XT1pKnMtbip1LGVbNl09cypmLW8qYSxlWzddPXIqYS1uKmYsZVs4XT1uKm8tcipzLGV9LGwuZGV0ZXJtaW5hbnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV0scj1lWzJdLGk9ZVszXSxzPWVbNF0sbz1lWzVdLHU9ZVs2XSxhPWVbN10sZj1lWzhdO3JldHVybiB0KihmKnMtbyphKStuKigtZippK28qdSkrciooYSppLXMqdSl9LGwubXVsdGlwbHk9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT10WzRdLGE9dFs1XSxmPXRbNl0sbD10WzddLGM9dFs4XSxoPW5bMF0scD1uWzFdLGQ9blsyXSx2PW5bM10sbT1uWzRdLGc9bls1XSx5PW5bNl0sYj1uWzddLHc9bls4XTtyZXR1cm4gZVswXT1oKnIrcCpvK2QqZixlWzFdPWgqaStwKnUrZCpsLGVbMl09aCpzK3AqYStkKmMsZVszXT12KnIrbSpvK2cqZixlWzRdPXYqaSttKnUrZypsLGVbNV09dipzK20qYStnKmMsZVs2XT15KnIrYipvK3cqZixlWzddPXkqaStiKnUrdypsLGVbOF09eSpzK2IqYSt3KmMsZX0sbC5tdWw9bC5tdWx0aXBseSxsLnRyYW5zbGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PXRbNF0sYT10WzVdLGY9dFs2XSxsPXRbN10sYz10WzhdLGg9blswXSxwPW5bMV07cmV0dXJuIGVbMF09cixlWzFdPWksZVsyXT1zLGVbM109byxlWzRdPXUsZVs1XT1hLGVbNl09aCpyK3AqbytmLGVbN109aCppK3AqdStsLGVbOF09aCpzK3AqYStjLGV9LGwucm90YXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9dFs0XSxhPXRbNV0sZj10WzZdLGw9dFs3XSxjPXRbOF0saD1NYXRoLnNpbihuKSxwPU1hdGguY29zKG4pO3JldHVybiBlWzBdPXAqcitoKm8sZVsxXT1wKmkraCp1LGVbMl09cCpzK2gqYSxlWzNdPXAqby1oKnIsZVs0XT1wKnUtaCppLGVbNV09cCphLWgqcyxlWzZdPWYsZVs3XT1sLGVbOF09YyxlfSxsLnNjYWxlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1uWzBdLGk9blsxXTtyZXR1cm4gZVswXT1yKnRbMF0sZVsxXT1yKnRbMV0sZVsyXT1yKnRbMl0sZVszXT1pKnRbM10sZVs0XT1pKnRbNF0sZVs1XT1pKnRbNV0sZVs2XT10WzZdLGVbN109dFs3XSxlWzhdPXRbOF0sZX0sbC5mcm9tTWF0MmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPTAsZVszXT10WzJdLGVbNF09dFszXSxlWzVdPTAsZVs2XT10WzRdLGVbN109dFs1XSxlWzhdPTEsZX0sbC5mcm9tUXVhdD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz1uK24sdT1yK3IsYT1pK2ksZj1uKm8sbD1uKnUsYz1uKmEsaD1yKnUscD1yKmEsZD1pKmEsdj1zKm8sbT1zKnUsZz1zKmE7cmV0dXJuIGVbMF09MS0oaCtkKSxlWzNdPWwrZyxlWzZdPWMtbSxlWzFdPWwtZyxlWzRdPTEtKGYrZCksZVs3XT1wK3YsZVsyXT1jK20sZVs1XT1wLXYsZVs4XT0xLShmK2gpLGV9LGwubm9ybWFsRnJvbU1hdDQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89dFs0XSx1PXRbNV0sYT10WzZdLGY9dFs3XSxsPXRbOF0sYz10WzldLGg9dFsxMF0scD10WzExXSxkPXRbMTJdLHY9dFsxM10sbT10WzE0XSxnPXRbMTVdLHk9bip1LXIqbyxiPW4qYS1pKm8sdz1uKmYtcypvLEU9ciphLWkqdSxTPXIqZi1zKnUseD1pKmYtcyphLFQ9bCp2LWMqZCxOPWwqbS1oKmQsQz1sKmctcCpkLGs9YyptLWgqdixMPWMqZy1wKnYsQT1oKmctcCptLE89eSpBLWIqTCt3KmsrRSpDLVMqTit4KlQ7cmV0dXJuIE8/KE89MS9PLGVbMF09KHUqQS1hKkwrZiprKSpPLGVbMV09KGEqQy1vKkEtZipOKSpPLGVbMl09KG8qTC11KkMrZipUKSpPLGVbM109KGkqTC1yKkEtcyprKSpPLGVbNF09KG4qQS1pKkMrcypOKSpPLGVbNV09KHIqQy1uKkwtcypUKSpPLGVbNl09KHYqeC1tKlMrZypFKSpPLGVbN109KG0qdy1kKngtZypiKSpPLGVbOF09KGQqUy12KncrZyp5KSpPLGUpOm51bGx9LGwuc3RyPWZ1bmN0aW9uKGUpe3JldHVyblwibWF0MyhcIitlWzBdK1wiLCBcIitlWzFdK1wiLCBcIitlWzJdK1wiLCBcIitlWzNdK1wiLCBcIitlWzRdK1wiLCBcIitlWzVdK1wiLCBcIitlWzZdK1wiLCBcIitlWzddK1wiLCBcIitlWzhdK1wiKVwifSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUubWF0Mz1sKTt2YXIgYz17fTtjLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKDE2KTtyZXR1cm4gZVswXT0xLGVbMV09MCxlWzJdPTAsZVszXT0wLGVbNF09MCxlWzVdPTEsZVs2XT0wLGVbN109MCxlWzhdPTAsZVs5XT0wLGVbMTBdPTEsZVsxMV09MCxlWzEyXT0wLGVbMTNdPTAsZVsxNF09MCxlWzE1XT0xLGV9LGMuY2xvbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG4oMTYpO3JldHVybiB0WzBdPWVbMF0sdFsxXT1lWzFdLHRbMl09ZVsyXSx0WzNdPWVbM10sdFs0XT1lWzRdLHRbNV09ZVs1XSx0WzZdPWVbNl0sdFs3XT1lWzddLHRbOF09ZVs4XSx0WzldPWVbOV0sdFsxMF09ZVsxMF0sdFsxMV09ZVsxMV0sdFsxMl09ZVsxMl0sdFsxM109ZVsxM10sdFsxNF09ZVsxNF0sdFsxNV09ZVsxNV0sdH0sYy5jb3B5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGVbM109dFszXSxlWzRdPXRbNF0sZVs1XT10WzVdLGVbNl09dFs2XSxlWzddPXRbN10sZVs4XT10WzhdLGVbOV09dFs5XSxlWzEwXT10WzEwXSxlWzExXT10WzExXSxlWzEyXT10WzEyXSxlWzEzXT10WzEzXSxlWzE0XT10WzE0XSxlWzE1XT10WzE1XSxlfSxjLmlkZW50aXR5PWZ1bmN0aW9uKGUpe3JldHVybiBlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTAsZVs0XT0wLGVbNV09MSxlWzZdPTAsZVs3XT0wLGVbOF09MCxlWzldPTAsZVsxMF09MSxlWzExXT0wLGVbMTJdPTAsZVsxM109MCxlWzE0XT0wLGVbMTVdPTEsZX0sYy50cmFuc3Bvc2U9ZnVuY3Rpb24oZSx0KXtpZihlPT09dCl7dmFyIG49dFsxXSxyPXRbMl0saT10WzNdLHM9dFs2XSxvPXRbN10sdT10WzExXTtlWzFdPXRbNF0sZVsyXT10WzhdLGVbM109dFsxMl0sZVs0XT1uLGVbNl09dFs5XSxlWzddPXRbMTNdLGVbOF09cixlWzldPXMsZVsxMV09dFsxNF0sZVsxMl09aSxlWzEzXT1vLGVbMTRdPXV9ZWxzZSBlWzBdPXRbMF0sZVsxXT10WzRdLGVbMl09dFs4XSxlWzNdPXRbMTJdLGVbNF09dFsxXSxlWzVdPXRbNV0sZVs2XT10WzldLGVbN109dFsxM10sZVs4XT10WzJdLGVbOV09dFs2XSxlWzEwXT10WzEwXSxlWzExXT10WzE0XSxlWzEyXT10WzNdLGVbMTNdPXRbN10sZVsxNF09dFsxMV0sZVsxNV09dFsxNV07cmV0dXJuIGV9LGMuaW52ZXJ0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPXRbNF0sdT10WzVdLGE9dFs2XSxmPXRbN10sbD10WzhdLGM9dFs5XSxoPXRbMTBdLHA9dFsxMV0sZD10WzEyXSx2PXRbMTNdLG09dFsxNF0sZz10WzE1XSx5PW4qdS1yKm8sYj1uKmEtaSpvLHc9bipmLXMqbyxFPXIqYS1pKnUsUz1yKmYtcyp1LHg9aSpmLXMqYSxUPWwqdi1jKmQsTj1sKm0taCpkLEM9bCpnLXAqZCxrPWMqbS1oKnYsTD1jKmctcCp2LEE9aCpnLXAqbSxPPXkqQS1iKkwrdyprK0UqQy1TKk4reCpUO3JldHVybiBPPyhPPTEvTyxlWzBdPSh1KkEtYSpMK2YqaykqTyxlWzFdPShpKkwtcipBLXMqaykqTyxlWzJdPSh2KngtbSpTK2cqRSkqTyxlWzNdPShoKlMtYyp4LXAqRSkqTyxlWzRdPShhKkMtbypBLWYqTikqTyxlWzVdPShuKkEtaSpDK3MqTikqTyxlWzZdPShtKnctZCp4LWcqYikqTyxlWzddPShsKngtaCp3K3AqYikqTyxlWzhdPShvKkwtdSpDK2YqVCkqTyxlWzldPShyKkMtbipMLXMqVCkqTyxlWzEwXT0oZCpTLXYqdytnKnkpKk8sZVsxMV09KGMqdy1sKlMtcCp5KSpPLGVbMTJdPSh1Kk4tbyprLWEqVCkqTyxlWzEzXT0obiprLXIqTitpKlQpKk8sZVsxNF09KHYqYi1kKkUtbSp5KSpPLGVbMTVdPShsKkUtYypiK2gqeSkqTyxlKTpudWxsfSxjLmFkam9pbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89dFs0XSx1PXRbNV0sYT10WzZdLGY9dFs3XSxsPXRbOF0sYz10WzldLGg9dFsxMF0scD10WzExXSxkPXRbMTJdLHY9dFsxM10sbT10WzE0XSxnPXRbMTVdO3JldHVybiBlWzBdPXUqKGgqZy1wKm0pLWMqKGEqZy1mKm0pK3YqKGEqcC1mKmgpLGVbMV09LShyKihoKmctcCptKS1jKihpKmctcyptKSt2KihpKnAtcypoKSksZVsyXT1yKihhKmctZiptKS11KihpKmctcyptKSt2KihpKmYtcyphKSxlWzNdPS0ociooYSpwLWYqaCktdSooaSpwLXMqaCkrYyooaSpmLXMqYSkpLGVbNF09LShvKihoKmctcCptKS1sKihhKmctZiptKStkKihhKnAtZipoKSksZVs1XT1uKihoKmctcCptKS1sKihpKmctcyptKStkKihpKnAtcypoKSxlWzZdPS0obiooYSpnLWYqbSktbyooaSpnLXMqbSkrZCooaSpmLXMqYSkpLGVbN109biooYSpwLWYqaCktbyooaSpwLXMqaCkrbCooaSpmLXMqYSksZVs4XT1vKihjKmctcCp2KS1sKih1KmctZip2KStkKih1KnAtZipjKSxlWzldPS0obiooYypnLXAqdiktbCoocipnLXMqdikrZCoocipwLXMqYykpLGVbMTBdPW4qKHUqZy1mKnYpLW8qKHIqZy1zKnYpK2QqKHIqZi1zKnUpLGVbMTFdPS0obioodSpwLWYqYyktbyoocipwLXMqYykrbCoocipmLXMqdSkpLGVbMTJdPS0obyooYyptLWgqdiktbCoodSptLWEqdikrZCoodSpoLWEqYykpLGVbMTNdPW4qKGMqbS1oKnYpLWwqKHIqbS1pKnYpK2QqKHIqaC1pKmMpLGVbMTRdPS0obioodSptLWEqdiktbyoociptLWkqdikrZCoociphLWkqdSkpLGVbMTVdPW4qKHUqaC1hKmMpLW8qKHIqaC1pKmMpK2wqKHIqYS1pKnUpLGV9LGMuZGV0ZXJtaW5hbnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV0scj1lWzJdLGk9ZVszXSxzPWVbNF0sbz1lWzVdLHU9ZVs2XSxhPWVbN10sZj1lWzhdLGw9ZVs5XSxjPWVbMTBdLGg9ZVsxMV0scD1lWzEyXSxkPWVbMTNdLHY9ZVsxNF0sbT1lWzE1XSxnPXQqby1uKnMseT10KnUtcipzLGI9dCphLWkqcyx3PW4qdS1yKm8sRT1uKmEtaSpvLFM9ciphLWkqdSx4PWYqZC1sKnAsVD1mKnYtYypwLE49ZiptLWgqcCxDPWwqdi1jKmQsaz1sKm0taCpkLEw9YyptLWgqdjtyZXR1cm4gZypMLXkqaytiKkMrdypOLUUqVCtTKnh9LGMubXVsdGlwbHk9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT10WzRdLGE9dFs1XSxmPXRbNl0sbD10WzddLGM9dFs4XSxoPXRbOV0scD10WzEwXSxkPXRbMTFdLHY9dFsxMl0sbT10WzEzXSxnPXRbMTRdLHk9dFsxNV0sYj1uWzBdLHc9blsxXSxFPW5bMl0sUz1uWzNdO3JldHVybiBlWzBdPWIqcit3KnUrRSpjK1MqdixlWzFdPWIqaSt3KmErRSpoK1MqbSxlWzJdPWIqcyt3KmYrRSpwK1MqZyxlWzNdPWIqbyt3KmwrRSpkK1MqeSxiPW5bNF0sdz1uWzVdLEU9bls2XSxTPW5bN10sZVs0XT1iKnIrdyp1K0UqYytTKnYsZVs1XT1iKmkrdyphK0UqaCtTKm0sZVs2XT1iKnMrdypmK0UqcCtTKmcsZVs3XT1iKm8rdypsK0UqZCtTKnksYj1uWzhdLHc9bls5XSxFPW5bMTBdLFM9blsxMV0sZVs4XT1iKnIrdyp1K0UqYytTKnYsZVs5XT1iKmkrdyphK0UqaCtTKm0sZVsxMF09YipzK3cqZitFKnArUypnLGVbMTFdPWIqbyt3KmwrRSpkK1MqeSxiPW5bMTJdLHc9blsxM10sRT1uWzE0XSxTPW5bMTVdLGVbMTJdPWIqcit3KnUrRSpjK1MqdixlWzEzXT1iKmkrdyphK0UqaCtTKm0sZVsxNF09YipzK3cqZitFKnArUypnLGVbMTVdPWIqbyt3KmwrRSpkK1MqeSxlfSxjLm11bD1jLm11bHRpcGx5LGMudHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1uWzBdLGk9blsxXSxzPW5bMl0sbyx1LGEsZixsLGMsaCxwLGQsdixtLGc7cmV0dXJuIHQ9PT1lPyhlWzEyXT10WzBdKnIrdFs0XSppK3RbOF0qcyt0WzEyXSxlWzEzXT10WzFdKnIrdFs1XSppK3RbOV0qcyt0WzEzXSxlWzE0XT10WzJdKnIrdFs2XSppK3RbMTBdKnMrdFsxNF0sZVsxNV09dFszXSpyK3RbN10qaSt0WzExXSpzK3RbMTVdKToobz10WzBdLHU9dFsxXSxhPXRbMl0sZj10WzNdLGw9dFs0XSxjPXRbNV0saD10WzZdLHA9dFs3XSxkPXRbOF0sdj10WzldLG09dFsxMF0sZz10WzExXSxlWzBdPW8sZVsxXT11LGVbMl09YSxlWzNdPWYsZVs0XT1sLGVbNV09YyxlWzZdPWgsZVs3XT1wLGVbOF09ZCxlWzldPXYsZVsxMF09bSxlWzExXT1nLGVbMTJdPW8qcitsKmkrZCpzK3RbMTJdLGVbMTNdPXUqcitjKmkrdipzK3RbMTNdLGVbMTRdPWEqcitoKmkrbSpzK3RbMTRdLGVbMTVdPWYqcitwKmkrZypzK3RbMTVdKSxlfSxjLnNjYWxlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1uWzBdLGk9blsxXSxzPW5bMl07cmV0dXJuIGVbMF09dFswXSpyLGVbMV09dFsxXSpyLGVbMl09dFsyXSpyLGVbM109dFszXSpyLGVbNF09dFs0XSppLGVbNV09dFs1XSppLGVbNl09dFs2XSppLGVbN109dFs3XSppLGVbOF09dFs4XSpzLGVbOV09dFs5XSpzLGVbMTBdPXRbMTBdKnMsZVsxMV09dFsxMV0qcyxlWzEyXT10WzEyXSxlWzEzXT10WzEzXSxlWzE0XT10WzE0XSxlWzE1XT10WzE1XSxlfSxjLnJvdGF0ZT1mdW5jdGlvbihlLG4scixpKXt2YXIgcz1pWzBdLG89aVsxXSx1PWlbMl0sYT1NYXRoLnNxcnQocypzK28qbyt1KnUpLGYsbCxjLGgscCxkLHYsbSxnLHksYix3LEUsUyx4LFQsTixDLGssTCxBLE8sTSxfO3JldHVybiBNYXRoLmFicyhhKTx0P251bGw6KGE9MS9hLHMqPWEsbyo9YSx1Kj1hLGY9TWF0aC5zaW4ociksbD1NYXRoLmNvcyhyKSxjPTEtbCxoPW5bMF0scD1uWzFdLGQ9blsyXSx2PW5bM10sbT1uWzRdLGc9bls1XSx5PW5bNl0sYj1uWzddLHc9bls4XSxFPW5bOV0sUz1uWzEwXSx4PW5bMTFdLFQ9cypzKmMrbCxOPW8qcypjK3UqZixDPXUqcypjLW8qZixrPXMqbypjLXUqZixMPW8qbypjK2wsQT11Km8qYytzKmYsTz1zKnUqYytvKmYsTT1vKnUqYy1zKmYsXz11KnUqYytsLGVbMF09aCpUK20qTit3KkMsZVsxXT1wKlQrZypOK0UqQyxlWzJdPWQqVCt5Kk4rUypDLGVbM109dipUK2IqTit4KkMsZVs0XT1oKmsrbSpMK3cqQSxlWzVdPXAqaytnKkwrRSpBLGVbNl09ZCprK3kqTCtTKkEsZVs3XT12KmsrYipMK3gqQSxlWzhdPWgqTyttKk0rdypfLGVbOV09cCpPK2cqTStFKl8sZVsxMF09ZCpPK3kqTStTKl8sZVsxMV09dipPK2IqTSt4Kl8sbiE9PWUmJihlWzEyXT1uWzEyXSxlWzEzXT1uWzEzXSxlWzE0XT1uWzE0XSxlWzE1XT1uWzE1XSksZSl9LGMucm90YXRlWD1mdW5jdGlvbihlLHQsbil7dmFyIHI9TWF0aC5zaW4obiksaT1NYXRoLmNvcyhuKSxzPXRbNF0sbz10WzVdLHU9dFs2XSxhPXRbN10sZj10WzhdLGw9dFs5XSxjPXRbMTBdLGg9dFsxMV07cmV0dXJuIHQhPT1lJiYoZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZVszXT10WzNdLGVbMTJdPXRbMTJdLGVbMTNdPXRbMTNdLGVbMTRdPXRbMTRdLGVbMTVdPXRbMTVdKSxlWzRdPXMqaStmKnIsZVs1XT1vKmkrbCpyLGVbNl09dSppK2MqcixlWzddPWEqaStoKnIsZVs4XT1mKmktcypyLGVbOV09bCppLW8qcixlWzEwXT1jKmktdSpyLGVbMTFdPWgqaS1hKnIsZX0sYy5yb3RhdGVZPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1NYXRoLnNpbihuKSxpPU1hdGguY29zKG4pLHM9dFswXSxvPXRbMV0sdT10WzJdLGE9dFszXSxmPXRbOF0sbD10WzldLGM9dFsxMF0saD10WzExXTtyZXR1cm4gdCE9PWUmJihlWzRdPXRbNF0sZVs1XT10WzVdLGVbNl09dFs2XSxlWzddPXRbN10sZVsxMl09dFsxMl0sZVsxM109dFsxM10sZVsxNF09dFsxNF0sZVsxNV09dFsxNV0pLGVbMF09cyppLWYqcixlWzFdPW8qaS1sKnIsZVsyXT11KmktYypyLGVbM109YSppLWgqcixlWzhdPXMqcitmKmksZVs5XT1vKnIrbCppLGVbMTBdPXUqcitjKmksZVsxMV09YSpyK2gqaSxlfSxjLnJvdGF0ZVo9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPU1hdGguc2luKG4pLGk9TWF0aC5jb3Mobikscz10WzBdLG89dFsxXSx1PXRbMl0sYT10WzNdLGY9dFs0XSxsPXRbNV0sYz10WzZdLGg9dFs3XTtyZXR1cm4gdCE9PWUmJihlWzhdPXRbOF0sZVs5XT10WzldLGVbMTBdPXRbMTBdLGVbMTFdPXRbMTFdLGVbMTJdPXRbMTJdLGVbMTNdPXRbMTNdLGVbMTRdPXRbMTRdLGVbMTVdPXRbMTVdKSxlWzBdPXMqaStmKnIsZVsxXT1vKmkrbCpyLGVbMl09dSppK2MqcixlWzNdPWEqaStoKnIsZVs0XT1mKmktcypyLGVbNV09bCppLW8qcixlWzZdPWMqaS11KnIsZVs3XT1oKmktYSpyLGV9LGMuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb249ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT1yK3IsYT1pK2ksZj1zK3MsbD1yKnUsYz1yKmEsaD1yKmYscD1pKmEsZD1pKmYsdj1zKmYsbT1vKnUsZz1vKmEseT1vKmY7cmV0dXJuIGVbMF09MS0ocCt2KSxlWzFdPWMreSxlWzJdPWgtZyxlWzNdPTAsZVs0XT1jLXksZVs1XT0xLShsK3YpLGVbNl09ZCttLGVbN109MCxlWzhdPWgrZyxlWzldPWQtbSxlWzEwXT0xLShsK3ApLGVbMTFdPTAsZVsxMl09blswXSxlWzEzXT1uWzFdLGVbMTRdPW5bMl0sZVsxNV09MSxlfSxjLmZyb21RdWF0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPW4rbix1PXIrcixhPWkraSxmPW4qbyxsPW4qdSxjPW4qYSxoPXIqdSxwPXIqYSxkPWkqYSx2PXMqbyxtPXMqdSxnPXMqYTtyZXR1cm4gZVswXT0xLShoK2QpLGVbMV09bCtnLGVbMl09Yy1tLGVbM109MCxlWzRdPWwtZyxlWzVdPTEtKGYrZCksZVs2XT1wK3YsZVs3XT0wLGVbOF09YyttLGVbOV09cC12LGVbMTBdPTEtKGYraCksZVsxMV09MCxlWzEyXT0wLGVbMTNdPTAsZVsxNF09MCxlWzE1XT0xLGV9LGMuZnJ1c3R1bT1mdW5jdGlvbihlLHQsbixyLGkscyxvKXt2YXIgdT0xLyhuLXQpLGE9MS8oaS1yKSxmPTEvKHMtbyk7cmV0dXJuIGVbMF09cyoyKnUsZVsxXT0wLGVbMl09MCxlWzNdPTAsZVs0XT0wLGVbNV09cyoyKmEsZVs2XT0wLGVbN109MCxlWzhdPShuK3QpKnUsZVs5XT0oaStyKSphLGVbMTBdPShvK3MpKmYsZVsxMV09LTEsZVsxMl09MCxlWzEzXT0wLGVbMTRdPW8qcyoyKmYsZVsxNV09MCxlfSxjLnBlcnNwZWN0aXZlPWZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIHM9MS9NYXRoLnRhbih0LzIpLG89MS8oci1pKTtyZXR1cm4gZVswXT1zL24sZVsxXT0wLGVbMl09MCxlWzNdPTAsZVs0XT0wLGVbNV09cyxlWzZdPTAsZVs3XT0wLGVbOF09MCxlWzldPTAsZVsxMF09KGkrcikqbyxlWzExXT0tMSxlWzEyXT0wLGVbMTNdPTAsZVsxNF09MippKnIqbyxlWzE1XT0wLGV9LGMub3J0aG89ZnVuY3Rpb24oZSx0LG4scixpLHMsbyl7dmFyIHU9MS8odC1uKSxhPTEvKHItaSksZj0xLyhzLW8pO3JldHVybiBlWzBdPS0yKnUsZVsxXT0wLGVbMl09MCxlWzNdPTAsZVs0XT0wLGVbNV09LTIqYSxlWzZdPTAsZVs3XT0wLGVbOF09MCxlWzldPTAsZVsxMF09MipmLGVbMTFdPTAsZVsxMl09KHQrbikqdSxlWzEzXT0oaStyKSphLGVbMTRdPShvK3MpKmYsZVsxNV09MSxlfSxjLmxvb2tBdD1mdW5jdGlvbihlLG4scixpKXt2YXIgcyxvLHUsYSxmLGwsaCxwLGQsdixtPW5bMF0sZz1uWzFdLHk9blsyXSxiPWlbMF0sdz1pWzFdLEU9aVsyXSxTPXJbMF0seD1yWzFdLFQ9clsyXTtyZXR1cm4gTWF0aC5hYnMobS1TKTx0JiZNYXRoLmFicyhnLXgpPHQmJk1hdGguYWJzKHktVCk8dD9jLmlkZW50aXR5KGUpOihoPW0tUyxwPWcteCxkPXktVCx2PTEvTWF0aC5zcXJ0KGgqaCtwKnArZCpkKSxoKj12LHAqPXYsZCo9dixzPXcqZC1FKnAsbz1FKmgtYipkLHU9YipwLXcqaCx2PU1hdGguc3FydChzKnMrbypvK3UqdSksdj8odj0xL3Yscyo9dixvKj12LHUqPXYpOihzPTAsbz0wLHU9MCksYT1wKnUtZCpvLGY9ZCpzLWgqdSxsPWgqby1wKnMsdj1NYXRoLnNxcnQoYSphK2YqZitsKmwpLHY/KHY9MS92LGEqPXYsZio9dixsKj12KTooYT0wLGY9MCxsPTApLGVbMF09cyxlWzFdPWEsZVsyXT1oLGVbM109MCxlWzRdPW8sZVs1XT1mLGVbNl09cCxlWzddPTAsZVs4XT11LGVbOV09bCxlWzEwXT1kLGVbMTFdPTAsZVsxMl09LShzKm0rbypnK3UqeSksZVsxM109LShhKm0rZipnK2wqeSksZVsxNF09LShoKm0rcCpnK2QqeSksZVsxNV09MSxlKX0sYy5zdHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJtYXQ0KFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIsIFwiK2VbMl0rXCIsIFwiK2VbM10rXCIsIFwiK2VbNF0rXCIsIFwiK2VbNV0rXCIsIFwiK2VbNl0rXCIsIFwiK2VbN10rXCIsIFwiK2VbOF0rXCIsIFwiK2VbOV0rXCIsIFwiK2VbMTBdK1wiLCBcIitlWzExXStcIiwgXCIrZVsxMl0rXCIsIFwiK2VbMTNdK1wiLCBcIitlWzE0XStcIiwgXCIrZVsxNV0rXCIpXCJ9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS5tYXQ0PWMpO3ZhciBoPXt9O2guY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oNCk7cmV0dXJuIGVbMF09MCxlWzFdPTAsZVsyXT0wLGVbM109MSxlfSxoLnJvdGF0aW9uVG89ZnVuY3Rpb24oKXt2YXIgZT1vLmNyZWF0ZSgpLHQ9by5mcm9tVmFsdWVzKDEsMCwwKSxuPW8uZnJvbVZhbHVlcygwLDEsMCk7cmV0dXJuIGZ1bmN0aW9uKHIsaSxzKXt2YXIgdT1vLmRvdChpLHMpO3JldHVybiB1PC0wLjk5OTk5OT8oby5jcm9zcyhlLHQsaSksby5sZW5ndGgoZSk8MWUtNiYmby5jcm9zcyhlLG4saSksby5ub3JtYWxpemUoZSxlKSxoLnNldEF4aXNBbmdsZShyLGUsTWF0aC5QSSkscik6dT4uOTk5OTk5PyhyWzBdPTAsclsxXT0wLHJbMl09MCxyWzNdPTEscik6KG8uY3Jvc3MoZSxpLHMpLHJbMF09ZVswXSxyWzFdPWVbMV0sclsyXT1lWzJdLHJbM109MSt1LGgubm9ybWFsaXplKHIscikpfX0oKSxoLnNldEF4ZXM9ZnVuY3Rpb24oKXt2YXIgZT1sLmNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbih0LG4scixpKXtyZXR1cm4gZVswXT1yWzBdLGVbM109clsxXSxlWzZdPXJbMl0sZVsxXT1pWzBdLGVbNF09aVsxXSxlWzddPWlbMl0sZVsyXT1uWzBdLGVbNV09blsxXSxlWzhdPW5bMl0saC5ub3JtYWxpemUodCxoLmZyb21NYXQzKHQsZSkpfX0oKSxoLmNsb25lPXUuY2xvbmUsaC5mcm9tVmFsdWVzPXUuZnJvbVZhbHVlcyxoLmNvcHk9dS5jb3B5LGguc2V0PXUuc2V0LGguaWRlbnRpdHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF09MCxlWzFdPTAsZVsyXT0wLGVbM109MSxlfSxoLnNldEF4aXNBbmdsZT1mdW5jdGlvbihlLHQsbil7bio9LjU7dmFyIHI9TWF0aC5zaW4obik7cmV0dXJuIGVbMF09cip0WzBdLGVbMV09cip0WzFdLGVbMl09cip0WzJdLGVbM109TWF0aC5jb3MobiksZX0saC5hZGQ9dS5hZGQsaC5tdWx0aXBseT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PW5bMF0sYT1uWzFdLGY9blsyXSxsPW5bM107cmV0dXJuIGVbMF09cipsK28qdStpKmYtcyphLGVbMV09aSpsK28qYStzKnUtcipmLGVbMl09cypsK28qZityKmEtaSp1LGVbM109bypsLXIqdS1pKmEtcypmLGV9LGgubXVsPWgubXVsdGlwbHksaC5zY2FsZT11LnNjYWxlLGgucm90YXRlWD1mdW5jdGlvbihlLHQsbil7bio9LjU7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PU1hdGguc2luKG4pLGE9TWF0aC5jb3Mobik7cmV0dXJuIGVbMF09ciphK28qdSxlWzFdPWkqYStzKnUsZVsyXT1zKmEtaSp1LGVbM109byphLXIqdSxlfSxoLnJvdGF0ZVk9ZnVuY3Rpb24oZSx0LG4pe24qPS41O3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT1NYXRoLnNpbihuKSxhPU1hdGguY29zKG4pO3JldHVybiBlWzBdPXIqYS1zKnUsZVsxXT1pKmErbyp1LGVbMl09cyphK3IqdSxlWzNdPW8qYS1pKnUsZX0saC5yb3RhdGVaPWZ1bmN0aW9uKGUsdCxuKXtuKj0uNTt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9TWF0aC5zaW4obiksYT1NYXRoLmNvcyhuKTtyZXR1cm4gZVswXT1yKmEraSp1LGVbMV09aSphLXIqdSxlWzJdPXMqYStvKnUsZVszXT1vKmEtcyp1LGV9LGguY2FsY3VsYXRlVz1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXTtyZXR1cm4gZVswXT1uLGVbMV09cixlWzJdPWksZVszXT0tTWF0aC5zcXJ0KE1hdGguYWJzKDEtbipuLXIqci1pKmkpKSxlfSxoLmRvdD11LmRvdCxoLmxlcnA9dS5sZXJwLGguc2xlcnA9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9dFswXSxzPXRbMV0sbz10WzJdLHU9dFszXSxhPW5bMF0sZj1uWzFdLGw9blsyXSxjPW5bM10saCxwLGQsdixtO3JldHVybiBwPWkqYStzKmYrbypsK3UqYyxwPDAmJihwPS1wLGE9LWEsZj0tZixsPS1sLGM9LWMpLDEtcD4xZS02PyhoPU1hdGguYWNvcyhwKSxkPU1hdGguc2luKGgpLHY9TWF0aC5zaW4oKDEtcikqaCkvZCxtPU1hdGguc2luKHIqaCkvZCk6KHY9MS1yLG09ciksZVswXT12KmkrbSphLGVbMV09dipzK20qZixlWzJdPXYqbyttKmwsZVszXT12KnUrbSpjLGV9LGguaW52ZXJ0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPW4qbityKnIraSppK3Mqcyx1PW8/MS9vOjA7cmV0dXJuIGVbMF09LW4qdSxlWzFdPS1yKnUsZVsyXT0taSp1LGVbM109cyp1LGV9LGguY29uanVnYXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09LXRbMF0sZVsxXT0tdFsxXSxlWzJdPS10WzJdLGVbM109dFszXSxlfSxoLmxlbmd0aD11Lmxlbmd0aCxoLmxlbj1oLmxlbmd0aCxoLnNxdWFyZWRMZW5ndGg9dS5zcXVhcmVkTGVuZ3RoLGguc3FyTGVuPWguc3F1YXJlZExlbmd0aCxoLm5vcm1hbGl6ZT11Lm5vcm1hbGl6ZSxoLmZyb21NYXQzPWZ1bmN0aW9uKCl7dmFyIGU9dHlwZW9mIEludDhBcnJheSE9XCJ1bmRlZmluZWRcIj9uZXcgSW50OEFycmF5KFsxLDIsMF0pOlsxLDIsMF07cmV0dXJuIGZ1bmN0aW9uKHQsbil7dmFyIHI9blswXStuWzRdK25bOF0saTtpZihyPjApaT1NYXRoLnNxcnQocisxKSx0WzNdPS41KmksaT0uNS9pLHRbMF09KG5bN10tbls1XSkqaSx0WzFdPShuWzJdLW5bNl0pKmksdFsyXT0oblszXS1uWzFdKSppO2Vsc2V7dmFyIHM9MDtuWzRdPm5bMF0mJihzPTEpLG5bOF0+bltzKjMrc10mJihzPTIpO3ZhciBvPWVbc10sdT1lW29dO2k9TWF0aC5zcXJ0KG5bcyozK3NdLW5bbyozK29dLW5bdSozK3VdKzEpLHRbc109LjUqaSxpPS41L2ksdFszXT0oblt1KjMrb10tbltvKjMrdV0pKmksdFtvXT0obltvKjMrc10rbltzKjMrb10pKmksdFt1XT0oblt1KjMrc10rbltzKjMrdV0pKml9cmV0dXJuIHR9fSgpLGguc3RyPWZ1bmN0aW9uKGUpe3JldHVyblwicXVhdChcIitlWzBdK1wiLCBcIitlWzFdK1wiLCBcIitlWzJdK1wiLCBcIitlWzNdK1wiKVwifSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUucXVhdD1oKX0odC5leHBvcnRzKX0pKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuZXcgKHJlcXVpcmUoJy4vc291cmNlL3dvcmtlci5qcycpKShzZWxmKTtcbn0gZWxzZSB7XG4gICAgLy8ganNoaW50IC1XMDc5XG4gICAgdmFyIG1hcGJveGdsID0gbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubWFwYm94Z2wgPSB7fTtcblxuICAgIG1hcGJveGdsLk1hcCA9IHJlcXVpcmUoJy4vdWkvbWFwLmpzJyk7XG4gICAgbWFwYm94Z2wuTmF2aWdhdGlvbiA9IHJlcXVpcmUoJy4vdWkvY29udHJvbC9uYXZpZ2F0aW9uLmpzJyk7XG4gICAgbWFwYm94Z2wuQXR0cmlidXRpb24gPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvYXR0cmlidXRpb24uanMnKTtcblxuICAgIG1hcGJveGdsLlNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlL3NvdXJjZScpO1xuICAgIG1hcGJveGdsLkdlb0pTT05Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS9nZW9qc29uc291cmNlJyk7XG4gICAgbWFwYm94Z2wuVmlkZW9Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS92aWRlb3NvdXJjZScpO1xuXG4gICAgbWFwYm94Z2wuU3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlL3N0eWxlLmpzJyk7XG5cbiAgICBtYXBib3hnbC5MYXRMbmcgPSByZXF1aXJlKCcuL2dlby9sYXRsbmcuanMnKTtcbiAgICBtYXBib3hnbC5MYXRMbmdCb3VuZHMgPSByZXF1aXJlKCcuL2dlby9sYXRsbmdib3VuZHMuanMnKTtcbiAgICBtYXBib3hnbC5Qb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbiAgICBtYXBib3hnbC5FdmVudGVkID0gcmVxdWlyZSgnLi91dGlsL2V2ZW50ZWQuanMnKTtcbiAgICBtYXBib3hnbC51dGlsID0gcmVxdWlyZSgnLi91dGlsL3V0aWwuanMnKTtcblxuICAgIHZhciBicm93c2VyID0gcmVxdWlyZSgnLi91dGlsL2Jyb3dzZXIuanMnKTtcbiAgICBtYXBib3hnbC51dGlsLnN1cHBvcnRlZCA9IGJyb3dzZXIuc3VwcG9ydGVkO1xuXG4gICAgdmFyIGFqYXggPSByZXF1aXJlKCcuL3V0aWwvYWpheC5qcycpO1xuICAgIG1hcGJveGdsLnV0aWwuZ2V0SlNPTiA9IGFqYXguZ2V0SlNPTjtcbiAgICBtYXBib3hnbC51dGlsLmdldEFycmF5QnVmZmVyID0gYWpheC5nZXRBcnJheUJ1ZmZlcjtcblxuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL3V0aWwvY29uZmlnLmpzJyk7XG4gICAgbWFwYm94Z2wuY29uZmlnID0gY29uZmlnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcGJveGdsLCAnYWNjZXNzVG9rZW4nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBjb25maWcuQUNDRVNTX1RPS0VOOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRva2VuKSB7IGNvbmZpZy5BQ0NFU1NfVE9LRU4gPSB0b2tlbjsgfVxuICAgIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0MyA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLm1hdDM7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0JhY2tncm91bmQ7XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSkge1xuICAgIHZhciBjb2xvciA9IGxheWVyU3R5bGVbJ2JhY2tncm91bmQtY29sb3InXTtcbiAgICB2YXIgaW1hZ2UgPSBsYXllclN0eWxlWydiYWNrZ3JvdW5kLWltYWdlJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllclN0eWxlWydiYWNrZ3JvdW5kLW9wYWNpdHknXTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKGltYWdlKSB7XG4gICAgICAgIC8vIERyYXcgdGV4dHVyZSBmaWxsXG4gICAgICAgIHZhciBpbWFnZVBvcyA9IGltYWdlU3ByaXRlLmdldFBvc2l0aW9uKGltYWdlLCB0cnVlKTtcbiAgICAgICAgaWYgKCFpbWFnZVBvcykgcmV0dXJuO1xuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIucGF0dGVyblNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcG9zTWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlLCAwKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsLCBpbWFnZVBvcy50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9iciwgaW1hZ2VQb3MuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWl4LCBwYWludGVyLnRyYW5zZm9ybS56b29tRnJhY3Rpb24pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHBhaW50ZXIudHJhbnNmb3JtO1xuICAgICAgICB2YXIgc2l6ZSA9IGltYWdlUG9zLnNpemU7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0cmFuc2Zvcm0ubG9jYXRpb25Db29yZGluYXRlKHRyYW5zZm9ybS5jZW50ZXIpO1xuICAgICAgICB2YXIgc2NhbGUgPSAxIC8gTWF0aC5wb3coMiwgdHJhbnNmb3JtLnpvb21GcmFjdGlvbik7XG4gICAgICAgIHZhciBtYXRyaXggPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgICAgIG1hdDMuc2NhbGUobWF0cml4LCBtYXRyaXgsIFsxIC8gc2l6ZVswXSwgMSAvIHNpemVbMV0sIDFdKTtcbiAgICAgICAgbWF0My50cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIFtcbiAgICAgICAgICAgIChjZW50ZXIuY29sdW1uICogdHJhbnNmb3JtLnRpbGVTaXplKSAlIHNpemVbMF0sXG4gICAgICAgICAgICAoY2VudGVyLnJvdyAgICAqIHRyYW5zZm9ybS50aWxlU2l6ZSkgJSBzaXplWzFdLFxuICAgICAgICAgICAgMFxuICAgICAgICBdKTtcbiAgICAgICAgbWF0My5yb3RhdGUobWF0cml4LCBtYXRyaXgsIC10cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeCwgbWF0cml4LCBbXG4gICAgICAgICAgICBzY2FsZSAqIHRyYW5zZm9ybS53aWR0aCAgLyAyLFxuICAgICAgICAgICAtc2NhbGUgKiB0cmFuc2Zvcm0uaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIDFcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudV9wYXR0ZXJubWF0cml4LCBmYWxzZSwgbWF0cml4KTtcblxuICAgICAgICBpbWFnZVNwcml0ZS5iaW5kKGdsLCB0cnVlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgZmlsbGluZyByZWN0YW5nbGUuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuZmlsbFNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcGFyYW1zLnBhZGRlZCB8fCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1Db3VudCk7XG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0ZXh0VmVydGljZXMgPSByZXF1aXJlKCcuLi9saWIvZGVidWd0ZXh0LmpzJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdEZWJ1ZztcblxuZnVuY3Rpb24gZHJhd0RlYnVnKGdsLCBwYWludGVyLCB0aWxlLCBwYXJhbXMpIHtcbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmRlYnVnU2hhZGVyLCBwYWludGVyLnRpbGUucG9zTWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xuXG4gICAgLy8gZHJhdyBib3VuZGluZyByZWN0YW5nbGVcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci5kZWJ1Z0J1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwYWludGVyLmRlYnVnU2hhZGVyLmFfcG9zLCBwYWludGVyLmRlYnVnQnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm00ZihwYWludGVyLmRlYnVnU2hhZGVyLnVfY29sb3IsIDEsIDAsIDAsIDEpO1xuICAgIGdsLmxpbmVXaWR0aCg0KTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVfU1RSSVAsIDAsIHBhaW50ZXIuZGVidWdCdWZmZXIuaXRlbUNvdW50KTtcblxuICAgIC8vIGRyYXcgdGlsZSBjb29yZGluYXRlXG4gICAgdmFyIGNvb3JkID0gcGFyYW1zLnogKyAnLycgKyBwYXJhbXMueCArICcvJyArIHBhcmFtcy55O1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGV4dFZlcnRpY2VzKGNvb3JkLCA1MCwgMjAwLCA1KTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLmRlYnVnVGV4dEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KHZlcnRpY2VzKSwgZ2wuU1RSRUFNX0RSQVcpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kZWJ1Z1NoYWRlci5hX3BvcywgcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wubGluZVdpZHRoKDggKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIGdsLnVuaWZvcm00ZihwYWludGVyLmRlYnVnU2hhZGVyLnVfY29sb3IsIDEsIDEsIDEsIDEpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHZlcnRpY2VzLmxlbmd0aCAvIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplKTtcbiAgICBnbC5saW5lV2lkdGgoMiAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgZ2wudW5pZm9ybTRmKHBhaW50ZXIuZGVidWdTaGFkZXIudV9jb2xvciwgMCwgMCwgMCwgMSk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUywgMCwgdmVydGljZXMubGVuZ3RoIC8gcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUpO1xuXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyk7XG52YXIgbWF0MyA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLm1hdDM7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0ZpbGw7XG5cbmZ1bmN0aW9uIGRyYXdGaWxsKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSkge1xuXG4gICAgdmFyIHRyYW5zbGF0ZWRQb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZU1hdHJpeChwb3NNYXRyaXgsIHBhcmFtcy56LCBsYXllclN0eWxlWydmaWxsLXRyYW5zbGF0ZSddLCBsYXllclN0eWxlWydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXSk7XG5cbiAgICB2YXIgY29sb3IgPSBsYXllclN0eWxlWydmaWxsLWNvbG9yJ107XG5cbiAgICB2YXIgdmVydGV4LCBlbGVtZW50cywgZ3JvdXAsIGNvdW50O1xuXG4gICAgLy8gRHJhdyB0aGUgc3RlbmNpbCBtYXNrLlxuXG4gICAgLy8gV2UncmUgb25seSBkcmF3aW5nIHRvIHRoZSBmaXJzdCBzZXZlbiBiaXRzICg9PSBzdXBwb3J0IGEgbWF4aW11bSBvZlxuICAgIC8vIDEyNyBvdmVybGFwcGluZyBwb2x5Z29ucyBpbiBvbmUgcGxhY2UgYmVmb3JlIHdlIGdldCByZW5kZXJpbmcgZXJyb3JzKS5cbiAgICBnbC5zdGVuY2lsTWFzaygweDNGKTtcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuXG4gICAgLy8gRHJhdyBmcm9udCBmYWNpbmcgdHJpYW5nbGVzLiBXaGVyZXZlciB0aGUgMHg4MCBiaXQgaXMgMSwgd2UgYXJlXG4gICAgLy8gaW5jcmVhc2luZyB0aGUgbG93ZXIgNyBiaXRzIGJ5IG9uZSBpZiB0aGUgdHJpYW5nbGUgaXMgYSBmcm9udC1mYWNpbmdcbiAgICAvLyB0cmlhbmdsZS4gVGhpcyBtZWFucyB0aGF0IGFsbCB2aXNpYmxlIHBvbHlnb25zIHNob3VsZCBiZSBpbiBDQ1dcbiAgICAvLyBvcmllbnRhdGlvbiwgd2hpbGUgYWxsIGhvbGVzIChzZWUgYmVsb3cpIGFyZSBpbiBDVyBvcmllbnRhdGlvbi5cbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwgMHg4MCwgMHg4MCk7XG5cbiAgICAvLyBXaGVuIHdlIGRvIGEgbm9uemVybyBmaWxsLCB3ZSBjb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgcGl4ZWwgaXNcbiAgICAvLyBjb3ZlcmVkIGJ5IGEgY291bnRlcmNsb2Nrd2lzZSBwb2x5Z29uLCBhbmQgc3VidHJhY3QgdGhlIG51bWJlciBvZlxuICAgIC8vIHRpbWVzIGl0IGlzIFwidW5jb3ZlcmVkXCIgYnkgYSBjbG9ja3dpc2UgcG9seWdvbi5cbiAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5GUk9OVCwgZ2wuSU5DUl9XUkFQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5CQUNLLCBnbC5ERUNSX1dSQVAsIGdsLktFRVAsIGdsLktFRVApO1xuXG4gICAgLy8gV2hlbiBkcmF3aW5nIGEgc2hhcGUsIHdlIGZpcnN0IGRyYXcgYWxsIHNoYXBlcyB0byB0aGUgc3RlbmNpbCBidWZmZXJcbiAgICAvLyBhbmQgaW5jcmVtZW50aW5nIGFsbCBhcmVhcyB3aGVyZSBwb2x5Z29ucyBhcmVcbiAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIHRyaWFuZ2xlIGZhbiBpbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlci5cbiAgICBnbC5zd2l0Y2hTaGFkZXIocGFpbnRlci5maWxsU2hhZGVyLCB0cmFuc2xhdGVkUG9zTWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xuXG4gICAgLy8gRHJhdyBhbGwgYnVmZmVyc1xuICAgIHZlcnRleCA9IGJ1Y2tldC5idWZmZXJzLmZpbGxWZXJ0ZXg7XG4gICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgIGVsZW1lbnRzID0gYnVja2V0LmJ1ZmZlcnMuZmlsbEVsZW1lbnQ7XG4gICAgZWxlbWVudHMuYmluZChnbCk7XG5cbiAgICB2YXIgb2Zmc2V0LCBlbGVtZW50T2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzW2ldO1xuICAgICAgICBvZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZmlsbFNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCA0LCBvZmZzZXQgKyAwKTtcblxuICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBlbGVtZW50T2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBzdGVuY2lsIG1hc2sgaW4gdGhlIHN0ZW5jaWwgYnVmZmVyLCB3ZSBjYW4gc3RhcnRcbiAgICAvLyB3cml0aW5nIHRvIHRoZSBjb2xvciBidWZmZXIuXG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgLy8gRnJvbSBub3cgb24sIHdlIGRvbid0IHdhbnQgdG8gdXBkYXRlIHRoZSBzdGVuY2lsIGJ1ZmZlciBhbnltb3JlLlxuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweDApO1xuXG4gICAgdmFyIHN0cm9rZUNvbG9yID0gbGF5ZXJTdHlsZVsnZmlsbC1vdXRsaW5lLWNvbG9yJ107XG5cbiAgICAvLyBCZWNhdXNlIHdlJ3JlIGRyYXdpbmcgdG9wLXRvLWJvdHRvbSwgYW5kIHdlIHVwZGF0ZSB0aGUgc3RlbmNpbCBtYXNrXG4gICAgLy8gYmVsb3csIHdlIGhhdmUgdG8gZHJhdyB0aGUgb3V0bGluZSBmaXJzdCAoISlcbiAgICBpZiAobGF5ZXJTdHlsZVsnZmlsbC1hbnRpYWxpYXMnXSA9PT0gdHJ1ZSAmJiBwYXJhbXMuYW50aWFsaWFzaW5nICYmICEobGF5ZXJTdHlsZVsnZmlsbC1pbWFnZSddICYmICFzdHJva2VDb2xvcikpIHtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIub3V0bGluZVNoYWRlciwgdHJhbnNsYXRlZFBvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcbiAgICAgICAgZ2wubGluZVdpZHRoKDIgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuXG4gICAgICAgIGlmIChzdHJva2VDb2xvcikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGVmaW5lZCBhIGRpZmZlcmVudCBjb2xvciBmb3IgdGhlIGZpbGwgb3V0bGluZSwgd2UgYXJlXG4gICAgICAgICAgICAvLyBnb2luZyB0byBpZ25vcmUgdGhlIGJpdHMgaW4gMHgzRiBhbmQganVzdCBjYXJlIGFib3V0IHRoZSBnbG9iYWxcbiAgICAgICAgICAgIC8vIGNsaXBwaW5nIG1hc2suXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG9ubHkgd2FudCB0byBkcmF3IHRoZSBhbnRpYWxpYXNlZCBwYXJ0cyB0aGF0IGFyZVxuICAgICAgICAgICAgLy8gKm91dHNpZGUqIHRoZSBjdXJyZW50IHNoYXBlLiBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlIHRoZSBmaWxsXG4gICAgICAgICAgICAvLyBvciBzdHJva2UgY29sb3IgaXMgdHJhbnNsdWNlbnQuIElmIHdlIHdvdWxkbid0IGNsaXAgdG8gb3V0c2lkZVxuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgc2hhcGUsIHNvbWUgcGl4ZWxzIGZyb20gdGhlIG91dGxpbmUgc3Ryb2tlIG92ZXJsYXBwZWRcbiAgICAgICAgICAgIC8vIHRoZSAobm9uLWFudGlhbGlhc2VkKSBmaWxsLlxuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4QkYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmKHBhaW50ZXIub3V0bGluZVNoYWRlci51X3dvcmxkLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHBhaW50ZXIub3V0bGluZVNoYWRlci51X2NvbG9yLCBzdHJva2VDb2xvciA/IHN0cm9rZUNvbG9yIDogY29sb3IpO1xuXG4gICAgICAgIC8vIERyYXcgYWxsIGJ1ZmZlcnNcbiAgICAgICAgdmVydGV4ID0gYnVja2V0LmJ1ZmZlcnMuZmlsbFZlcnRleDtcbiAgICAgICAgZWxlbWVudHMgPSBidWNrZXQuYnVmZmVycy5vdXRsaW5lRWxlbWVudDtcbiAgICAgICAgZWxlbWVudHMuYmluZChnbCk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzW2tdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5vdXRsaW5lU2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDQsIG9mZnNldCArIDApO1xuXG4gICAgICAgICAgICBjb3VudCA9IGdyb3VwLnNlY29uZEVsZW1lbnRMZW5ndGggKiAyO1xuICAgICAgICAgICAgZWxlbWVudE9mZnNldCA9IGdyb3VwLnNlY29uZEVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuTElORVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBsYXllclN0eWxlWydmaWxsLWltYWdlJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllclN0eWxlWydmaWxsLW9wYWNpdHknXSB8fCAxO1xuICAgIHZhciBzaGFkZXI7XG5cbiAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgLy8gRHJhdyB0ZXh0dXJlIGZpbGxcbiAgICAgICAgdmFyIGltYWdlUG9zID0gaW1hZ2VTcHJpdGUuZ2V0UG9zaXRpb24oaW1hZ2UsIHRydWUpO1xuICAgICAgICBpZiAoIWltYWdlUG9zKSByZXR1cm47XG5cbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5wYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGwsIGltYWdlUG9zLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyLCBpbWFnZVBvcy5icik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIHBhaW50ZXIudHJhbnNmb3JtLnpvb21GcmFjdGlvbik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBvcGFjaXR5KTtcblxuICAgICAgICB2YXIgZmFjdG9yID0gOCAvIE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tIC0gcGFyYW1zLnopO1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeCwgbWF0cml4LCBbXG4gICAgICAgICAgICAxIC8gKGltYWdlUG9zLnNpemVbMF0gKiBmYWN0b3IpLFxuICAgICAgICAgICAgMSAvIChpbWFnZVBvcy5zaXplWzFdICogZmFjdG9yKSxcbiAgICAgICAgICAgIDEsIDFcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudV9wYXR0ZXJubWF0cml4LCBmYWxzZSwgbWF0cml4KTtcblxuICAgICAgICBpbWFnZVNwcml0ZS5iaW5kKGdsLCB0cnVlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgZmlsbGluZyByZWN0YW5nbGUuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuZmlsbFNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcGFyYW1zLnBhZGRlZCB8fCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgLy8gT25seSBkcmF3IHJlZ2lvbnMgdGhhdCB3ZSBtYXJrZWRcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwgMHgwLCAweDNGKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQpO1xuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRyYXdMaW5lKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSkge1xuICAgIC8vIGRvbid0IGRyYXcgemVyby13aWR0aCBsaW5lc1xuICAgIGlmIChsYXllclN0eWxlWydsaW5lLXdpZHRoJ10gPD0gMCkgcmV0dXJuO1xuXG4gICAgdmFyIGFudGlhbGlhc2luZyA9IDEgLyBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgdmFyIHdpZHRoID0gbGF5ZXJTdHlsZVsnbGluZS13aWR0aCddO1xuICAgIHZhciBvZmZzZXQgPSBsYXllclN0eWxlWydsaW5lLW9mZnNldCddIC8gMjtcbiAgICB2YXIgYmx1ciA9IGxheWVyU3R5bGVbJ2xpbmUtYmx1ciddICsgYW50aWFsaWFzaW5nO1xuXG4gICAgdmFyIGluc2V0ID0gTWF0aC5tYXgoLTEsIG9mZnNldCAtIHdpZHRoIC8gMiAtIGFudGlhbGlhc2luZyAvIDIpICsgMTtcbiAgICB2YXIgb3V0c2V0ID0gb2Zmc2V0ICsgd2lkdGggLyAyICsgYW50aWFsaWFzaW5nIC8gMjtcblxuICAgIHZhciBjb2xvciA9IGxheWVyU3R5bGVbJ2xpbmUtY29sb3InXTtcbiAgICB2YXIgcmF0aW8gPSBwYWludGVyLnRyYW5zZm9ybS5zY2FsZSAvICgxIDw8IHBhcmFtcy56KSAvIDg7XG4gICAgdmFyIHZ0eE1hdHJpeCA9IHBhaW50ZXIudHJhbnNsYXRlTWF0cml4KHBvc01hdHJpeCwgcGFyYW1zLnosIGxheWVyU3R5bGVbJ2xpbmUtdHJhbnNsYXRlJ10sIGxheWVyU3R5bGVbJ2xpbmUtdHJhbnNsYXRlLWFuY2hvciddKTtcblxuICAgIHZhciBzaGFkZXI7XG5cbiAgICB2YXIgaW1hZ2VQb3MgPSBsYXllclN0eWxlWydsaW5lLWltYWdlJ10gJiYgaW1hZ2VTcHJpdGUuZ2V0UG9zaXRpb24obGF5ZXJTdHlsZVsnbGluZS1pbWFnZSddKTtcbiAgICBpZiAoaW1hZ2VQb3MpIHtcbiAgICAgICAgdmFyIGZhY3RvciA9IDggLyBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSAtIHBhcmFtcy56KTtcblxuICAgICAgICBpbWFnZVNwcml0ZS5iaW5kKGdsLCB0cnVlKTtcblxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmxpbmVwYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCB2dHhNYXRyaXgsIHBhaW50ZXIudGlsZS5leE1hdHJpeCk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3JhdGlvLCByYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBibHVyKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fc2l6ZSwgW2ltYWdlUG9zLnNpemVbMF0gKiBmYWN0b3IsIGltYWdlUG9zLnNpemVbMV0gXSk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bCwgaW1hZ2VQb3MudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnIsIGltYWdlUG9zLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2ZhZGUsIHBhaW50ZXIudHJhbnNmb3JtLnpvb21GcmFjdGlvbik7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmxpbmVTaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHZ0eE1hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X2xpbmV3aWR0aCwgWyBvdXRzZXQsIGluc2V0IF0pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfcmF0aW8sIHJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2JsdXIsIGJsdXIpO1xuXG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGNvbG9yKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9kYXNoYXJyYXksIGxheWVyU3R5bGVbJ2xpbmUtZGFzaGFycmF5J10pO1xuICAgIH1cblxuICAgIHZhciB2ZXJ0ZXggPSBidWNrZXQuYnVmZmVycy5saW5lVmVydGV4O1xuICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICB2YXIgZWxlbWVudCA9IGJ1Y2tldC5idWZmZXJzLmxpbmVFbGVtZW50O1xuICAgIGVsZW1lbnQuYmluZChnbCk7XG5cbiAgICB2YXIgZ3JvdXBzID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgdmFyIHZ0eE9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCA0LCBnbC5TSE9SVCwgZmFsc2UsIDgsIHZ0eE9mZnNldCArIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2V4dHJ1ZGUsIDIsIGdsLkJZVEUsIGZhbHNlLCA4LCB2dHhPZmZzZXQgKyA2KTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9saW5lc29mYXIsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgdnR4T2Zmc2V0ICsgNCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuZWxlbWVudExlbmd0aCAqIDM7XG4gICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50Lml0ZW1TaXplO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgIH1cblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4uL3NvdXJjZS90aWxlY29vcmQuanMnKTtcbnZhciBQcmVyZW5kZXJlZFRleHR1cmUgPSByZXF1aXJlKCcuL3ByZXJlbmRlcmVkLmpzJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLm1hdDQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1Jhc3RlcjtcblxuZnVuY3Rpb24gZHJhd1Jhc3RlcihnbCwgcGFpbnRlciwgYnVja2V0LCBsYXllclN0eWxlLCBwYXJhbXMsIHN0eWxlLCBsYXllciwgdGlsZSkge1xuICAgIGlmIChsYXllciAmJiBsYXllci5sYXllcnMpIHtcblxuICAgICAgICBpZiAoIWJ1Y2tldC5wcmVyZW5kZXJlZCkge1xuICAgICAgICAgICAgYnVja2V0LnByZXJlbmRlcmVkID0gbmV3IFByZXJlbmRlcmVkVGV4dHVyZShnbCwgYnVja2V0LmluZm8sIHBhaW50ZXIpO1xuICAgICAgICAgICAgYnVja2V0LnByZXJlbmRlcmVkLmJpbmRGcmFtZWJ1ZmZlcigpO1xuXG4gICAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoMHg4MCk7XG4gICAgICAgICAgICBnbC5zdGVuY2lsTWFzaygweEZGKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCB8IGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG5cbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGJ1Y2tldC5wcmVyZW5kZXJlZC5zaXplLCBidWNrZXQucHJlcmVuZGVyZWQuc2l6ZSk7XG5cbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWNrZXQucHJlcmVuZGVyZWQuYnVmZmVyICogNDA5NjtcblxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgICAgICBtYXQ0Lm9ydGhvKG1hdHJpeCwgLWJ1ZmZlciwgNDA5NiArIGJ1ZmZlciwgLTQwOTYgLSBidWZmZXIsIGJ1ZmZlciwgMCwgMSk7XG4gICAgICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgWzAsIC00MDk2LCAwXSk7XG5cbiAgICAgICAgICAgIHBhcmFtcy5wYWRkZWQgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgbWF0NC5vcnRobyhwYXJhbXMucGFkZGVkLCAwLCA0MDk2LCAtNDA5NiwgMCwgMCwgMSk7XG4gICAgICAgICAgICBtYXQ0LnRyYW5zbGF0ZShwYXJhbXMucGFkZGVkLCBwYXJhbXMucGFkZGVkLCBbMCwgLTQwOTYsIDBdKTtcblxuICAgICAgICAgICAgcGFpbnRlci5kcmF3KHRpbGUsIHN0eWxlLCBsYXllci5sYXllcnMsIHBhcmFtcywgbWF0cml4KTtcblxuICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5wYWRkZWQ7XG5cbiAgICAgICAgICAgIGlmIChidWNrZXQuaW5mb1sncmFzdGVyLWJsdXInXSA+IDApIHtcbiAgICAgICAgICAgICAgICBidWNrZXQucHJlcmVuZGVyZWQuYmx1cihwYWludGVyLCBidWNrZXQuaW5mb1sncmFzdGVyLWJsdXInXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1Y2tldC5wcmVyZW5kZXJlZC51bmJpbmRGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgcGFpbnRlci53aWR0aCwgcGFpbnRlci5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgdGV4dHVyZSA9IGJ1Y2tldC50aWxlID8gYnVja2V0LnRpbGUgOiBidWNrZXQucHJlcmVuZGVyZWQ7XG5cbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICB2YXIgc2hhZGVyID0gcGFpbnRlci5yYXN0ZXJTaGFkZXI7XG4gICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcGFpbnRlci50aWxlLnBvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcblxuICAgIC8vIGNvbG9yIHBhcmFtZXRlcnNcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnJpZ2h0bmVzc19sb3csIGxheWVyU3R5bGVbJ3Jhc3Rlci1icmlnaHRuZXNzJ11bMF0pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9icmlnaHRuZXNzX2hpZ2gsIGxheWVyU3R5bGVbJ3Jhc3Rlci1icmlnaHRuZXNzJ11bMV0pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zYXR1cmF0aW9uX2ZhY3Rvciwgc2F0dXJhdGlvbkZhY3RvcihsYXllclN0eWxlWydyYXN0ZXItc2F0dXJhdGlvbiddKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2NvbnRyYXN0X2ZhY3RvciwgY29udHJhc3RGYWN0b3IobGF5ZXJTdHlsZVsncmFzdGVyLWNvbnRyYXN0J10pKTtcbiAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci51X3NwaW5fd2VpZ2h0cywgc3BpbldlaWdodHMobGF5ZXJTdHlsZVsncmFzdGVyLWh1ZS1yb3RhdGUnXSkpO1xuXG4gICAgdmFyIHBhcmVudFRpbGUsIG9wYWNpdGllcztcbiAgICBpZiAobGF5ZXIgJiYgbGF5ZXIubGF5ZXJzKSB7XG4gICAgICAgIHBhcmVudFRpbGUgPSBudWxsO1xuICAgICAgICBvcGFjaXRpZXMgPSBbbGF5ZXJTdHlsZVsncmFzdGVyLW9wYWNpdHknXSwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50VGlsZSA9IGZpbmRQYXJlbnQodGV4dHVyZSk7XG4gICAgICAgIG9wYWNpdGllcyA9IGdldE9wYWNpdGllcyh0ZXh0dXJlLCBwYXJlbnRUaWxlLCBsYXllclN0eWxlKTtcbiAgICB9XG4gICAgdmFyIHBhcmVudFNjYWxlQnksIHBhcmVudFRMO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgdGV4dHVyZS5iaW5kKGdsKTtcblxuICAgIGlmIChwYXJlbnRUaWxlKSB7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgICBwYXJlbnRUaWxlLmJpbmQoZ2wpO1xuXG4gICAgICAgIHZhciB0aWxlUG9zID0gVGlsZUNvb3JkLmZyb21JRCh0ZXh0dXJlLmlkKTtcbiAgICAgICAgdmFyIHBhcmVudFBvcyA9IHBhcmVudFRpbGUgJiYgVGlsZUNvb3JkLmZyb21JRChwYXJlbnRUaWxlLmlkKTtcbiAgICAgICAgcGFyZW50U2NhbGVCeSA9IE1hdGgucG93KDIsIHBhcmVudFBvcy56IC0gdGlsZVBvcy56KTtcbiAgICAgICAgcGFyZW50VEwgPSBbdGlsZVBvcy54ICogcGFyZW50U2NhbGVCeSAlIDEsIHRpbGVQb3MueSAqIHBhcmVudFNjYWxlQnkgJSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcGFjaXRpZXNbMV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJTY2FsZSA9IGJ1Y2tldC5wcmVyZW5kZXJlZCA/ICg0MDk2ICogKDEgKyAyICogYnVja2V0LnByZXJlbmRlcmVkLmJ1ZmZlcikpIC8gNDA5NiA6IDE7XG5cbiAgICAvLyBjcm9zcy1mYWRlIHBhcmFtZXRlcnNcbiAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3RsX3BhcmVudCwgcGFyZW50VEwgfHwgWzAsIDBdKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfc2NhbGVfcGFyZW50LCBwYXJlbnRTY2FsZUJ5IHx8IDEpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXJfc2NhbGUsIGJ1ZmZlclNjYWxlKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eTAsIG9wYWNpdGllc1swXSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHkxLCBvcGFjaXRpZXNbMV0pO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZTAsIDApO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZTEsIDEpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRleHR1cmUuYm91bmRzQnVmZmVyIHx8IHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgICAgICAgICAyLCBnbC5TSE9SVCwgZmFsc2UsIDgsIDApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfdGV4dHVyZV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgNCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbn1cblxuZnVuY3Rpb24gZmluZFBhcmVudCh0aWxlKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRpbGUuc291cmNlO1xuICAgIGlmICghc291cmNlKSByZXR1cm47XG4gICAgdmFyIHBhcmVudFRpbGVzID0ge307XG4gICAgc291cmNlLl9maW5kTG9hZGVkUGFyZW50KHRpbGUuaWQsIHNvdXJjZS5taW56b29tLCBwYXJlbnRUaWxlcyk7XG4gICAgcmV0dXJuIHNvdXJjZS50aWxlc1tPYmplY3Qua2V5cyhwYXJlbnRUaWxlcylbMF1dO1xufVxuXG5mdW5jdGlvbiBjbGFtcChuLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgbikpO1xufVxuXG5mdW5jdGlvbiBzcGluV2VpZ2h0cyhhbmdsZSkge1xuICAgIGFuZ2xlICo9IE1hdGguUEkgLyAxODA7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKDIgKiBjICsgMSkgLyAzLFxuICAgICAgICAoLU1hdGguc3FydCgzKSAqIHMgLSBjICsgMSkgLyAzLFxuICAgICAgICAoTWF0aC5zcXJ0KDMpICogcyAtIGMgKyAxKSAvIDNcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBjb250cmFzdEZhY3Rvcihjb250cmFzdCkge1xuICAgIHJldHVybiBjb250cmFzdCA+IDAgP1xuICAgICAgICAxIC8gKDEgLSBjb250cmFzdCkgOlxuICAgICAgICAxICsgY29udHJhc3Q7XG59XG5cbmZ1bmN0aW9uIHNhdHVyYXRpb25GYWN0b3Ioc2F0dXJhdGlvbikge1xuICAgIHJldHVybiBzYXR1cmF0aW9uID4gMCA/XG4gICAgICAgIDEgLSAxIC8gKDEuMDAxIC0gc2F0dXJhdGlvbikgOlxuICAgICAgICAtc2F0dXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0T3BhY2l0aWVzKHRpbGUsIHBhcmVudFRpbGUsIGxheWVyU3R5bGUpIHtcbiAgICBpZiAoIXRpbGUuc291cmNlKSByZXR1cm4gWzEsIDBdO1xuXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgdmFyIGZhZGVEdXJhdGlvbiA9IGxheWVyU3R5bGVbJ3Jhc3Rlci1mYWRlLWR1cmF0aW9uJ107XG4gICAgdmFyIHNpbmNlVGlsZSA9IChub3cgLSB0aWxlLnRpbWVBZGRlZCkgLyBmYWRlRHVyYXRpb247XG4gICAgdmFyIHNpbmNlUGFyZW50ID0gcGFyZW50VGlsZSA/IChub3cgLSBwYXJlbnRUaWxlLnRpbWVBZGRlZCkgLyBmYWRlRHVyYXRpb24gOiAtMTtcblxuICAgIHZhciB0aWxlUG9zID0gVGlsZUNvb3JkLmZyb21JRCh0aWxlLmlkKTtcbiAgICB2YXIgcGFyZW50UG9zID0gcGFyZW50VGlsZSAmJiBUaWxlQ29vcmQuZnJvbUlEKHBhcmVudFRpbGUuaWQpO1xuXG4gICAgdmFyIGlkZWFsWiA9IHRpbGUuc291cmNlLl9jb3ZlcmluZ1pvb21MZXZlbCh0aWxlLnNvdXJjZS5fZ2V0Wm9vbSgpKTtcbiAgICB2YXIgcGFyZW50RnVydGhlciA9IHBhcmVudFRpbGUgPyBNYXRoLmFicyhwYXJlbnRQb3MueiAtIGlkZWFsWikgPiBNYXRoLmFicyh0aWxlUG9zLnogLSBpZGVhbFopIDogZmFsc2U7XG5cbiAgICB2YXIgb3BhY2l0eSA9IFtdO1xuICAgIGlmICghcGFyZW50VGlsZSB8fCBwYXJlbnRGdXJ0aGVyKSB7XG4gICAgICAgIC8vIGlmIG5vIHBhcmVudCBvciBwYXJlbnQgaXMgb2xkZXJcbiAgICAgICAgb3BhY2l0eVswXSA9IGNsYW1wKHNpbmNlVGlsZSwgMCwgMSk7XG4gICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXJlbnQgaXMgeW91bmdlciwgem9vbWluZyBvdXRcbiAgICAgICAgb3BhY2l0eVswXSA9IGNsYW1wKDEgLSBzaW5jZVBhcmVudCwgMCwgMSk7XG4gICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICB9XG5cbiAgICB2YXIgb3AgPSBsYXllclN0eWxlWydyYXN0ZXItb3BhY2l0eSddO1xuICAgIG9wYWNpdHlbMF0gKj0gb3A7XG4gICAgb3BhY2l0eVsxXSAqPSBvcDtcblxuICAgIHJldHVybiBvcGFjaXR5O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xudmFyIG1hdDQgPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKS5tYXQ0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdTeW1ib2xzO1xuXG5mdW5jdGlvbiBkcmF3U3ltYm9scyhnbCwgcGFpbnRlciwgYnVja2V0LCBsYXllclN0eWxlLCBwb3NNYXRyaXgsIHBhcmFtcywgaW1hZ2VTcHJpdGUpIHtcbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgaWYgKGJ1Y2tldC5lbGVtZW50R3JvdXBzLnRleHQuZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICBkcmF3U3ltYm9sKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSwgJ3RleHQnKTtcbiAgICB9XG4gICAgaWYgKGJ1Y2tldC5lbGVtZW50R3JvdXBzLmljb24uZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICBkcmF3U3ltYm9sKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSwgJ2ljb24nKTtcbiAgICB9XG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG59XG5cbnZhciBkZWZhdWx0U2l6ZXMgPSB7XG4gICAgaWNvbjogMSxcbiAgICB0ZXh0OiAyNFxufTtcblxuZnVuY3Rpb24gZHJhd1N5bWJvbChnbCwgcGFpbnRlciwgYnVja2V0LCBsYXllclN0eWxlLCBwb3NNYXRyaXgsIHBhcmFtcywgaW1hZ2VTcHJpdGUsIHByZWZpeCkge1xuXG4gICAgcG9zTWF0cml4ID0gcGFpbnRlci50cmFuc2xhdGVNYXRyaXgocG9zTWF0cml4LCBwYXJhbXMueiwgbGF5ZXJTdHlsZVtwcmVmaXggKyAnLXRyYW5zbGF0ZSddLCBsYXllclN0eWxlW3ByZWZpeCArICctdHJhbnNsYXRlLWFuY2hvciddKTtcblxuICAgIHZhciBpbmZvID0gYnVja2V0LmluZm87XG5cbiAgICB2YXIgZXhNYXRyaXggPSBtYXQ0LmNsb25lKHBhaW50ZXIucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgdmFyIGFsaWduZWRXaXRoTWFwID0gaW5mb1twcmVmaXggKyAnLXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJztcbiAgICB2YXIgYW5nbGVPZmZzZXQgPSAoYWxpZ25lZFdpdGhNYXAgPyBwYWludGVyLnRyYW5zZm9ybS5hbmdsZSA6IDApO1xuXG4gICAgaWYgKGFuZ2xlT2Zmc2V0KSB7XG4gICAgICAgIG1hdDQucm90YXRlWihleE1hdHJpeCwgZXhNYXRyaXgsIGFuZ2xlT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBJZiBsYXllclN0eWxlLnNpemUgPiBpbmZvW3ByZWZpeCArICctbWF4LXNpemUnXSB0aGVuIGxhYmVscyBtYXkgY29sbGlkZVxuICAgIHZhciBmb250U2l6ZSA9IGxheWVyU3R5bGVbcHJlZml4ICsgJy1zaXplJ10gfHwgaW5mb1twcmVmaXggKyAnLW1heC1zaXplJ107XG4gICAgdmFyIGZvbnRTY2FsZSA9IGZvbnRTaXplIC8gZGVmYXVsdFNpemVzW3ByZWZpeF07XG4gICAgbWF0NC5zY2FsZShleE1hdHJpeCwgZXhNYXRyaXgsIFsgZm9udFNjYWxlLCBmb250U2NhbGUsIDEgXSk7XG5cbiAgICB2YXIgdGV4dCA9IHByZWZpeCA9PT0gJ3RleHQnO1xuICAgIHZhciBzZGYgPSB0ZXh0IHx8IGJ1Y2tldC5lbGVtZW50R3JvdXBzLnNkZkljb25zO1xuICAgIHZhciBzaGFkZXIsIGJ1ZmZlciwgdGV4c2l6ZTtcblxuICAgIGlmICghdGV4dCAmJiAhaW1hZ2VTcHJpdGUubG9hZGVkKCkpXG4gICAgICAgIHJldHVybjtcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXG4gICAgaWYgKHNkZikge1xuICAgICAgICBzaGFkZXIgPSBwYWludGVyLnNkZlNoYWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmljb25TaGFkZXI7XG4gICAgfVxuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgICAgcGFpbnRlci5nbHlwaEF0bGFzLnVwZGF0ZVRleHR1cmUoZ2wpO1xuICAgICAgICBidWZmZXIgPSBidWNrZXQuYnVmZmVycy5nbHlwaFZlcnRleDtcbiAgICAgICAgdGV4c2l6ZSA9IFtwYWludGVyLmdseXBoQXRsYXMud2lkdGggLyA0LCBwYWludGVyLmdseXBoQXRsYXMuaGVpZ2h0IC8gNF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2VTcHJpdGUuYmluZChnbCwgYWxpZ25lZFdpdGhNYXAgfHwgcGFyYW1zLnJvdGF0aW5nIHx8IHBhcmFtcy56b29taW5nIHx8IGZvbnRTY2FsZSAhPSAxIHx8IHNkZik7XG4gICAgICAgIGJ1ZmZlciA9IGJ1Y2tldC5idWZmZXJzLmljb25WZXJ0ZXg7XG4gICAgICAgIHRleHNpemUgPSBbaW1hZ2VTcHJpdGUuaW1nLndpZHRoLCBpbWFnZVNwcml0ZS5pbWcuaGVpZ2h0XTtcbiAgICB9XG5cbiAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgsIGV4TWF0cml4KTtcbiAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfdGV4dHVyZSwgMCk7XG4gICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV90ZXhzaXplLCB0ZXhzaXplKTtcblxuICAgIGJ1ZmZlci5iaW5kKGdsLCBzaGFkZXIpO1xuXG4gICAgLy8gQ29udmVydCB0aGUgLXBpLi5waSB0byBhbiBpbnQ4IHJhbmdlLlxuICAgIHZhciBhbmdsZSA9IE1hdGgucm91bmQocGFpbnRlci50cmFuc2Zvcm0uYW5nbGUgLyBNYXRoLlBJICogMTI4KTtcblxuICAgIC8vIGFkanVzdCBtaW4vbWF4IHpvb21zIGZvciB2YXJpYWJsZSBmb250IHNpZXNcbiAgICB2YXIgem9vbUFkanVzdCA9IE1hdGgubG9nKGZvbnRTaXplIC8gaW5mb1twcmVmaXggKyAnLW1heC1zaXplJ10pIC8gTWF0aC5MTjIgfHwgMDtcblxuICAgIHZhciBmbGlwID0gYWxpZ25lZFdpdGhNYXAgJiYgaW5mb1twcmVmaXggKyAnLWtlZXAtdXByaWdodCddO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mbGlwLCBmbGlwID8gMSA6IDApO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9hbmdsZSwgKGFuZ2xlICsgMjU2KSAlIDI1Nik7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3pvb20sIChwYWludGVyLnRyYW5zZm9ybS56b29tIC0gem9vbUFkanVzdCkgKiAxMCk7IC8vIGN1cnJlbnQgem9vbSBsZXZlbFxuXG4gICAgdmFyIGYgPSBwYWludGVyLmZyYW1lSGlzdG9yeS5nZXRGYWRlUHJvcGVydGllcygzMDApO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mYWRlZGlzdCwgZi5mYWRlZGlzdCAqIDEwKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWluZmFkZXpvb20sIE1hdGguZmxvb3IoZi5taW5mYWRlem9vbSAqIDEwKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21heGZhZGV6b29tLCBNYXRoLmZsb29yKGYubWF4ZmFkZXpvb20gKiAxMCkpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mYWRlem9vbSwgKHBhaW50ZXIudHJhbnNmb3JtLnpvb20gKyBmLmJ1bXApICogMTApO1xuXG4gICAgdmFyIGJlZ2luID0gYnVja2V0LmVsZW1lbnRHcm91cHNbcHJlZml4XS5ncm91cHNbMF0udmVydGV4U3RhcnRJbmRleCxcbiAgICAgICAgbGVuID0gYnVja2V0LmVsZW1lbnRHcm91cHNbcHJlZml4XS5ncm91cHNbMF0udmVydGV4TGVuZ3RoO1xuXG4gICAgaWYgKHNkZikge1xuICAgICAgICB2YXIgc2RmUHggPSA4O1xuICAgICAgICB2YXIgYmx1ck9mZnNldCA9IDEuMTk7XG4gICAgICAgIHZhciBoYWxvT2Zmc2V0ID0gNjtcbiAgICAgICAgdmFyIGdhbW1hID0gMC4xMDUgKiBkZWZhdWx0U2l6ZXNbcHJlZml4XSAvIGZvbnRTaXplIC8gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9nYW1tYSwgZ2FtbWEpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBsYXllclN0eWxlW3ByZWZpeCArICctY29sb3InXSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXIsICgyNTYgLSA2NCkgLyAyNTYpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgYmVnaW4sIGxlbik7XG5cbiAgICAgICAgaWYgKGxheWVyU3R5bGVbcHJlZml4ICsgJy1oYWxvLWNvbG9yJ10pIHtcbiAgICAgICAgICAgIC8vIERyYXcgaGFsbyB1bmRlcm5lYXRoIHRoZSB0ZXh0LlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2dhbW1hLCBsYXllclN0eWxlW3ByZWZpeCArICctaGFsby1ibHVyJ10gKiBibHVyT2Zmc2V0IC8gZm9udFNjYWxlIC8gc2RmUHggKyBnYW1tYSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBsYXllclN0eWxlW3ByZWZpeCArICctaGFsby1jb2xvciddKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXIsIChoYWxvT2Zmc2V0IC0gbGF5ZXJTdHlsZVtwcmVmaXggKyAnLWhhbG8td2lkdGgnXSAvIGZvbnRTY2FsZSkgLyBzZGZQeCk7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgYmVnaW4sIGxlbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eSwgbGF5ZXJTdHlsZVsnaWNvbi1vcGFjaXR5J10pO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgYmVnaW4sIGxlbik7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xudmFyIG1hdDQgPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKS5tYXQ0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdWZXJ0aWNlcztcblxuZnVuY3Rpb24gZHJhd1ZlcnRpY2VzKGdsLCBwYWludGVyLCBidWNrZXQpIHtcbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmRvdFNoYWRlciwgcGFpbnRlci50aWxlLnBvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcblxuICAgIC8vIC8vIERyYXcgZGVidWcgcG9pbnRzLlxuICAgIGdsLnVuaWZvcm0xZihwYWludGVyLmRvdFNoYWRlci51X3NpemUsIDQgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIGdsLnVuaWZvcm0xZihwYWludGVyLmRvdFNoYWRlci51X2JsdXIsIDAuMjUpO1xuICAgIGdsLnVuaWZvcm00ZnYocGFpbnRlci5kb3RTaGFkZXIudV9jb2xvciwgWzAuMjUsIDAsIDAsIDAuMjVdKTtcblxuICAgIC8vIERyYXcgdGhlIGFjdHVhbCB0cmlhbmdsZSBmYW4gaW50byB0aGUgc3RlbmNpbCBidWZmZXIuXG5cbiAgICB2YXIgdmVydGV4LCBncm91cHMsIGdyb3VwLCBiZWdpbiwgY291bnQ7XG5cbiAgICAvLyBEcmF3IGFsbCBidWZmZXJzXG4gICAgaWYgKGJ1Y2tldC5pbmZvLmZpbGwpIHtcbiAgICAgICAgdmVydGV4ID0gYnVja2V0LmJ1ZmZlcnMuZmlsbFZlcnRleDtcbiAgICAgICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgICAgICBncm91cHMgPSBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIGJlZ2luID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgICAgIGNvdW50ID0gZ3JvdXAudmVydGV4TGVuZ3RoO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwYWludGVyLmRvdFNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCBiZWdpbiwgY291bnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld1Bvc01hdHJpeCA9IG1hdDQuY2xvbmUocGFpbnRlci50aWxlLnBvc01hdHJpeCk7XG4gICAgbWF0NC5zY2FsZShuZXdQb3NNYXRyaXgsIG5ld1Bvc01hdHJpeCwgWzAuNSwgMC41LCAxXSk7XG5cbiAgICBnbC5zd2l0Y2hTaGFkZXIocGFpbnRlci5kb3RTaGFkZXIsIG5ld1Bvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcblxuICAgIC8vIERyYXcgYWxsIGxpbmUgYnVmZmVyc1xuICAgIGlmIChidWNrZXQuaW5mby5saW5lKSB7XG4gICAgICAgIHZlcnRleCA9IGJ1Y2tldC5idWZmZXJzLmxpbmVWZXJ0ZXg7XG4gICAgICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICAgICAgZ3JvdXBzID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyb3Vwcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBncm91cHNba107XG4gICAgICAgICAgICBiZWdpbiA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBjb3VudCA9IGdyb3VwLnZlcnRleExlbmd0aDtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kb3RTaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgYmVnaW4sIGNvdW50KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhbWVIaXN0b3J5O1xuXG5mdW5jdGlvbiBGcmFtZUhpc3RvcnkoKSB7XG4gICAgdGhpcy5mcmFtZUhpc3RvcnkgPSBbXTtcbn1cblxuRnJhbWVIaXN0b3J5LnByb3RvdHlwZS5nZXRGYWRlUHJvcGVydGllcyA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIGR1cmF0aW9uID0gMzAwO1xuICAgIHZhciBjdXJyZW50VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBSZW1vdmUgZnJhbWVzIHVudGlsIG9ubHkgb25lIGlzIG91dHNpZGUgdGhlIGR1cmF0aW9uLCBvciB1bnRpbCB0aGVyZSBhcmUgb25seSB0aHJlZVxuICAgIHdoaWxlICh0aGlzLmZyYW1lSGlzdG9yeS5sZW5ndGggPiAzICYmIHRoaXMuZnJhbWVIaXN0b3J5WzFdLnRpbWUgKyBkdXJhdGlvbiA8IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRoaXMuZnJhbWVIaXN0b3J5LnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnJhbWVIaXN0b3J5WzFdLnRpbWUgKyBkdXJhdGlvbiA8IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRoaXMuZnJhbWVIaXN0b3J5WzBdLnogPSB0aGlzLmZyYW1lSGlzdG9yeVsxXS56O1xuICAgIH1cblxuICAgIHZhciBmcmFtZUxlbiA9IHRoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aDtcbiAgICBpZiAoZnJhbWVMZW4gPCAzKSBjb25zb2xlLndhcm4oJ3RoZXJlIHNob3VsZCBuZXZlciBiZSBsZXNzIHRoYW4gdGhyZWUgZnJhbWVzIGluIHRoZSBoaXN0b3J5Jyk7XG5cbiAgICAvLyBGaW5kIHRoZSByYW5nZSBvZiB6b29tIGxldmVscyB3ZSB3YW50IHRvIGZhZGUgYmV0d2VlblxuICAgIHZhciBzdGFydGluZ1ogPSB0aGlzLmZyYW1lSGlzdG9yeVswXS56LFxuICAgICAgICBsYXN0RnJhbWUgPSB0aGlzLmZyYW1lSGlzdG9yeVtmcmFtZUxlbiAtIDFdLFxuICAgICAgICBlbmRpbmdaID0gbGFzdEZyYW1lLnosXG4gICAgICAgIGxvd1ogPSBNYXRoLm1pbihzdGFydGluZ1osIGVuZGluZ1opLFxuICAgICAgICBoaWdoWiA9IE1hdGgubWF4KHN0YXJ0aW5nWiwgZW5kaW5nWik7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNwZWVkIG9mIHpvb21pbmcsIGFuZCBob3cgZmFyIGl0IHdvdWxkIHpvb20gaW4gdGVybXMgb2Ygem9vbSBsZXZlbHMgaW4gb25lIGR1cmF0aW9uXG4gICAgdmFyIHpvb21EaWZmID0gbGFzdEZyYW1lLnogLSB0aGlzLmZyYW1lSGlzdG9yeVsxXS56LFxuICAgICAgICB0aW1lRGlmZiA9IGxhc3RGcmFtZS50aW1lIC0gdGhpcy5mcmFtZUhpc3RvcnlbMV0udGltZTtcbiAgICB2YXIgZmFkZWRpc3QgPSB6b29tRGlmZiAvICh0aW1lRGlmZiAvIGR1cmF0aW9uKTtcblxuICAgIGlmIChpc05hTihmYWRlZGlzdCkpIGNvbnNvbGUud2FybignZmFkZWRpc3Qgc2hvdWxkIG5ldmVyIGJlIE5hTicpO1xuXG4gICAgLy8gQXQgZW5kIG9mIGEgem9vbSB3aGVuIHRoZSB6b29tIHN0b3BzIGNoYW5naW5nIGNvbnRpbnVlIHByZXRlbmRpbmcgdG8gem9vbSBhdCB0aGF0IHNwZWVkXG4gICAgLy8gYnVtcCBpcyBob3cgbXVjaCBmYXJ0aGVyIGl0IHdvdWxkIGhhdmUgYmVlbiBpZiBpdCBoYWQgY29udGludWVkIHpvb21pbmcgYXQgdGhlIHNhbWUgcmF0ZVxuICAgIHZhciBidW1wID0gKGN1cnJlbnRUaW1lIC0gbGFzdEZyYW1lLnRpbWUpIC8gZHVyYXRpb24gKiBmYWRlZGlzdDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZhZGVkaXN0OiBmYWRlZGlzdCxcbiAgICAgICAgbWluZmFkZXpvb206IGxvd1osXG4gICAgICAgIG1heGZhZGV6b29tOiBoaWdoWixcbiAgICAgICAgYnVtcDogYnVtcFxuICAgIH07XG59O1xuXG4vLyBSZWNvcmQgZnJhbWUgaGlzdG9yeSB0aGF0IHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgZmFkaW5nIHBhcmFtc1xuRnJhbWVIaXN0b3J5LnByb3RvdHlwZS5yZWNvcmQgPSBmdW5jdGlvbih6b29tKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIC8vIGZpcnN0IGZyYW1lIGV2ZXJcbiAgICBpZiAoIXRoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLmZyYW1lSGlzdG9yeS5wdXNoKHt0aW1lOiAwLCB6OiB6b29tIH0sIHt0aW1lOiAwLCB6OiB6b29tIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZyYW1lSGlzdG9yeS5sZW5ndGggPT09IDIgfHwgdGhpcy5mcmFtZUhpc3RvcnlbdGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoIC0gMV0ueiAhPT0gem9vbSkge1xuICAgICAgICB0aGlzLmZyYW1lSGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgejogem9vbVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2hhZGVycyA9IHJlcXVpcmUoJy4vc2hhZGVycy5qcycpO1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmdldFNoYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0eXBlID09IHRoaXMuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICd2ZXJ0ZXgnO1xuICAgICAgICBpZiAoIXNoYWRlcnNbbmFtZV0gfHwgIXNoYWRlcnNbbmFtZV1ba2luZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHNoYWRlciBcIiArIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgICB0aGlzLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlcnNbbmFtZV1ba2luZF0pO1xuICAgICAgICB0aGlzLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgaWYgKCF0aGlzLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfTtcblxuICAgIGNvbnRleHQuaW5pdGlhbGl6ZVNoYWRlciA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHVuaWZvcm1zKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSB7XG4gICAgICAgICAgICBwcm9ncmFtOiB0aGlzLmNyZWF0ZVByb2dyYW0oKSxcbiAgICAgICAgICAgIGZyYWdtZW50OiB0aGlzLmdldFNoYWRlcihuYW1lLCB0aGlzLkZSQUdNRU5UX1NIQURFUiksXG4gICAgICAgICAgICB2ZXJ0ZXg6IHRoaXMuZ2V0U2hhZGVyKG5hbWUsIHRoaXMuVkVSVEVYX1NIQURFUiksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF0dGFjaFNoYWRlcihzaGFkZXIucHJvZ3JhbSwgc2hhZGVyLnZlcnRleCk7XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCBzaGFkZXIuZnJhZ21lbnQpO1xuICAgICAgICB0aGlzLmxpbmtQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcblxuICAgICAgICBpZiAoIXRoaXMuZ2V0UHJvZ3JhbVBhcmFtZXRlcihzaGFkZXIucHJvZ3JhbSwgdGhpcy5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5nZXRQcm9ncmFtSW5mb0xvZyhzaGFkZXIucHJvZ3JhbSkpO1xuICAgICAgICAgICAgYWxlcnQoXCJDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIgXCIgKyBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNoYWRlclthdHRyaWJ1dGVzW2ldXSA9IHRoaXMuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgICAgIHNoYWRlci5hdHRyaWJ1dGVzLnB1c2goc2hhZGVyW2F0dHJpYnV0ZXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdW5pZm9ybXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJbdW5pZm9ybXNba11dID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIHVuaWZvcm1zW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfTtcblxuICAgIC8vIFN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHNoYWRlciBwcm9ncmFtLlxuICAgIGNvbnRleHQuc3dpdGNoU2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyLCBwb3NNYXRyaXgsIGV4TWF0cml4KSB7XG4gICAgICAgIGlmICghcG9zTWF0cml4KSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCdwb3NNYXRyaXggZG9lcyBub3QgaGF2ZSByZXF1aXJlZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNoYWRlciAhPT0gc2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuXG4gICAgICAgICAgICAvLyBEaXNhYmxlIGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIGV4aXN0aW5nIHNoYWRlciB0aGF0IGFyZW4ndCB1c2VkIGluXG4gICAgICAgICAgICAvLyB0aGUgbmV3IHNoYWRlci4gTm90ZTogYXR0cmlidXRlIGluZGljZXMgYXJlICpub3QqIHByb2dyYW0gc3BlY2lmaWMhXG4gICAgICAgICAgICB2YXIgZW5hYmxlZCA9IHRoaXMuY3VycmVudFNoYWRlciA/IHRoaXMuY3VycmVudFNoYWRlci5hdHRyaWJ1dGVzIDogW107XG4gICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBzaGFkZXIuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmFibGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkLmluZGV4T2YoZW5hYmxlZFtpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGVuYWJsZWRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5hYmxlIGFsbCBhdHRyaWJ1dGVzIGZvciB0aGUgbmV3IHNoYWRlci5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVxdWlyZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZC5pbmRleE9mKHJlcXVpcmVkW2pdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShyZXF1aXJlZFtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTaGFkZXIgPSBzaGFkZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1hdHJpY2VzIGlmIG5lY2Vzc2FyeS4gTm90ZTogVGhpcyByZWxpZXMgb24gb2JqZWN0IGlkZW50aXR5IVxuICAgICAgICAvLyBUaGlzIG1lYW5zIGNoYW5naW5nIHRoZSBtYXRyaXggdmFsdWVzIHdpdGhvdXQgdGhlIGFjdHVhbCBtYXRyaXggb2JqZWN0XG4gICAgICAgIC8vIHdpbGwgRkFJTCB0byB1cGRhdGUgdGhlIG1hdHJpeCBwcm9wZXJseS5cbiAgICAgICAgaWYgKHNoYWRlci5wb3NNYXRyaXggIT09IHBvc01hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtTWF0cml4NGZ2KHNoYWRlci51X21hdHJpeCwgZmFsc2UsIHBvc01hdHJpeCk7XG4gICAgICAgICAgICBzaGFkZXIucG9zTWF0cml4ID0gcG9zTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChleE1hdHJpeCAmJiBzaGFkZXIuZXhNYXRyaXggIT09IGV4TWF0cml4ICYmIHNoYWRlci51X2V4bWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyLnVfZXhtYXRyaXgsIGZhbHNlLCBleE1hdHJpeCk7XG4gICAgICAgICAgICBzaGFkZXIuZXhNYXRyaXggPSBleE1hdHJpeDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gY29udGV4dDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbHV0aWwgPSByZXF1aXJlKCcuL2dsdXRpbC5qcycpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXIuanMnKTtcbnZhciBHbHlwaEF0bGFzID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dseXBoYXRsYXMuanMnKTtcbnZhciBnbG1hdHJpeCA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpO1xudmFyIEZyYW1lSGlzdG9yeSA9IHJlcXVpcmUoJy4vZnJhbWVoaXN0b3J5LmpzJyk7XG5cbnZhciBtYXQ0ID0gZ2xtYXRyaXgubWF0NDtcblxudmFyIGRyYXdTeW1ib2wgPSByZXF1aXJlKCcuL2RyYXdzeW1ib2wuanMnKTtcbnZhciBkcmF3TGluZSA9IHJlcXVpcmUoJy4vZHJhd2xpbmUuanMnKTtcbnZhciBkcmF3RmlsbCA9IHJlcXVpcmUoJy4vZHJhd2ZpbGwuanMnKTtcbnZhciBkcmF3UmFzdGVyID0gcmVxdWlyZSgnLi9kcmF3cmFzdGVyLmpzJyk7XG52YXIgZHJhd0RlYnVnID0gcmVxdWlyZSgnLi9kcmF3ZGVidWcuanMnKTtcbnZhciBkcmF3QmFja2dyb3VuZCA9IHJlcXVpcmUoJy4vZHJhd2JhY2tncm91bmQuanMnKTtcbnZhciBkcmF3VmVydGljZXMgPSByZXF1aXJlKCcuL2RyYXd2ZXJ0aWNlcy5qcycpO1xuXG4vKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBwYWludGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0NhbnZhc30gZ2wgYW4gZXhwZXJpbWVudGFsLXdlYmdsIGRyYXdpbmcgY29udGV4dFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEdMUGFpbnRlcjtcbmZ1bmN0aW9uIEdMUGFpbnRlcihnbCwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5nbCA9IGdsdXRpbC5leHRlbmQoZ2wpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuXG4gICAgdGhpcy5yZXVzYWJsZVRleHR1cmVzID0ge307XG4gICAgdGhpcy5wcmVGYm9zID0ge307XG5cbiAgICB0aGlzLnRpbGVFeHRlbnQgPSA0MDk2O1xuICAgIHRoaXMuZnJhbWVIaXN0b3J5ID0gbmV3IEZyYW1lSGlzdG9yeSgpO1xuXG4gICAgdGhpcy5zZXR1cCgpO1xufVxuXG4vKlxuICogVXBkYXRlIHRoZSBHTCB2aWV3cG9ydCwgcHJvamVjdGlvbiBtYXRyaXgsIGFuZCB0cmFuc2Zvcm1zIHRvIGNvbXBlbnNhdGVcbiAqIGZvciBhIG5ldyB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlLlxuICovXG5HTFBhaW50ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIC8vIEluaXRpYWxpemUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgIG1hdDQub3J0aG8odGhpcy5wcm9qZWN0aW9uTWF0cml4LCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCAtMSk7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGggKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG59O1xuXG5cbkdMUGFpbnRlci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wudmVyYm9zZSA9IHRydWU7XG5cbiAgICAvLyBXZSBhcmUgYmxlbmRpbmcgdGhlIG5ldyBwaXhlbHMgKmJlaGluZCogdGhlIGV4aXN0aW5nIHBpeGVscy4gVGhhdCB3YXkgd2UgY2FuXG4gICAgLy8gZHJhdyBmcm9udC10by1iYWNrIGFuZCB1c2UgdGhlbiBzdGVuY2lsIGJ1ZmZlciB0byBjdWxsIG9wYXF1ZSBwaXhlbHMgZWFybHkuXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FKTtcblxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgdGhpcy5nbHlwaEF0bGFzID0gbmV3IEdseXBoQXRsYXMoMTAyNCwgMTAyNCk7XG4gICAgLy8gdGhpcy5nbHlwaEF0bGFzLmRlYnVnID0gdHJ1ZTtcbiAgICB0aGlzLmdseXBoQXRsYXMuYmluZChnbCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHNoYWRlcnNcbiAgICB0aGlzLmRlYnVnU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignZGVidWcnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9wb2ludHNpemUnLCAndV9jb2xvciddKTtcblxuICAgIHRoaXMuZ2F1c3NpYW5TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdnYXVzc2lhbicsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2ltYWdlJywgJ3Vfb2Zmc2V0J10pO1xuXG4gICAgdGhpcy5yYXN0ZXJTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdyYXN0ZXInLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfdGV4dHVyZV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2JyaWdodG5lc3NfbG93JywgJ3VfYnJpZ2h0bmVzc19oaWdoJywgJ3Vfc2F0dXJhdGlvbl9mYWN0b3InLCAndV9zcGluX3dlaWdodHMnLCAndV9jb250cmFzdF9mYWN0b3InLCAndV9vcGFjaXR5MCcsICd1X29wYWNpdHkxJywgJ3VfaW1hZ2UwJywgJ3VfaW1hZ2UxJywgJ3VfdGxfcGFyZW50JywgJ3Vfc2NhbGVfcGFyZW50JywgJ3VfYnVmZmVyX3NjYWxlJ10pO1xuXG4gICAgdGhpcy5saW5lU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZScsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9leHRydWRlJywgJ2FfbGluZXNvZmFyJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X2xpbmV3aWR0aCcsICd1X2NvbG9yJywgJ3VfcmF0aW8nLCAndV9kYXNoYXJyYXknLCAndV9ibHVyJ10pO1xuXG4gICAgdGhpcy5saW5lcGF0dGVyblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2xpbmVwYXR0ZXJuJyxcbiAgICAgICAgWydhX3BvcycsICdhX2V4dHJ1ZGUnLCAnYV9saW5lc29mYXInXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2V4bWF0cml4JywgJ3VfbGluZXdpZHRoJywgJ3VfcmF0aW8nLCAndV9wYXR0ZXJuX3NpemUnLCAndV9wYXR0ZXJuX3RsJywgJ3VfcGF0dGVybl9icicsICd1X3BvaW50JywgJ3VfYmx1cicsICd1X2ZhZGUnXSk7XG5cbiAgICB0aGlzLmRvdFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2RvdCcsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X3NpemUnLCAndV9jb2xvcicsICd1X2JsdXInXSk7XG5cbiAgICB0aGlzLnNkZlNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ3NkZicsXG4gICAgICAgIFsnYV9wb3MnLCAnYV90ZXgnLCAnYV9vZmZzZXQnLCAnYV9hbmdsZScsICdhX21pbnpvb20nLCAnYV9tYXh6b29tJywgJ2FfcmFuZ2VlbmQnLCAnYV9yYW5nZXN0YXJ0JywgJ2FfbGFiZWxtaW56b29tJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X3RleHR1cmUnLCAndV90ZXhzaXplJywgJ3VfY29sb3InLCAndV9nYW1tYScsICd1X2J1ZmZlcicsICd1X2FuZ2xlJywgJ3Vfem9vbScsICd1X2ZsaXAnLCAndV9mYWRlZGlzdCcsICd1X21pbmZhZGV6b29tJywgJ3VfbWF4ZmFkZXpvb20nLCAndV9mYWRlem9vbSddKTtcblxuICAgIHRoaXMuaWNvblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2ljb24nLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfdGV4JywgJ2Ffb2Zmc2V0JywgJ2FfYW5nbGUnLCAnYV9taW56b29tJywgJ2FfbWF4em9vbScsICdhX3JhbmdlZW5kJywgJ2FfcmFuZ2VzdGFydCcsICdhX2xhYmVsbWluem9vbSddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV90ZXh0dXJlJywgJ3VfdGV4c2l6ZScsICd1X2FuZ2xlJywgJ3Vfem9vbScsICd1X2ZsaXAnLCAndV9mYWRlZGlzdCcsICd1X21pbmZhZGV6b29tJywgJ3VfbWF4ZmFkZXpvb20nLCAndV9mYWRlem9vbScsICd1X29wYWNpdHknXSk7XG5cbiAgICB0aGlzLm91dGxpbmVTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdvdXRsaW5lJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfY29sb3InLCAndV93b3JsZCddXG4gICAgKTtcblxuICAgIHRoaXMucGF0dGVyblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ3BhdHRlcm4nLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9wYXR0ZXJuX3RsJywgJ3VfcGF0dGVybl9icicsICd1X21peCcsICd1X3BhdHRlcm5tYXRyaXgnLCAndV9vcGFjaXR5JywgJ3VfaW1hZ2UnXVxuICAgICk7XG5cbiAgICB0aGlzLmZpbGxTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdmaWxsJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfY29sb3InXVxuICAgICk7XG5cbiAgICB0aGlzLmlkZW50aXR5TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAgIC8vIFRoZSBiYWNrZ3JvdW5kQnVmZmVyIGlzIHVzZWQgd2hlbiBkcmF3aW5nIHRvIHRoZSBmdWxsICpjYW52YXMqXG4gICAgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1TaXplID0gMjtcbiAgICB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbUNvdW50ID0gNDtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoWy0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxXSksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIC8vIFRoZSB0aWxlRXh0ZW50QnVmZmVyIGlzIHVzZWQgd2hlbiBkcmF3aW5nIHRvIGEgZnVsbCAqdGlsZSpcbiAgICB0aGlzLnRpbGVFeHRlbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbVNpemUgPSA0O1xuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQgPSA0O1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgSW50MTZBcnJheShbXG4gICAgICAgIC8vIHRpbGUgY29vcmQgeCwgdGlsZSBjb29yZCB5LCB0ZXh0dXJlIGNvb3JkIHgsIHRleHR1cmUgY29vcmQgeVxuICAgICAgICAgICAgICAgICAgICAgIDAsIDAsICAgICAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICB0aGlzLnRpbGVFeHRlbnQsIDAsICAgICAgICAgICAgICAgIDMyNzY3LCAwLFxuICAgICAgICAgICAgICAgICAgICAgIDAsIHRoaXMudGlsZUV4dGVudCwgICAgICAwLCAzMjc2NyxcbiAgICAgICAgdGhpcy50aWxlRXh0ZW50LCB0aGlzLnRpbGVFeHRlbnQsICAzMjc2NywgMzI3NjdcbiAgICBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gVGhlIGRlYnVnQnVmZmVyIGlzIHVzZWQgdG8gZHJhdyB0aWxlIG91dGxpbmVzIGZvciBkZWJ1Z2dpbmdcbiAgICB0aGlzLmRlYnVnQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5kZWJ1Z0J1ZmZlci5pdGVtU2l6ZSA9IDI7XG4gICAgdGhpcy5kZWJ1Z0J1ZmZlci5pdGVtQ291bnQgPSA1O1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmRlYnVnQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoWzAsIDAsIDQwOTUsIDAsIDQwOTUsIDQwOTUsIDAsIDQwOTUsIDAsIDBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gVGhlIGRlYnVnVGV4dEJ1ZmZlciBpcyB1c2VkIHRvIGRyYXcgdGlsZSBJRHMgZm9yIGRlYnVnZ2luZ1xuICAgIHRoaXMuZGVidWdUZXh0QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUgPSAyO1xufTtcblxuLypcbiAqIFJlc2V0IHRoZSBjb2xvciBidWZmZXJzIG9mIHRoZSBkcmF3aW5nIGNhbnZhcy5cbiAqL1xuR0xQYWludGVyLnByb3RvdHlwZS5jbGVhckNvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xufTtcblxuLypcbiAqIFJlc2V0IHRoZSBkcmF3aW5nIGNhbnZhcyBieSBjbGVhcmluZyB0aGUgc3RlbmNpbCBidWZmZXIgc28gdGhhdCB3ZSBjYW4gZHJhd1xuICogbmV3IHRpbGVzIGF0IHRoZSBzYW1lIGxvY2F0aW9uLCB3aGlsZSByZXRhaW5pbmcgcHJldmlvdXNseSBkcmF3biBwaXhlbHMuXG4gKi9cbkdMUGFpbnRlci5wcm90b3R5cGUuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhclN0ZW5jaWwoMHgwKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweEZGKTtcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xufTtcblxuR0xQYWludGVyLnByb3RvdHlwZS5kcmF3Q2xpcHBpbmdNYXNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5zd2l0Y2hTaGFkZXIodGhpcy5maWxsU2hhZGVyLCB0aGlzLnRpbGUucG9zTWF0cml4LCB0aGlzLnRpbGUuZXhNYXRyaXgpO1xuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAvLyBDbGVhciB0aGUgZW50aXJlIHN0ZW5jaWwgYnVmZmVyLCBleGNlcHQgZm9yIHRoZSA3dGggYml0LCB3aGljaCBzdG9yZXNcbiAgICAvLyB0aGUgZ2xvYmFsIGNsaXBwaW5nIG1hc2sgdGhhdCBhbGxvd3MgdXMgdG8gYXZvaWQgZHJhd2luZyBpbiByZWdpb25zIG9mXG4gICAgLy8gdGlsZXMgd2UndmUgYWxyZWFkeSBwYWludGVkIGluLlxuICAgIGdsLmNsZWFyU3RlbmNpbCgweDApO1xuICAgIGdsLnN0ZW5jaWxNYXNrKDB4QkYpO1xuICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG5cbiAgICAvLyBUaGUgc3RlbmNpbCB0ZXN0IHdpbGwgZmFpbCBhbHdheXMsIG1lYW5pbmcgd2Ugc2V0IGFsbCBwaXhlbHMgY292ZXJlZFxuICAgIC8vIGJ5IHRoaXMgZ2VvbWV0cnkgdG8gMHg4MC4gV2UgdXNlIHRoZSBoaWdoZXN0IGJpdCAweDgwIHRvIG1hcmsgdGhlIHJlZ2lvbnNcbiAgICAvLyB3ZSB3YW50IHRvIGRyYXcgaW4uIEFsbCBwaXhlbHMgdGhhdCBoYXZlIHRoaXMgYml0ICpub3QqIHNldCB3aWxsIG5ldmVyIGJlXG4gICAgLy8gZHJhd24gaW4uXG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4QzAsIDB4NDApO1xuICAgIGdsLnN0ZW5jaWxNYXNrKDB4QzApO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5SRVBMQUNFLCBnbC5LRUVQLCBnbC5LRUVQKTtcblxuICAgIC8vIERyYXcgdGhlIGNsaXBwaW5nIG1hc2tcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuZmlsbFNoYWRlci5hX3BvcywgdGhpcy50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDgsIDApO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQpO1xuXG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5SRVBMQUNFKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG59O1xuXG5HTFBhaW50ZXIucHJvdG90eXBlLnByZXBhcmVCdWZmZXJzID0gZnVuY3Rpb24oKSB7fTsgLy8gT3ZlcnJpZGRlbiBieSBoZWFkbGVzcyB0ZXN0cy5cblxuLypcbiAqIERyYXcgYSBuZXcgdGlsZSB0byB0aGUgY29udGV4dCwgYXNzdW1pbmcgdGhhdCB0aGUgdmlld3BvcnQgaXNcbiAqIGFscmVhZHkgY29ycmVjdGx5IHNldC5cbiAqL1xuR0xQYWludGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gZ2xQYWludGVyRHJhdyh0aWxlLCBzdHlsZSwgbGF5ZXJzLCBwYXJhbXMsIG1hdHJpeCkge1xuICAgIHRoaXMudGlsZSA9IHRpbGU7XG5cbiAgICAvLyBmYWxzZSB3aGVuIGRyYXdpbmcgYSBncm91cCBvZiBjb21wb3NpdGVkIGxheWVyc1xuICAgIGlmICh0aWxlICYmICFtYXRyaXgpIHtcbiAgICAgICAgLy8gRHJhdyB0aGUgcm9vdCBjbGlwcGluZyBtYXNrLlxuICAgICAgICB0aGlzLmRyYXdDbGlwcGluZ01hc2soKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGF5ZXJzKSkgY29uc29sZS53YXJuKCdMYXllcnMgaXMgbm90IGFuIGFycmF5Jyk7XG5cbiAgICB0aGlzLmZyYW1lSGlzdG9yeS5yZWNvcmQodGhpcy50cmFuc2Zvcm0uem9vbSk7XG5cbiAgICAvLyBEcmF3IGxheWVycyBmcm9udC10by1iYWNrLlxuICAgIC8vIExheWVycyBhcmUgYWxyZWFkeSBpbiByZXZlcnNlIG9yZGVyIGZyb20gc3R5bGUucmVzdHJ1Y3R1cmUoKVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5hcHBseVN0eWxlKGxheWVyc1tpXSwgc3R5bGUsIHRpbGUgJiYgdGlsZS5idWNrZXRzLCBwYXJhbXMsIHRpbGUsIG1hdHJpeCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5kZWJ1Zykge1xuICAgICAgICBkcmF3RGVidWcodGhpcy5nbCwgdGhpcywgdGlsZSwgcGFyYW1zKTtcbiAgICB9XG59O1xuXG5HTFBhaW50ZXIucHJvdG90eXBlLmFwcGx5U3R5bGUgPSBmdW5jdGlvbihsYXllciwgc3R5bGUsIGJ1Y2tldHMsIHBhcmFtcywgdGlsZSwgbWF0cml4KSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHZhciBsYXllclN0eWxlID0gc3R5bGUuY29tcHV0ZWRbbGF5ZXIuaWRdO1xuICAgIGlmICghbGF5ZXJTdHlsZSB8fCBsYXllclN0eWxlLmhpZGRlbikgcmV0dXJuO1xuXG4gICAgaWYgKGxheWVyLmxheWVycyAmJiBsYXllci50eXBlID09PSAncmFzdGVyJykge1xuICAgICAgICBkcmF3UmFzdGVyKGdsLCB0aGlzLCBidWNrZXRzW2xheWVyLmJ1Y2tldF0sIGxheWVyU3R5bGUsIHBhcmFtcywgc3R5bGUsIGxheWVyLCB0aWxlKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5iYWNrZ3JvdW5kKSB7XG4gICAgICAgIGRyYXdCYWNrZ3JvdW5kKGdsLCB0aGlzLCB1bmRlZmluZWQsIGxheWVyU3R5bGUsIHRoaXMuaWRlbnRpdHlNYXRyaXgsIHBhcmFtcywgc3R5bGUuc3ByaXRlKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2xheWVyLmJ1Y2tldF07XG4gICAgICAgIC8vIFRoZXJlIGFyZSBubyB2ZXJ0aWNlcyB5ZXQgZm9yIHRoaXMgbGF5ZXIuXG4gICAgICAgIGlmICghYnVja2V0IHx8IChidWNrZXQuaGFzRGF0YSAmJiAhYnVja2V0Lmhhc0RhdGEoKSkpIHJldHVybjtcblxuICAgICAgICB2YXIgdHlwZSA9IGJ1Y2tldC50eXBlO1xuXG4gICAgICAgIGlmIChidWNrZXQubWluWm9vbSAmJiB0aGlzLnRyYW5zZm9ybS56b29tIDwgYnVja2V0Lm1pblpvb20pIHJldHVybjtcbiAgICAgICAgaWYgKGJ1Y2tldC5tYXhab29tICYmIHRoaXMudHJhbnNmb3JtLnpvb20gPj0gYnVja2V0Lm1heFpvb20pIHJldHVybjtcblxuICAgICAgICB2YXIgZHJhdyA9IHR5cGUgPT09ICdzeW1ib2wnID8gZHJhd1N5bWJvbCA6XG4gICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gJ2ZpbGwnID8gZHJhd0ZpbGwgOlxuICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdsaW5lJyA/IGRyYXdMaW5lIDpcbiAgICAgICAgICAgICAgICAgICB0eXBlID09PSAncmFzdGVyJyA/IGRyYXdSYXN0ZXIgOiBudWxsO1xuXG4gICAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgICAgICB2YXIgdXNlTWF0cml4ID0gbWF0cml4IHx8IHRoaXMudGlsZS5wb3NNYXRyaXg7XG4gICAgICAgICAgICBkcmF3KGdsLCB0aGlzLCBidWNrZXQsIGxheWVyU3R5bGUsIHVzZU1hdHJpeCwgcGFyYW1zLCBzdHlsZS5zcHJpdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBidWNrZXQgdHlwZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudmVydGljZXMgJiYgIWxheWVyLmxheWVycykge1xuICAgICAgICAgICAgZHJhd1ZlcnRpY2VzKGdsLCB0aGlzLCBidWNrZXQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gRHJhd3Mgbm9uLW9wYXF1ZSBhcmVhcy4gVGhpcyBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuR0xQYWludGVyLnByb3RvdHlwZS5kcmF3U3RlbmNpbEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuc3dpdGNoU2hhZGVyKHRoaXMuZmlsbFNoYWRlciwgdGhpcy5pZGVudGl0eU1hdHJpeCk7XG5cbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG5cbiAgICAvLyBEcncgdGhlIGZpbGxpbmcgcXVhZCB3aGVyZSB0aGUgc3RlbmNpbCBidWZmZXIgaXNuJ3Qgc2V0LlxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJhY2tncm91bmRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5maWxsU2hhZGVyLmFfcG9zLCB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wudW5pZm9ybTRmdih0aGlzLmZpbGxTaGFkZXIudV9jb2xvciwgWzAsIDAsIDAsIDAuNV0pO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtQ291bnQpO1xuXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XG59O1xuXG5HTFBhaW50ZXIucHJvdG90eXBlLnRyYW5zbGF0ZU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCwgeiwgdHJhbnNsYXRlLCBhbmNob3IpIHtcbiAgICBpZiAoIXRyYW5zbGF0ZVswXSAmJiAhdHJhbnNsYXRlWzFdKSByZXR1cm4gbWF0cml4O1xuXG4gICAgaWYgKGFuY2hvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgICB2YXIgc2luX2EgPSBNYXRoLnNpbigtdGhpcy50cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICB2YXIgY29zX2EgPSBNYXRoLmNvcygtdGhpcy50cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICB0cmFuc2xhdGUgPSBbXG4gICAgICAgICAgICB0cmFuc2xhdGVbMF0gKiBjb3NfYSAtIHRyYW5zbGF0ZVsxXSAqIHNpbl9hLFxuICAgICAgICAgICAgdHJhbnNsYXRlWzBdICogc2luX2EgKyB0cmFuc2xhdGVbMV0gKiBjb3NfYVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciB0aWxlUGl4ZWxSYXRpbyA9IHRoaXMudHJhbnNmb3JtLnNjYWxlIC8gKDEgPDwgeikgLyA4O1xuICAgIHZhciB0cmFuc2xhdGlvbiA9IFtcbiAgICAgICAgdHJhbnNsYXRlWzBdIC8gdGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIHRyYW5zbGF0ZVsxXSAvIHRpbGVQaXhlbFJhdGlvLFxuICAgICAgICAwXG4gICAgXTtcblxuICAgIHZhciB0cmFuc2xhdGVkTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgbWF0NC50cmFuc2xhdGUodHJhbnNsYXRlZE1hdHJpeCwgbWF0cml4LCB0cmFuc2xhdGlvbik7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZWRNYXRyaXg7XG59O1xuXG5HTFBhaW50ZXIucHJvdG90eXBlLnNhdmVUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSkge1xuICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMucmV1c2FibGVUZXh0dXJlc1t0ZXh0dXJlLnNpemVdO1xuICAgIGlmICghdGV4dHVyZXMpIHtcbiAgICAgICAgdGhpcy5yZXVzYWJsZVRleHR1cmVzW3RleHR1cmUuc2l6ZV0gPSBbdGV4dHVyZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICB9XG59O1xuXG5cbkdMUGFpbnRlci5wcm90b3R5cGUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnJldXNhYmxlVGV4dHVyZXNbc2l6ZV07XG4gICAgcmV0dXJuIHRleHR1cmVzICYmIHRleHR1cmVzLmxlbmd0aCA+IDAgPyB0ZXh0dXJlcy5wb3AoKSA6IG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xtYXRyaXggPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKTtcbnZhciBtYXQ0ID0gZ2xtYXRyaXgubWF0NDtcblxubW9kdWxlLmV4cG9ydHMgPSBQcmVyZW5kZXJlZFRleHR1cmU7XG5cbmZ1bmN0aW9uIFByZXJlbmRlcmVkVGV4dHVyZShnbCwgYnVja2V0LCBwYWludGVyKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuYnVmZmVyID0gYnVja2V0WydyYXN0ZXItYnVmZmVyJ10gfHwgKDEvMzIpO1xuICAgIHRoaXMuc2l6ZSA9IChidWNrZXRbJ3Jhc3Rlci1zaXplJ10gfHwgNTEyKSAqICgxICsgMiAqIHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLmZibyA9IG51bGw7XG4gICAgdGhpcy5mYm9zID0gdGhpcy5wYWludGVyLnByZUZib3NbdGhpcy5zaXplXTtcbn1cblxuUHJlcmVuZGVyZWRUZXh0dXJlLnByb3RvdHlwZS5iaW5kRnJhbWVidWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gdHJ5IHRvIHJldXNlIGF2YWlsYWJsZSByYXN0ZXIgdGV4dHVyZXNcbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLnBhaW50ZXIuZ2V0VGV4dHVyZSh0aGlzLnNpemUpO1xuXG4gICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICAgIHRoaXMudGV4dHVyZS5zaXplID0gdGhpcy5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZib3MpIHtcbiAgICAgICAgdGhpcy5mYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICB2YXIgc3RlbmNpbCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbCk7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5TVEVOQ0lMX0lOREVYOCwgdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLlNURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBzdGVuY2lsKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmJvID0gdGhpcy5mYm9zLnBvcCgpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUsIDApO1xuICAgIH1cbn07XG5cblByZXJlbmRlcmVkVGV4dHVyZS5wcm90b3R5cGUudW5iaW5kRnJhbWVidWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgaWYgKHRoaXMuZmJvcykgdGhpcy5mYm9zLnB1c2godGhpcy5mYm8pOyBlbHNlIHRoaXMucGFpbnRlci5wcmVGYm9zW3RoaXMuc2l6ZV0gPSBbdGhpcy5mYm9dO1xufTtcblxuUHJlcmVuZGVyZWRUZXh0dXJlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnRleHR1cmUpIHRocm93KCdwcmUtcmVuZGVyZWQgdGV4dHVyZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbn07XG5cblByZXJlbmRlcmVkVGV4dHVyZS5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uKHBhaW50ZXIsIHBhc3Nlcykge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIG9yaWdpbmFsVGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICB2YXIgc2Vjb25kYXJ5VGV4dHVyZSA9IHRoaXMucGFpbnRlci5nZXRUZXh0dXJlKHRoaXMuc2l6ZSk7XG4gICAgaWYgKCFzZWNvbmRhcnlUZXh0dXJlKSB7XG4gICAgICAgIHNlY29uZGFyeVRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHNlY29uZGFyeVRleHR1cmUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICAgIHNlY29uZGFyeVRleHR1cmUuc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzZWNvbmRhcnlUZXh0dXJlKTtcbiAgICB9XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cbiAgICB2YXIgbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICBtYXQ0Lm9ydGhvKG1hdHJpeCwgMCwgNDA5NiwgLTQwOTYsIDAsIDAsIDEpO1xuICAgIG1hdDQudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCBbMCwgLTQwOTYsIDBdKTtcblxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmdhdXNzaWFuU2hhZGVyLCBtYXRyaXgpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIGdsLnVuaWZvcm0xaShwYWludGVyLmdhdXNzaWFuU2hhZGVyLnVfaW1hZ2UsIDApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXNzZXM7IGkrKykge1xuXG4gICAgICAgIC8vIFJlbmRlciBob3Jpem9udGFsXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgc2Vjb25kYXJ5VGV4dHVyZSwgMCk7XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHBhaW50ZXIuZ2F1c3NpYW5TaGFkZXIudV9vZmZzZXQsIFsxIC8gdGhpcy5zaXplLCAwXSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9yaWdpbmFsVGV4dHVyZSk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZ2F1c3NpYW5TaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgMCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXG5cbiAgICAgICAgLy8gUmVuZGVyIHZlcnRpY2FsXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgb3JpZ2luYWxUZXh0dXJlLCAwKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYocGFpbnRlci5nYXVzc2lhblNoYWRlci51X29mZnNldCwgWzAsIDEgLyB0aGlzLnNpemVdKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc2Vjb25kYXJ5VGV4dHVyZSk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZ2F1c3NpYW5TaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgMCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIH1cblxuICAgIHRoaXMucGFpbnRlci5zYXZlVGV4dHVyZShzZWNvbmRhcnlUZXh0dXJlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbGlmeSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXCJkZWJ1Z1wiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbnVuaWZvcm0gZmxvYXQgdV9wb2ludHNpemU7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS53ID0gMS4wO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIHRtcHZhcl8xLnogPSBmbG9hdCgoYV9wb3MueCA+PSAzMjc2Ny4wKSk7XFxuICBnbF9Qb3NpdGlvbiA9ICh1X21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIGdsX1BvaW50U2l6ZSA9IHVfcG9pbnRzaXplO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG52b2lkIG1haW4gKClcXG57XFxuICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJkb3RcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3NpemU7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgZ2xfUG9zaXRpb24gPSAodV9tYXRyaXggKiB0bXB2YXJfMSk7XFxuICBnbF9Qb2ludFNpemUgPSB1X3NpemU7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9ibHVyO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIG1lZGl1bXAgdmVjMiB4XzE7XFxuICB4XzEgPSAoZ2xfUG9pbnRDb29yZCAtIDAuNSk7XFxuICBtZWRpdW1wIGZsb2F0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSBjbGFtcCAoKChcXG4gICAgc3FydChkb3QgKHhfMSwgeF8xKSlcXG4gICAtIDAuNSkgLyAoXFxuICAgICgwLjUgLSB1X2JsdXIpXFxuICAgLSAwLjUpKSwgMC4wLCAxLjApO1xcbiAgZ2xfRnJhZ0NvbG9yID0gKHVfY29sb3IgKiAodG1wdmFyXzIgKiAodG1wdmFyXzIgKiBcXG4gICAgKDMuMCAtICgyLjAgKiB0bXB2YXJfMikpXFxuICApKSk7XFxufVxcblxcblwifSxcbiAgICBcImZpbGxcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgZ2xfUG9zaXRpb24gPSAodV9tYXRyaXggKiB0bXB2YXJfMSk7XFxuICBnbF9Qb2ludFNpemUgPSAyLjA7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XFxufVxcblxcblwifSxcbiAgICBcImdhdXNzaWFuXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X29mZnNldDtcXG52YXJ5aW5nIGhpZ2hwIHZlYzIgYVszXTtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8xLnh5ID0gYV9wb3M7XFxuICB2ZWM0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSAodV9tYXRyaXggKiB0bXB2YXJfMSk7XFxuICBnbF9Qb3NpdGlvbiA9IHRtcHZhcl8yO1xcbiAgaGlnaHAgdmVjMiB0bXB2YXJfMztcXG4gIHRtcHZhcl8zID0gKCh0bXB2YXJfMi54eSAvIDIuMCkgKyAwLjUpO1xcbiAgYVswXSA9IHRtcHZhcl8zO1xcbiAgdmVjMiBjc2VfNDtcXG4gIGNzZV80ID0gKHVfb2Zmc2V0ICogMS4xODI0Myk7XFxuICBhWzFdID0gKHRtcHZhcl8zICsgY3NlXzQpO1xcbiAgYVsyXSA9ICh0bXB2YXJfMyAtIGNzZV80KTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgYVszXTtcXG52b2lkIG1haW4gKClcXG57XFxuICBsb3dwIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMSA9ICgoKHRleHR1cmUyRCAodV9pbWFnZSwgYVswXSkgKiAwLjQwMjYyKSArICh0ZXh0dXJlMkQgKHVfaW1hZ2UsIGFbMV0pICogMC4yOTg2OSkpICsgKHRleHR1cmUyRCAodV9pbWFnZSwgYVsyXSkgKiAwLjI5ODY5KSk7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMTtcXG59XFxuXFxuXCJ9LFxuICAgIFwibGluZVwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfZXh0cnVkZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9saW5lc29mYXI7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9yYXRpbztcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzIgY18xO1xcbiAgdmVjMiB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKHZlYzIobW9kIChhX3BvcywgMi4wKSkpO1xcbiAgY18xLnggPSB0bXB2YXJfMi54O1xcbiAgY18xLnkgPSBzaWduKCh0bXB2YXJfMi55IC0gMC41KSk7XFxuICBhID0gY18xO1xcbiAgdmVjNCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zLnp3ID0gdmVjMigwLjAsIDAuMCk7XFxuICB0bXB2YXJfMy54eSA9ICgodV9saW5ld2lkdGgueCAqIGFfZXh0cnVkZSkgKiAwLjAxNTg3Myk7XFxuICB2ZWM0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl80Lnh5ID0gZmxvb3IoKGFfcG9zICogMC41KSk7XFxuICBnbF9Qb3NpdGlvbiA9ICgodV9tYXRyaXggKiB0bXB2YXJfNCkgKyAodV9leG1hdHJpeCAqIHRtcHZhcl8zKSk7XFxuICBiID0gKGFfbGluZXNvZmFyICogdV9yYXRpbyk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIHZlYzIgdV9kYXNoYXJyYXk7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGZsb2F0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAoc3FydChkb3QgKGEsIGEpKSAqIHVfbGluZXdpZHRoLngpO1xcbiAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9IChmbG9hdChtb2QgKGIsICh1X2Rhc2hhcnJheS54ICsgdV9kYXNoYXJyYXkueSkpKSk7XFxuICBnbF9GcmFnQ29sb3IgPSAodV9jb2xvciAqIChjbGFtcCAoXFxuICAgIChtaW4gKCh0bXB2YXJfMSAtICh1X2xpbmV3aWR0aC55IC0gdV9ibHVyKSksICh1X2xpbmV3aWR0aC54IC0gdG1wdmFyXzEpKSAvIHVfYmx1cilcXG4gICwgMC4wLCAxLjApICogbWF4IChcXG4gICAgZmxvYXQoKC0odV9kYXNoYXJyYXkueSkgPj0gMC4wKSlcXG4gICwgXFxuICAgIGNsYW1wIChtaW4gKHRtcHZhcl8yLCAodV9kYXNoYXJyYXkueCAtIHRtcHZhcl8yKSksIDAuMCwgMS4wKVxcbiAgKSkpO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJsaW5lcGF0dGVyblwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfZXh0cnVkZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9saW5lc29mYXI7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9wb2ludDtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzIgY18xO1xcbiAgdmVjMiB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKHZlYzIobW9kIChhX3BvcywgMi4wKSkpO1xcbiAgY18xLnggPSB0bXB2YXJfMi54O1xcbiAgY18xLnkgPSBzaWduKCh0bXB2YXJfMi55IC0gMC41KSk7XFxuICBhID0gY18xO1xcbiAgdmVjNCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMy54eSA9IGZsb29yKChhX3BvcyAvIDIuMCkpO1xcbiAgdmVjNCB0bXB2YXJfNDtcXG4gIHRtcHZhcl80LncgPSAwLjA7XFxuICB0bXB2YXJfNC54eSA9ICgodV9saW5ld2lkdGgueCAqIChhX2V4dHJ1ZGUgLyA2My4wKSkgKiAoMS4wIC0gdV9wb2ludCkpO1xcbiAgdG1wdmFyXzQueiA9IChmbG9hdCgoYV9wb3MueCA+PSAzMjc2Ny4wKSkgKyAodV9wb2ludCAqIGZsb2F0KFxcbiAgICAoY18xLnkgPj0gMS4wKVxcbiAgKSkpO1xcbiAgZ2xfUG9zaXRpb24gPSAoKHVfbWF0cml4ICogdG1wdmFyXzMpICsgKHVfZXhtYXRyaXggKiB0bXB2YXJfNCkpO1xcbiAgYiA9IGFfbGluZXNvZmFyO1xcbiAgZ2xfUG9pbnRTaXplID0gKCgyLjAgKiB1X2xpbmV3aWR0aC54KSAtIDEuMCk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3NpemU7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyO1xcbnVuaWZvcm0gZmxvYXQgdV9wb2ludDtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBsb3dwIHZlYzQgal8xO1xcbiAgbWVkaXVtcCB2ZWMyIHhfMjtcXG4gIHhfMiA9ICgoZ2xfUG9pbnRDb29yZCAqIDIuMCkgLSAxLjApO1xcbiAgbWVkaXVtcCBmbG9hdCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zID0gKCgoXFxuICAgIHNxcnQoZG90IChhLCBhKSlcXG4gICAqIFxcbiAgICAoMS4wIC0gdV9wb2ludClcXG4gICkgKyAodV9wb2ludCAqIFxcbiAgICBzcXJ0KGRvdCAoeF8yLCB4XzIpKVxcbiAgKSkgKiB1X2xpbmV3aWR0aC54KTtcXG4gIGZsb2F0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQgPSAoZmxvYXQobW9kICgoYiAvIHVfcGF0dGVybl9zaXplLngpLCAxLjApKSk7XFxuICBmbG9hdCB0bXB2YXJfNTtcXG4gIHRtcHZhcl81ID0gKDAuNSArICgoYS55ICogdV9saW5ld2lkdGgueCkgLyB1X3BhdHRlcm5fc2l6ZS55KSk7XFxuICB2ZWMyIHRtcHZhcl82O1xcbiAgdG1wdmFyXzYueCA9IHRtcHZhcl80O1xcbiAgdG1wdmFyXzYueSA9IHRtcHZhcl81O1xcbiAgdmVjMiB0bXB2YXJfNztcXG4gIHRtcHZhcl83LnggPSAoZmxvYXQobW9kICgodG1wdmFyXzQgKiAyLjApLCAxLjApKSk7XFxuICB0bXB2YXJfNy55ID0gdG1wdmFyXzU7XFxuICBsb3dwIHZlYzQgdG1wdmFyXzg7XFxuICB0bXB2YXJfOCA9ICgodGV4dHVyZTJEICh1X2ltYWdlLCBtaXggKHVfcGF0dGVybl90bCwgdV9wYXR0ZXJuX2JyLCB0bXB2YXJfNikpICogKDEuMCAtIHVfZmFkZSkpICsgKHVfZmFkZSAqIHRleHR1cmUyRCAodV9pbWFnZSwgbWl4ICh1X3BhdHRlcm5fdGwsIHVfcGF0dGVybl9iciwgdG1wdmFyXzcpKSkpO1xcbiAgal8xLncgPSB0bXB2YXJfOC53O1xcbiAgal8xLnh5eiA9ICh0bXB2YXJfOC54eXogKiB0bXB2YXJfOC53KTtcXG4gIGdsX0ZyYWdDb2xvciA9IChqXzEgKiBjbGFtcCAoKFxcbiAgICBtaW4gKCh0bXB2YXJfMyAtICh1X2xpbmV3aWR0aC55IC0gdV9ibHVyKSksICh1X2xpbmV3aWR0aC54IC0gdG1wdmFyXzMpKVxcbiAgIC8gdV9ibHVyKSwgMC4wLCAxLjApKTtcXG59XFxuXFxuXCJ9LFxuICAgIFwib3V0bGluZVwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV93b3JsZDtcXG52YXJ5aW5nIGhpZ2hwIHZlYzIgYTtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8xLnh5ID0gYV9wb3M7XFxuICB2ZWM0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSAodV9tYXRyaXggKiB0bXB2YXJfMSk7XFxuICBnbF9Qb3NpdGlvbiA9IHRtcHZhcl8yO1xcbiAgYSA9ICgoKHRtcHZhcl8yLnh5ICsgMS4wKSAvIDIuMCkgKiB1X3dvcmxkKTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudmFyeWluZyB2ZWMyIGE7XFxudm9pZCBtYWluICgpXFxue1xcbiAgaGlnaHAgdmVjMiB4XzE7XFxuICB4XzEgPSAoYSAtIGdsX0ZyYWdDb29yZC54eSk7XFxuICBoaWdocCBmbG9hdCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gY2xhbXAgKCgoXFxuICAgIHNxcnQoZG90ICh4XzEsIHhfMSkpXFxuICAgLSAxLjApIC8gLTEuMCksIDAuMCwgMS4wKTtcXG4gIGhpZ2hwIHZlYzQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMyA9ICh1X2NvbG9yICogKHRtcHZhcl8yICogKHRtcHZhcl8yICogXFxuICAgICgzLjAgLSAoMi4wICogdG1wdmFyXzIpKVxcbiAgKSkpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdG1wdmFyXzM7XFxufVxcblxcblwifSxcbiAgICBcInBhdHRlcm5cIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVfcGF0dGVybm1hdHJpeDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG52YXJ5aW5nIHZlYzIgYTtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8xLnh5ID0gYV9wb3M7XFxuICBnbF9Qb3NpdGlvbiA9ICh1X21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIHZlYzMgdG1wdmFyXzI7XFxuICB0bXB2YXJfMi56ID0gMS4wO1xcbiAgdG1wdmFyXzIueHkgPSBhX3BvcztcXG4gIGEgPSAodV9wYXR0ZXJubWF0cml4ICogdG1wdmFyXzIpLnh5O1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHVfbWl4O1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGw7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icjtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzIgdG1wdmFyXzE7XFxuICB0bXB2YXJfMSA9ICh2ZWMyKG1vZCAoYSwgMS4wKSkpO1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSAobWl4ICh0ZXh0dXJlMkQgKHVfaW1hZ2UsIG1peCAodV9wYXR0ZXJuX3RsLCB1X3BhdHRlcm5fYnIsIHRtcHZhcl8xKSksIHRleHR1cmUyRCAodV9pbWFnZSwgbWl4ICh1X3BhdHRlcm5fdGwsIHVfcGF0dGVybl9iciwgXFxuICAgICh2ZWMyKG1vZCAoKHRtcHZhcl8xICogMi4wKSwgMS4wKSkpXFxuICApKSwgdV9taXgpICogdV9vcGFjaXR5KTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8yO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJyYXN0ZXJcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfdGxfcGFyZW50O1xcbnVuaWZvcm0gZmxvYXQgdV9zY2FsZV9wYXJlbnQ7XFxudW5pZm9ybSBmbG9hdCB1X2J1ZmZlcl9zY2FsZTtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleHR1cmVfcG9zO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgdmVjMiBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIGdsX1Bvc2l0aW9uID0gKHVfbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgdmVjMiB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKCgoXFxuICAgIChhX3RleHR1cmVfcG9zIC8gMzI3NjcuMClcXG4gICAtIDAuNSkgLyB1X2J1ZmZlcl9zY2FsZSkgKyAwLjUpO1xcbiAgYSA9IHRtcHZhcl8yO1xcbiAgYiA9ICgodG1wdmFyXzIgKiB1X3NjYWxlX3BhcmVudCkgKyB1X3RsX3BhcmVudCk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5MDtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTE7XFxudW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3NfbG93O1xcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2hpZ2g7XFxudW5pZm9ybSBmbG9hdCB1X3NhdHVyYXRpb25fZmFjdG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9jb250cmFzdF9mYWN0b3I7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTE7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyB2ZWMyIGI7XFxudW5pZm9ybSB2ZWMzIHVfc3Bpbl93ZWlnaHRzO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGxvd3AgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKCh0ZXh0dXJlMkQgKHVfaW1hZ2UwLCBhKSAqIHVfb3BhY2l0eTApICsgKHRleHR1cmUyRCAodV9pbWFnZTEsIGIpICogdV9vcGFjaXR5MSkpO1xcbiAgbG93cCB2ZWMzIHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIueCA9IGRvdCAodG1wdmFyXzEueHl6LCB1X3NwaW5fd2VpZ2h0cyk7XFxuICB0bXB2YXJfMi55ID0gZG90ICh0bXB2YXJfMS54eXosIHVfc3Bpbl93ZWlnaHRzLnp4eSk7XFxuICB0bXB2YXJfMi56ID0gZG90ICh0bXB2YXJfMS54eXosIHVfc3Bpbl93ZWlnaHRzLnl6eCk7XFxuICBsb3dwIHZlYzQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMy54eXogPSBtaXggKHZlYzModV9icmlnaHRuZXNzX2xvdyksIHZlYzModV9icmlnaHRuZXNzX2hpZ2gpLCAoKFxcbiAgICAoKHRtcHZhcl8yICsgKChcXG4gICAgICAoKCh0bXB2YXJfMS54ICsgdG1wdmFyXzEueSkgKyB0bXB2YXJfMS56KSAvIDMuMClcXG4gICAgIC0gdG1wdmFyXzIpICogdV9zYXR1cmF0aW9uX2ZhY3RvcikpIC0gMC41KVxcbiAgICogdV9jb250cmFzdF9mYWN0b3IpICsgMC41KSk7XFxuICB0bXB2YXJfMy53ID0gdG1wdmFyXzEudztcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8zO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJpY29uXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9vZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXg7XFxuYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7XFxuYXR0cmlidXRlIGZsb2F0IGFfbWluem9vbTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9tYXh6b29tO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3JhbmdlZW5kO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3Jhbmdlc3RhcnQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfbGFiZWxtaW56b29tO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9leG1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfYW5nbGU7XFxudW5pZm9ybSBmbG9hdCB1X3pvb207XFxudW5pZm9ybSBmbG9hdCB1X2ZsaXA7XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGVkaXN0O1xcbnVuaWZvcm0gZmxvYXQgdV9taW5mYWRlem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfbWF4ZmFkZXpvb207XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O1xcbnVuaWZvcm0gdmVjMiB1X3RleHNpemU7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGZsb2F0IGRfMTtcXG4gIGRfMSA9IDAuMDtcXG4gIGZsb2F0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSAoZmxvYXQobW9kICgoYV9hbmdsZSArIHVfYW5nbGUpLCAyNTYuMCkpKTtcXG4gIGlmICgoKCh1X2ZsaXAgPiAwLjApICYmICh0bXB2YXJfMiA+PSA2NC4wKSkgJiYgKHRtcHZhcl8yIDwgMTkyLjApKSkge1xcbiAgICBkXzEgPSAxLjA7XFxuICB9O1xcbiAgZmxvYXQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMyA9ICgoKDIuMCAtIFxcbiAgICBmbG9hdCgodV96b29tID49IGFfbWluem9vbSkpXFxuICApIC0gKDEuMCAtIFxcbiAgICBmbG9hdCgodV96b29tID49IGFfbWF4em9vbSkpXFxuICApKSArIGRfMSk7XFxuICBmbG9hdCB0bXB2YXJfNDtcXG4gIHRtcHZhcl80ID0gY2xhbXAgKCgodV9mYWRlem9vbSAtIGFfbGFiZWxtaW56b29tKSAvIHVfZmFkZWRpc3QpLCAwLjAsIDEuMCk7XFxuICBpZiAoKHVfZmFkZWRpc3QgPj0gMC4wKSkge1xcbiAgICBiID0gdG1wdmFyXzQ7XFxuICB9IGVsc2Uge1xcbiAgICBiID0gKDEuMCAtIHRtcHZhcl80KTtcXG4gIH07XFxuICBpZiAoKHVfbWF4ZmFkZXpvb20gPCBhX2xhYmVsbWluem9vbSkpIHtcXG4gICAgYiA9IDAuMDtcXG4gIH07XFxuICBpZiAoKHVfbWluZmFkZXpvb20gPj0gYV9sYWJlbG1pbnpvb20pKSB7XFxuICAgIGIgPSAxLjA7XFxuICB9O1xcbiAgdmVjNCB0bXB2YXJfNTtcXG4gIHRtcHZhcl81Lnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfNS54eSA9IGFfcG9zO1xcbiAgdmVjNCB0bXB2YXJfNjtcXG4gIHRtcHZhcl82LncgPSAwLjA7XFxuICB0bXB2YXJfNi54eSA9IChhX29mZnNldCAvIDY0LjApO1xcbiAgdG1wdmFyXzYueiA9ICgodG1wdmFyXzMgKyBmbG9hdChcXG4gICAgKDAuMCA+PSBiKVxcbiAgKSkgKyAoZmxvYXQoXFxuICAgICh1X2FuZ2xlID49IGFfcmFuZ2VlbmQpXFxuICApICogKDEuMCAtIFxcbiAgICBmbG9hdCgodV9hbmdsZSA+PSBhX3Jhbmdlc3RhcnQpKVxcbiAgKSkpO1xcbiAgZ2xfUG9zaXRpb24gPSAoKHVfbWF0cml4ICogdG1wdmFyXzUpICsgKHVfZXhtYXRyaXggKiB0bXB2YXJfNikpO1xcbiAgYSA9IChhX3RleCAvIHVfdGV4c2l6ZSk7XFxuICBiID0gKGIgKiB1X29wYWNpdHkpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGxvd3AgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKHRleHR1cmUyRCAodV90ZXh0dXJlLCBhKSAqIGIpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdG1wdmFyXzE7XFxufVxcblxcblwifSxcbiAgICBcInNkZlwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfb2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4O1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2FuZ2xlO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX21pbnpvb207XFxuYXR0cmlidXRlIGZsb2F0IGFfbWF4em9vbTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYW5nZWVuZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYW5nZXN0YXJ0O1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2xhYmVsbWluem9vbTtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVfZXhtYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X2FuZ2xlO1xcbnVuaWZvcm0gZmxvYXQgdV96b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9mbGlwO1xcbnVuaWZvcm0gZmxvYXQgdV9mYWRlZGlzdDtcXG51bmlmb3JtIGZsb2F0IHVfbWluZmFkZXpvb207XFxudW5pZm9ybSBmbG9hdCB1X21heGZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9mYWRlem9vbTtcXG51bmlmb3JtIHZlYzIgdV90ZXhzaXplO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBmbG9hdCBjXzE7XFxuICBjXzEgPSAwLjA7XFxuICBmbG9hdCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKGZsb2F0KG1vZCAoKGFfYW5nbGUgKyB1X2FuZ2xlKSwgMjU2LjApKSk7XFxuICBpZiAoKCgodV9mbGlwID4gMC4wKSAmJiAodG1wdmFyXzIgPj0gNjQuMCkpICYmICh0bXB2YXJfMiA8IDE5Mi4wKSkpIHtcXG4gICAgY18xID0gMS4wO1xcbiAgfTtcXG4gIGZsb2F0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAoKCgyLjAgLSBcXG4gICAgZmxvYXQoKHVfem9vbSA+PSBhX21pbnpvb20pKVxcbiAgKSAtICgxLjAgLSBcXG4gICAgZmxvYXQoKHVfem9vbSA+PSBhX21heHpvb20pKVxcbiAgKSkgKyBjXzEpO1xcbiAgZmxvYXQgdG1wdmFyXzQ7XFxuICB0bXB2YXJfNCA9IGNsYW1wICgoKHVfZmFkZXpvb20gLSBhX2xhYmVsbWluem9vbSkgLyB1X2ZhZGVkaXN0KSwgMC4wLCAxLjApO1xcbiAgaWYgKCh1X2ZhZGVkaXN0ID49IDAuMCkpIHtcXG4gICAgYiA9IHRtcHZhcl80O1xcbiAgfSBlbHNlIHtcXG4gICAgYiA9ICgxLjAgLSB0bXB2YXJfNCk7XFxuICB9O1xcbiAgaWYgKCh1X21heGZhZGV6b29tIDwgYV9sYWJlbG1pbnpvb20pKSB7XFxuICAgIGIgPSAwLjA7XFxuICB9O1xcbiAgaWYgKCh1X21pbmZhZGV6b29tID49IGFfbGFiZWxtaW56b29tKSkge1xcbiAgICBiID0gMS4wO1xcbiAgfTtcXG4gIHZlYzQgdG1wdmFyXzU7XFxuICB0bXB2YXJfNS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzUueHkgPSBhX3BvcztcXG4gIHZlYzQgdG1wdmFyXzY7XFxuICB0bXB2YXJfNi53ID0gMC4wO1xcbiAgdG1wdmFyXzYueHkgPSAoYV9vZmZzZXQgLyA2NC4wKTtcXG4gIHRtcHZhcl82LnogPSAoKHRtcHZhcl8zICsgZmxvYXQoXFxuICAgICgwLjAgPj0gYilcXG4gICkpICsgKGZsb2F0KFxcbiAgICAodV9hbmdsZSA+PSBhX3JhbmdlZW5kKVxcbiAgKSAqICgxLjAgLSBcXG4gICAgZmxvYXQoKHVfYW5nbGUgPj0gYV9yYW5nZXN0YXJ0KSlcXG4gICkpKTtcXG4gIGdsX1Bvc2l0aW9uID0gKCh1X21hdHJpeCAqIHRtcHZhcl81KSArICh1X2V4bWF0cml4ICogdG1wdmFyXzYpKTtcXG4gIGEgPSAoYV90ZXggLyB1X3RleHNpemUpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2J1ZmZlcjtcXG51bmlmb3JtIGZsb2F0IHVfZ2FtbWE7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGZsb2F0IGVkZ2UwXzE7XFxuICBlZGdlMF8xID0gKHVfYnVmZmVyIC0gdV9nYW1tYSk7XFxuICBsb3dwIGZsb2F0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSBjbGFtcCAoKCh0ZXh0dXJlMkQgKHVfdGV4dHVyZSwgYSkudyAtIGVkZ2UwXzEpIC8gKFxcbiAgICAodV9idWZmZXIgKyB1X2dhbW1hKVxcbiAgIC0gZWRnZTBfMSkpLCAwLjAsIDEuMCk7XFxuICBsb3dwIHZlYzQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMyA9ICh1X2NvbG9yICogKCh0bXB2YXJfMiAqIFxcbiAgICAodG1wdmFyXzIgKiAoMy4wIC0gKDIuMCAqIHRtcHZhcl8yKSkpXFxuICApICogYikpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdG1wdmFyXzM7XFxufVxcblxcblwifVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcbnZhciBTb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS5qcycpO1xudmFyIEdlb0pTT05UaWxlID0gcmVxdWlyZSgnLi9nZW9qc29udGlsZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb0pTT05Tb3VyY2U7XG5cbmZ1bmN0aW9uIEdlb0pTT05Tb3VyY2Uob3B0aW9ucykge1xuICAgIHRoaXMuX3RpbGVzID0ge307XG4gICAgdGhpcy5fYWxsdGlsZXMgPSB7fTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuem9vbXMgPSBbMSwgNSwgOSwgMTNdO1xuICAgIHRoaXMubWluVGlsZVpvb20gPSB0aGlzLnpvb21zWzBdO1xuICAgIHRoaXMubWF4VGlsZVpvb20gPSB0aGlzLnpvb21zW3RoaXMuem9vbXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xufVxuXG5HZW9KU09OU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChTb3VyY2UsIHtcbiAgICBtaW56b29tOiAxLFxuICAgIG1heHpvb206IDEzLFxuXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAodGhpcy5tYXApIHRoaXMuX3VwZGF0ZURhdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMucGFpbnRlciA9IG1hcC5wYWludGVyO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcC5zdHlsZSkgdGhpcy5fdXBkYXRlRGF0YSgpO1xuICAgICAgICBtYXAub24oJ3N0eWxlLmNoYW5nZScsIHRoaXMuX3VwZGF0ZURhdGEuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHRoaXMud29ya2VySUQgPSB0aGlzLm1hcC5kaXNwYXRjaGVyLnNlbmQoJ3BhcnNlIGdlb2pzb24nLCB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICB6b29tczogdGhpcy56b29tcyxcbiAgICAgICAgICAgIHRpbGVTaXplOiA1MTIsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCB0aWxlcykge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5fYWxsdGlsZXNbdGlsZXNbaV0uaWRdID0gbmV3IEdlb0pTT05UaWxlKHRpbGVzW2ldLmlkLCBzb3VyY2UsIHRpbGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UubWFwKSBzb3VyY2UubWFwLnVwZGF0ZSgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FkZFRpbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5fYWxsdGlsZXNbaWRdO1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgICAgdGlsZS5fbG9hZCgpO1xuICAgICAgICAgICAgdGhpcy5fdGlsZXNbaWRdID0gdGlsZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5hZGQnLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWxlIHx8IHt9O1xuICAgIH0sXG5cbiAgICBfY292ZXJpbmdab29tTGV2ZWw6IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuem9vbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnpvb21zW2ldIDw9IHpvb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgeiA9IHRoaXMuem9vbXNbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlLmpzJyk7XG52YXIgQnVmZmVyU2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWZmZXIvYnVmZmVyc2V0LmpzJyk7XG52YXIgY3JlYXRlQnVja2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9jcmVhdGVidWNrZXQuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9KU09OVGlsZTtcblxuZnVuY3Rpb24gR2VvSlNPTlRpbGUoaWQsIHNvdXJjZSwgZGF0YSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMud29ya2VySUQgPSBzb3VyY2Uud29ya2VySUQ7XG59XG5cbkdlb0pTT05UaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGlsZS5wcm90b3R5cGUpO1xuXG5HZW9KU09OVGlsZS5wcm90b3R5cGUuX2xvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5sb2FkZWQpIHJldHVybjtcbiAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgQnVmZmVyU2V0KGRhdGEuYnVmZmVycyk7XG5cbiAgICB0aGlzLmJ1Y2tldHMgPSB7fTtcbiAgICBmb3IgKHZhciBiIGluIGRhdGEuZWxlbWVudEdyb3Vwcykge1xuICAgICAgICB0aGlzLmJ1Y2tldHNbYl0gPSBjcmVhdGVCdWNrZXQodGhpcy5zb3VyY2UubWFwLnN0eWxlLmJ1Y2tldHNbYl0sIHRoaXMuYnVmZmVycywgdW5kZWZpbmVkLCBkYXRhLmVsZW1lbnRHcm91cHNbYl0pO1xuICAgIH1cblxuXG59O1xuXG4vLyBub29wc1xuR2VvSlNPTlRpbGUucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7IH07XG5HZW9KU09OVGlsZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcHBlcjtcblxuLy8gY29uZm9ybSB0byB2ZWN0b3J0aWxlIGFwaVxuZnVuY3Rpb24gV3JhcHBlcihmZWF0dXJlcykge1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICB0aGlzLmxlbmd0aCA9IGZlYXR1cmVzLmxlbmd0aDtcbn1cblxuV3JhcHBlci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gbmV3IEZlYXR1cmVXcmFwcGVyKHRoaXMuZmVhdHVyZXNbaV0pO1xufTtcblxudmFyIG1hcHBpbmcgPSB7XG4gICAgJ1BvaW50JzogMSxcbiAgICAnTGluZVN0cmluZyc6IDIsXG4gICAgJ1BvbHlnb24nOiAzXG59O1xuXG5mdW5jdGlvbiBGZWF0dXJlV3JhcHBlcihmZWF0dXJlKSB7XG4gICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICB0aGlzLnR5cGUgPSBtYXBwaW5nW2ZlYXR1cmUudHlwZV07XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gZmVhdHVyZS5wcm9wZXJ0aWVzO1xufVxuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUubG9hZEdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5jb29yZHM7XG59O1xuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gbWFwcGluZy5Qb2ludCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmNvb3Jkc1swXVswXS54LFxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmNvb3Jkc1swXVswXS55LFxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmNvb3Jkc1swXVswXS54LFxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmNvb3Jkc1swXVswXS55XG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIHJpbmdzID0gdGhpcy5mZWF0dXJlLmNvb3JkcztcblxuICAgIHZhciB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSByaW5nW2pdO1xuXG4gICAgICAgICAgICB4MSA9IE1hdGgubWluKHgxLCBjb29yZC54KTtcbiAgICAgICAgICAgIHgyID0gTWF0aC5tYXgoeDIsIGNvb3JkLngpO1xuICAgICAgICAgICAgeTEgPSBNYXRoLm1pbih5MSwgY29vcmQueSk7XG4gICAgICAgICAgICB5MiA9IE1hdGgubWF4KHkyLCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRpbGUgPSByZXF1aXJlKCcuL3RpbGUuanMnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4LmpzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhc3RlclRpbGU7XG5cbmZ1bmN0aW9uIFJhc3RlclRpbGUoaWQsIHNvdXJjZSwgdXJsLCBjYWxsYmFjaykge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcbiAgICB0aGlzLl9sb2FkKCk7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMudXNlcyA9IDE7XG5cbiAgICAvLyBUb2RvIGZpbmlzaCBmaWd1cmluZyBvdXQgd2hhdCByYXN0ZXIgYnVja2V0cyBhcmVcbiAgICB0aGlzLmJ1Y2tldHMgPSB7fTtcbiAgICB0aGlzLmluZm8gPSB7IHJhc3RlcjogdHJ1ZSB9O1xuICAgIHZhciBidWNrZXRzID0gdGhpcy5tYXAuc3R5bGUuYnVja2V0cztcbiAgICBmb3IgKHZhciBiIGluIGJ1Y2tldHMpIHtcbiAgICAgICAgdmFyIGJ1Y2tldCA9IGJ1Y2tldHNbYl07XG4gICAgICAgIHZhciBzb3VyY2VpZCA9IGJ1Y2tldCAmJiBidWNrZXQuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLmlkID09PSBzb3VyY2VpZCkge1xuICAgICAgICAgICAgdGhpcy5idWNrZXRzW2JdID0ge1xuICAgICAgICAgICAgICAgIGluZm86IGJ1Y2tldC5yZW5kZXIsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jhc3RlcicsXG4gICAgICAgICAgICAgICAgdGlsZTogdGhpc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuUmFzdGVyVGlsZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoVGlsZSwge1xuICAgIF9sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzO1xuICAgICAgICBhamF4LmdldEltYWdlKHRoaXMudXJsLCBmdW5jdGlvbihlcnIsIGltZykge1xuICAgICAgICAgICAgLy8gQFRPRE8gaGFuZGxlIGVycm9ycy5cbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybjtcbiAgICAgICAgICAgIHRpbGUuaW1nID0gaW1nO1xuICAgICAgICAgICAgaWYgKHRpbGUubWFwKSB0aWxlLm9uVGlsZUxvYWQoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uVGlsZUxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzdGFydCB0ZXh0dXJlIHVwbG9hZFxuICAgICAgICB0aGlzLmJpbmQodGhpcy5tYXAucGFpbnRlci5nbCk7XG5cbiAgICAgICAgdGhpcy50aW1lQWRkZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5tYXAuYW5pbWF0aW9uTG9vcC5zZXQodGhpcy5tYXAuc3R5bGUucmFzdGVyRmFkZUR1cmF0aW9uKTtcblxuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICB9LFxuXG4gICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pbWcpIHRoaXMuaW1nLnNyYyA9ICcnO1xuICAgICAgICBkZWxldGUgdGhpcy5pbWc7XG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uKGdsKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gZmluZCByZXVzYWJsZSB0ZXh0dXJlXG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLm1hcC5wYWludGVyLmdldFRleHR1cmUodGhpcy5pbWcud2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmltZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5pbWcpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5zaXplID0gdGhpcy5pbWcud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkgdGhpcy5tYXAucGFpbnRlci5zYXZlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xuICAgICAgICBkZWxldGUgdGhpcy5tYXA7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzQXQ6IGZ1bmN0aW9uKHBvcywgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBub29wXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyksXG4gICAgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheC5qcycpLFxuICAgIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94LmpzJykubm9ybWFsaXplU291cmNlVVJMLFxuICAgIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQuanMnKSxcbiAgICBDYWNoZSA9IHJlcXVpcmUoJy4uL3V0aWwvbXJ1Y2FjaGUuanMnKSxcbiAgICBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVjb29yZCcpLFxuICAgIFZlY3RvclRpbGUgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGUnKSxcbiAgICBSYXN0ZXJUaWxlID0gcmVxdWlyZSgnLi9yYXN0ZXJ0aWxlLmpzJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvdXJjZTtcblxuZnVuY3Rpb24gU291cmNlKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLFxuICAgICAgICAndHlwZScsICd1cmwnLCAndGlsZVNpemUnKSk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndmVjdG9yJyAmJiB0aGlzLnRpbGVTaXplICE9PSA1MTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZWN0b3IgdGlsZSBzb3VyY2VzIG11c3QgaGF2ZSBhIHRpbGVTaXplIG9mIDUxMicpO1xuICAgIH1cblxuICAgIHRoaXMuVGlsZSA9IHRoaXMudHlwZSA9PT0gJ3ZlY3RvcicgPyBWZWN0b3JUaWxlIDogUmFzdGVyVGlsZTtcblxuICAgIHRoaXMuX3RpbGVzID0ge307XG4gICAgdGhpcy5fY2FjaGUgPSBuZXcgQ2FjaGUodGhpcy5jYWNoZVNpemUsIGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihlcnIsIHRpbGVKU09OKSB7XG4gICAgICAgIGlmIChlcnIpIHRocm93IGVycjtcblxuICAgICAgICBpZiAoIXRpbGVKU09OLnRpbGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHRpbGVzIHByb3BlcnR5Jyk7XG5cbiAgICAgICAgdXRpbC5leHRlbmQodGhpcywgdXRpbC5waWNrKHRpbGVKU09OLFxuICAgICAgICAgICAgJ3RpbGVzJywgJ21pbnpvb20nLCAnbWF4em9vbScsICdhdHRyaWJ1dGlvbicpKTtcblxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlyZSgnc291cmNlLmFkZCcsIHtzb3VyY2U6IHRoaXN9KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAodGhpcy51cmwpIHtcbiAgICAgICAgYWpheC5nZXRKU09OKG5vcm1hbGl6ZVVSTCh0aGlzLnVybCksIGxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGVkKG51bGwsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVRpbGVzID0gdXRpbC50aHJvdHRsZSh0aGlzLl91cGRhdGVUaWxlcywgNTAsIHRoaXMpO1xufVxuXG5Tb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIHtcbiAgICBtaW56b29tOiAwLFxuICAgIG1heHpvb206IDIyLFxuICAgIHRpbGVTaXplOiA1MTIsXG4gICAgY2FjaGVTaXplOiAyMCxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMucGFpbnRlciA9IG1hcC5wYWludGVyO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgICAgdGhpcy5fdGlsZXNbdF0uX2xvYWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RpbGVzW3RdLmxvYWRlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVzKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgICAgIC8vIEl0ZXJhdGl2ZWx5IHBhaW50IGV2ZXJ5IHRpbGUuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIHZhciBvcmRlciA9IE9iamVjdC5rZXlzKHRoaXMuX3RpbGVzKTtcbiAgICAgICAgb3JkZXIuc29ydCh0aGlzLl96X29yZGVyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gb3JkZXJbaV07XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgICAgIGlmICh0aWxlLmxvYWRlZCAmJiAhdGhpcy5jb3ZlcmVkVGlsZXNbaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGlsZSh0aWxlLCBpZCwgbGF5ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmZWF0dXJlc0F0OiBmdW5jdGlvbihwb2ludCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBwb2ludCA9IFBvaW50LmNvbnZlcnQocG9pbnQpO1xuXG4gICAgICAgIGlmIChwYXJhbXMubGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMubWFwLnN0eWxlLFxuICAgICAgICAgICAgICAgIGxheWVyID0gc3R5bGUuZ2V0TGF5ZXIocGFyYW1zLmxheWVyKTtcbiAgICAgICAgICAgIHBhcmFtcy5idWNrZXQgPSBzdHlsZS5idWNrZXRzW2xheWVyLnJlZiB8fCBsYXllci5pZF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JkZXIgPSBPYmplY3Qua2V5cyh0aGlzLl90aWxlcyk7XG4gICAgICAgIG9yZGVyLnNvcnQodGhpcy5fel9vcmRlcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG9yZGVyW2ldO1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgICAgICB2YXIgcG9zID0gdGlsZS5wb3NpdGlvbkF0KGlkLCBwb2ludCk7XG5cbiAgICAgICAgICAgIGlmIChwb3MgJiYgcG9zLnggPj0gMCAmJiBwb3MueCA8IDQwOTYgJiYgcG9zLnkgPj0gMCAmJiBwb3MueSA8IDQwOTYpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2xpY2sgaXMgd2l0aGluIHRoZSB2aWV3cG9ydC4gVGhlcmUgaXMgb25seSBldmVyIG9uZSB0aWxlIGluXG4gICAgICAgICAgICAgICAgLy8gYSBsYXllciB0aGF0IGhhcyB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlLmZlYXR1cmVzQXQocG9zLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IHRoZSB6b29tIGxldmVsIGFkanVzdGVkIGZvciB0aGUgZGlmZmVyZW5jZSBpbiBtYXAgYW5kIHNvdXJjZSB0aWxlc2l6ZXNcbiAgICBfZ2V0Wm9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB6T2Zmc2V0ID0gTWF0aC5sb2codGhpcy5tYXAudHJhbnNmb3JtLnRpbGVTaXplIC8gdGhpcy50aWxlU2l6ZSkgLyBNYXRoLkxOMjtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnRyYW5zZm9ybS56b29tICsgek9mZnNldDtcbiAgICB9LFxuXG4gICAgX2NvdmVyaW5nWm9vbUxldmVsOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIGZvciAodmFyIHogPSB0aGlzLm1heHpvb207IHogPj0gdGhpcy5taW56b29tOyB6LS0pIHtcbiAgICAgICAgICAgIGlmICh6IDw9IHpvb20pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAncmFzdGVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB1bmRlcnNjYWxpbmcgYnkgcm91bmRpbmcgdG8gdGhlIG5lYXJlc3Qgem9vbSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBpZiAoeiA8IHRoaXMubWF4em9vbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeiArPSBNYXRoLnJvdW5kKHpvb20gLSB6KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgX2NoaWxkWm9vbUxldmVsOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIHpvb20gPSBNYXRoLm1heCh0aGlzLm1pbnpvb20sIHpvb20gKyAxKTtcbiAgICAgICAgcmV0dXJuIHpvb20gPD0gdGhpcy5tYXh6b29tID8gem9vbSA6IG51bGw7XG4gICAgfSxcblxuICAgIF9nZXRDb3ZlcmluZ1RpbGVzOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHpvb20gPSB0aGlzLl9nZXRab29tKCk7XG4gICAgICAgIHZhciB6ID0gdGhpcy5fY292ZXJpbmdab29tTGV2ZWwoem9vbSksXG4gICAgICAgICAgICB0aWxlcyA9IDEgPDwgeixcbiAgICAgICAgICAgIHRyID0gdGhpcy5tYXAudHJhbnNmb3JtLFxuICAgICAgICAgICAgdGlsZUNlbnRlciA9IFRpbGVDb29yZC56b29tVG8odHIubG9jYXRpb25Db29yZGluYXRlKHRyLmNlbnRlciksIHopO1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAgICAgICBUaWxlQ29vcmQuem9vbVRvKHRyLnBvaW50Q29vcmRpbmF0ZSh0aWxlQ2VudGVyLCB7eDogMCwgeTogMH0pLCB6KSxcbiAgICAgICAgICAgIFRpbGVDb29yZC56b29tVG8odHIucG9pbnRDb29yZGluYXRlKHRpbGVDZW50ZXIsIHt4OiB0ci53aWR0aCwgeTogMH0pLCB6KSxcbiAgICAgICAgICAgIFRpbGVDb29yZC56b29tVG8odHIucG9pbnRDb29yZGluYXRlKHRpbGVDZW50ZXIsIHt4OiB0ci53aWR0aCwgeTogdHIuaGVpZ2h0fSksIHopLFxuICAgICAgICAgICAgVGlsZUNvb3JkLnpvb21Ubyh0ci5wb2ludENvb3JkaW5hdGUodGlsZUNlbnRlciwge3g6IDAsIHk6IHRyLmhlaWdodH0pLCB6KVxuICAgICAgICBdLCB0ID0ge307XG5cbiAgICAgICAgLy8gRGl2aWRlIHRoZSBzY3JlZW4gdXAgaW4gdHdvIHRyaWFuZ2xlcyBhbmQgc2NhbiBlYWNoIG9mIHRoZW06XG4gICAgICAgIC8vICstLS0vXG4gICAgICAgIC8vIHwgLyB8XG4gICAgICAgIC8vIC8tLS0rXG4gICAgICAgIHRoaXMuX3NjYW5UcmlhbmdsZShwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCAwLCB0aWxlcywgc2NhbkxpbmUpO1xuICAgICAgICB0aGlzLl9zY2FuVHJpYW5nbGUocG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1swXSwgMCwgdGlsZXMsIHNjYW5MaW5lKTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModCkuc29ydChmcm9tQ2VudGVyKTtcblxuICAgICAgICBmdW5jdGlvbiBmcm9tQ2VudGVyKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhZCA9IE1hdGguYWJzKGEueCAtIHRpbGVDZW50ZXIuY29sdW1uKSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGEueSAtIHRpbGVDZW50ZXIucm93KSxcbiAgICAgICAgICAgICAgICBiZCA9IE1hdGguYWJzKGIueCAtIHRpbGVDZW50ZXIuY29sdW1uKSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGIueSAtIHRpbGVDZW50ZXIucm93KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFkIC0gYmQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzY2FuTGluZSh4MCwgeDEsIHkpIHtcbiAgICAgICAgICAgIHZhciB4LCB3eDtcbiAgICAgICAgICAgIGlmICh5ID49IDAgJiYgeSA8PSB0aWxlcykge1xuICAgICAgICAgICAgICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICB3eCA9ICh4ICsgdGlsZXMpICUgdGlsZXM7XG4gICAgICAgICAgICAgICAgICAgIHRbVGlsZUNvb3JkLnRvSUQoeiwgd3gsIHksIE1hdGguZmxvb3IoeC90aWxlcykpXSA9IHt4OiB3eCwgeTogeX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdpdmVuIGEgdGlsZSBvZiBkYXRhLCBpdHMgaWQsIGFuZCBhIHN0eWxlIGxheWVycywgcmVuZGVyIHRoZSB0aWxlIHRvIHRoZSBjYW52YXNcbiAgICBfcmVuZGVyVGlsZTogZnVuY3Rpb24odGlsZSwgaWQsIGxheWVycykge1xuICAgICAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XG4gICAgICAgIHZhciB6ID0gcG9zLnosIHggPSBwb3MueCwgeSA9IHBvcy55LCB3ID0gcG9zLnc7XG4gICAgICAgIHggKz0gdyAqICgxIDw8IHopO1xuXG4gICAgICAgIHRpbGUuY2FsY3VsYXRlTWF0cmljZXMoeiwgeCwgeSwgdGhpcy5tYXAudHJhbnNmb3JtLCB0aGlzLnBhaW50ZXIpO1xuXG4gICAgICAgIHRoaXMucGFpbnRlci5kcmF3KHRpbGUsIHRoaXMubWFwLnN0eWxlLCBsYXllcnMsIHtcbiAgICAgICAgICAgIHo6IHosIHg6IHgsIHk6IHksXG4gICAgICAgICAgICBkZWJ1ZzogdGhpcy5tYXAuZGVidWcsXG4gICAgICAgICAgICBhbnRpYWxpYXNpbmc6IHRoaXMubWFwLmFudGlhbGlhc2luZyxcbiAgICAgICAgICAgIHZlcnRpY2VzOiB0aGlzLm1hcC52ZXJ0aWNlcyxcbiAgICAgICAgICAgIHJvdGF0aW5nOiB0aGlzLm1hcC5yb3RhdGluZyxcbiAgICAgICAgICAgIHpvb21pbmc6IHRoaXMubWFwLnpvb21pbmdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGZpbmQgY2hpbGRyZW4gb2YgdGhlIGdpdmVuIHRpbGUgKHVwIHRvIG1heENvdmVyaW5nWm9vbSkgdGhhdCBhcmUgYWxyZWFkeSBsb2FkZWQ7XG4gICAgLy8gYWRkcyBmb3VuZCB0aWxlcyB0byByZXRhaW4gb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgY2hpbGRyZW4gY29tcGxldGVseSBjb3ZlciB0aGUgdGlsZVxuXG4gICAgX2ZpbmRMb2FkZWRDaGlsZHJlbjogZnVuY3Rpb24oaWQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHZhciB6ID0gVGlsZUNvb3JkLmZyb21JRChpZCkuejtcbiAgICAgICAgdmFyIGlkcyA9IFRpbGVDb29yZC5jaGlsZHJlbihpZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGlsZXNbaWRzW2ldXSAmJiB0aGlzLl90aWxlc1tpZHNbaV1dLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHJldGFpbltpZHNbaV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoeiA8IG1heENvdmVyaW5nWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHbyBmdXJ0aGVyIGRvd24gdGhlIGhpZXJhcmNoeSB0byBmaW5kIG1vcmUgdW5sb2FkZWQgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRMb2FkZWRDaGlsZHJlbihpZHNbaV0sIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGEgbG9hZGVkIHBhcmVudCBvZiB0aGUgZ2l2ZW4gdGlsZSAodXAgdG8gbWluQ292ZXJpbmdab29tKTtcbiAgICAvLyBhZGRzIHRoZSBmb3VuZCB0aWxlIHRvIHJldGFpbiBvYmplY3QgYW5kIHJldHVybnMgdHJ1ZSBpZiBhIHBhcmVudCB3YXMgZm91bmRcblxuICAgIF9maW5kTG9hZGVkUGFyZW50OiBmdW5jdGlvbihpZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pIHtcbiAgICAgICAgZm9yICh2YXIgeiA9IFRpbGVDb29yZC5mcm9tSUQoaWQpLno7IHogPj0gbWluQ292ZXJpbmdab29tOyB6LS0pIHtcbiAgICAgICAgICAgIGlkID0gVGlsZUNvb3JkLnBhcmVudChpZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGlsZXNbaWRdICYmIHRoaXMuX3RpbGVzW2lkXS5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXRhaW5baWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZXMgdGlsZXMgdGhhdCBhcmUgb3V0c2lkZSB0aGUgdmlld3BvcnQgYW5kIGFkZHMgbmV3IHRpbGVzIHRoYXQgYXJlIGluc2lkZSB0aGUgdmlld3BvcnQuXG4gICAgX3VwZGF0ZVRpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcCB8fCAhdGhpcy5tYXAubG9hZE5ld1RpbGVzIHx8XG4gICAgICAgICAgICAhdGhpcy5tYXAuc3R5bGUgfHwgIXRoaXMubWFwLnN0eWxlLnNvdXJjZXMgfHwgIXRoaXMubWFwLnN0eWxlLnNvdXJjZXNbdGhpcy5pZF0pIHJldHVybjtcblxuICAgICAgICB2YXIgem9vbSA9IE1hdGguZmxvb3IodGhpcy5fZ2V0Wm9vbSgpKTtcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gdGhpcy5fZ2V0Q292ZXJpbmdUaWxlcygpLnNvcnQodGhpcy5fY2VudGVyT3V0LmJpbmQodGhpcykpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICB2YXIgY29tcGxldGU7XG4gICAgICAgIHZhciB0aWxlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgb3Zlcnpvb21pbmcvdW5kZXJ6b29taW5nIGFtb3VudHMuXG4gICAgICAgIHZhciBtaW5Db3ZlcmluZ1pvb20gPSBNYXRoLm1heCh0aGlzLm1pbnpvb20sIHpvb20gLSAxMCk7XG4gICAgICAgIHZhciBtYXhDb3ZlcmluZ1pvb20gPSB0aGlzLm1pbnpvb207XG4gICAgICAgIHdoaWxlIChtYXhDb3ZlcmluZ1pvb20gPCB6b29tICsgMSkge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5fY2hpbGRab29tTGV2ZWwobWF4Q292ZXJpbmdab29tKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgICAgICBlbHNlIG1heENvdmVyaW5nWm9vbSA9IGxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0YWluIGlzIGEgbGlzdCBvZiB0aWxlcyB0aGF0IHdlIHNob3VsZG4ndCBkZWxldGUsIGV2ZW4gaWYgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHRoZSBtb3N0IGlkZWFsIHRpbGUgZm9yIHRoZSBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIG1heSBpbmNsdWRlIHRpbGVzIGxpa2VcbiAgICAgICAgLy8gcGFyZW50IG9yIGNoaWxkIHRpbGVzIHRoYXQgYXJlICphbHJlYWR5KiBsb2FkZWQuXG4gICAgICAgIHZhciByZXRhaW4gPSB7fTtcbiAgICAgICAgLy8gQ292ZXJlZCBpcyBhIGxpc3Qgb2YgcmV0YWluZWQgdGlsZXMgd2hvJ3MgYXJlYXMgYXJlIGZ1bGwgY292ZXJlZCBieSBvdGhlcixcbiAgICAgICAgLy8gYmV0dGVyLCByZXRhaW5lZCB0aWxlcy4gVGhleSBhcmUgbm90IGRyYXduIHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuY292ZXJlZFRpbGVzID0ge307XG5cbiAgICAgICAgdmFyIGZ1bGx5Q29tcGxldGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIEFkZCBleGlzdGluZyBjaGlsZC9wYXJlbnQgdGlsZXMgaWYgdGhlIGFjdHVhbCB0aWxlIGlzIG5vdCB5ZXQgbG9hZGVkXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXF1aXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWQgPSArcmVxdWlyZWRbaV07XG4gICAgICAgICAgICByZXRhaW5baWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl9hZGRUaWxlKGlkKTtcblxuICAgICAgICAgICAgaWYgKCF0aWxlLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0aWxlIHdlIHJlcXVpcmUgaXMgbm90IHlldCBsb2FkZWQuIFRyeSB0byBmaW5kIGEgcGFyZW50IG9yXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgdGlsZSB0aGF0IHdlIGFscmVhZHkgaGF2ZS5cblxuICAgICAgICAgICAgICAgIC8vIEZpcnN0LCB0cnkgdG8gZmluZCBleGlzdGluZyBjaGlsZCB0aWxlcyB0aGF0IGNvbXBsZXRlbHkgY292ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gbWlzc2luZyB0aWxlLlxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gdGhpcy5fZmluZExvYWRlZENoaWxkcmVuKGlkLCBtYXhDb3ZlcmluZ1pvb20sIHJldGFpbik7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuLCBpZiB0aGVyZSBhcmUgbm8gY29tcGxldGUgY2hpbGQgdGlsZXMsIHRyeSB0byBmaW5kIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IHRpbGVzIHRoYXQgY29tcGxldGVseSBjb3ZlciB0aGUgbWlzc2luZyB0aWxlLlxuICAgICAgICAgICAgICAgIGlmICghY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSB0aGlzLl9maW5kTG9hZGVkUGFyZW50KGlkLCBtaW5Db3ZlcmluZ1pvb20sIHJldGFpbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHVubG9hZGVkIHRpbGUncyBhcmVhIGlzIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgbG9hZGVkIHRpbGVzXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBmdWxseUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgZmFkZUR1cmF0aW9uID0gdGhpcy50eXBlID09PSAncmFzdGVyJyA/IHRoaXMubWFwLnN0eWxlLnJhc3RlckZhZGVEdXJhdGlvbiA6IDA7XG5cbiAgICAgICAgZm9yIChpZCBpbiByZXRhaW4pIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLnRpbWVBZGRlZCA+IG5vdyAtIGZhZGVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdGlsZSBpcyBzdGlsbCBmYWRpbmcgaW4uIEZpbmQgdGlsZXMgdG8gY3Jvc3MtZmFkZSB3aXRoIGl0LlxuXG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSB0aGlzLl9maW5kTG9hZGVkQ2hpbGRyZW4oaWQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdmVyZWRUaWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRMb2FkZWRQYXJlbnQoaWQsIG1pbkNvdmVyaW5nWm9vbSwgcmV0YWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGlkIGluIHRoaXMuY292ZXJlZFRpbGVzKSByZXRhaW5baWRdID0gdHJ1ZTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRpbGVzIHdlIGRvbid0IG5lZWQgYW55bW9yZS5cbiAgICAgICAgdmFyIHJlbW92ZSA9IHV0aWwua2V5c0RpZmZlcmVuY2UodGhpcy5fdGlsZXMsIHJldGFpbik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gK3JlbW92ZVtpXTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRpbGUoaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcztcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLFxuICAgICAgICAgICAgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCksXG4gICAgICAgICAgICB0aWxlO1xuXG4gICAgICAgIGlmIChwb3MudyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS50aW1lKCdsb2FkaW5nICcgKyBwb3MueiArICcvJyArIHBvcy54ICsgJy8nICsgcG9zLnkpO1xuICAgICAgICAgICAgdmFyIHVybCA9IFRpbGVDb29yZC51cmwoaWQsIHRoaXMudGlsZXMpO1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXSA9IG5ldyB0aGlzLlRpbGUoaWQsIHRoaXMsIHVybCwgdGlsZUNvbXBsZXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gVGlsZUNvb3JkLnRvSUQocG9zLnosIHBvcy54LCBwb3MueSwgMCk7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNbaWRdID0gdGhpcy5fdGlsZXNbd3JhcHBlZF0gfHwgdGhpcy5fYWRkVGlsZSh3cmFwcGVkKTtcbiAgICAgICAgICAgIHRpbGUudXNlcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdGlsZUNvbXBsZXRlKGVycikge1xuICAgICAgICAgICAgLy8gY29uc29sZS50aW1lRW5kKCdsb2FkaW5nICcgKyBwb3MueiArICcvJyArIHBvcy54ICsgJy8nICsgcG9zLnkpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZmFpbGVkIHRvIGxvYWQgdGlsZSAlZC8lZC8lZDogJXMnLCBwb3MueiwgcG9zLngsIHBvcy55LCBlcnIuc3RhY2sgfHwgZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZmlyZSgndGlsZS5sb2FkJywge3RpbGU6IHRpbGV9KTtcbiAgICAgICAgICAgICAgICBtYXAudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgLy8gQWRkcyBhIHZlY3RvciB0aWxlIHRvIHRoZSBtYXAuIEl0IHdpbGwgdHJpZ2dlciBhIHJlcmVuZGVyIG9mIHRoZSBtYXAgYW5kIHdpbGxcbiAgICAvLyBiZSBwYXJ0IGluIGFsbCBmdXR1cmUgcmVuZGVycyBvZiB0aGUgbWFwLiBUaGUgbWFwIG9iamVjdCB3aWxsIGhhbmRsZSBjb3B5aW5nXG4gICAgLy8gdGhlIHRpbGUgZGF0YSB0byB0aGUgR1BVIGlmIGl0IGlzIHJlcXVpcmVkIHRvIHBhaW50IHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICAgIF9hZGRUaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl9jYWNoZS5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgICAgICB0aWxlLnVzZXMgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVzW2lkXSA9IHRpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl9sb2FkVGlsZShpZCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlVGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aWxlLnVzZXMtLTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90aWxlc1tpZF07XG5cbiAgICAgICAgICAgIGlmICh0aWxlLnVzZXMgPD0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aWxlLnRpbWVBZGRlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5hZGQoaWQsIHRpbGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5yZW1vdmUnLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFRha2VuIGZyb20gcG9seW1hcHMgc3JjL0xheWVyLmpzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbXBsZWdlby9wb2x5bWFwcy9ibG9iL21hc3Rlci9zcmMvTGF5ZXIuanMjTDMzMy1MMzgzXG5cbiAgICAvLyBzY2FuLWxpbmUgY29udmVyc2lvblxuICAgIF9zY2FuVHJpYW5nbGU6IGZ1bmN0aW9uKGEsIGIsIGMsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgICAgIHZhciBhYiA9IHRoaXMuX2VkZ2UoYSwgYiksXG4gICAgICAgICAgICBiYyA9IHRoaXMuX2VkZ2UoYiwgYyksXG4gICAgICAgICAgICBjYSA9IHRoaXMuX2VkZ2UoYywgYSk7XG5cbiAgICAgICAgdmFyIHQ7XG5cbiAgICAgICAgLy8gc29ydCBlZGdlcyBieSB5LWxlbmd0aFxuICAgICAgICBpZiAoYWIuZHkgPiBiYy5keSkgeyB0ID0gYWI7IGFiID0gYmM7IGJjID0gdDsgfVxuICAgICAgICBpZiAoYWIuZHkgPiBjYS5keSkgeyB0ID0gYWI7IGFiID0gY2E7IGNhID0gdDsgfVxuICAgICAgICBpZiAoYmMuZHkgPiBjYS5keSkgeyB0ID0gYmM7IGJjID0gY2E7IGNhID0gdDsgfVxuXG4gICAgICAgIC8vIHNjYW4gc3BhbiEgc2NhbiBzcGFuIVxuICAgICAgICBpZiAoYWIuZHkpIHRoaXMuX3NjYW5TcGFucyhjYSwgYWIsIHltaW4sIHltYXgsIHNjYW5MaW5lKTtcbiAgICAgICAgaWYgKGJjLmR5KSB0aGlzLl9zY2FuU3BhbnMoY2EsIGJjLCB5bWluLCB5bWF4LCBzY2FuTGluZSk7XG4gICAgfSxcblxuICAgIC8vIHNjYW4tbGluZSBjb252ZXJzaW9uXG4gICAgX2VkZ2U6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKGEucm93ID4gYi5yb3cpIHsgdmFyIHQgPSBhOyBhID0gYjsgYiA9IHQ7IH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgwOiBhLmNvbHVtbixcbiAgICAgICAgICAgIHkwOiBhLnJvdyxcbiAgICAgICAgICAgIHgxOiBiLmNvbHVtbixcbiAgICAgICAgICAgIHkxOiBiLnJvdyxcbiAgICAgICAgICAgIGR4OiBiLmNvbHVtbiAtIGEuY29sdW1uLFxuICAgICAgICAgICAgZHk6IGIucm93IC0gYS5yb3dcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gc2Nhbi1saW5lIGNvbnZlcnNpb25cbiAgICBfc2NhblNwYW5zOiBmdW5jdGlvbihlMCwgZTEsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgICAgIHZhciB5MCA9IE1hdGgubWF4KHltaW4sIE1hdGguZmxvb3IoZTEueTApKSxcbiAgICAgICAgICAgIHkxID0gTWF0aC5taW4oeW1heCwgTWF0aC5jZWlsKGUxLnkxKSk7XG5cbiAgICAgICAgLy8gc29ydCBlZGdlcyBieSB4LWNvb3JkaW5hdGVcbiAgICAgICAgaWYgKChlMC54MCA9PSBlMS54MCAmJiBlMC55MCA9PSBlMS55MCkgP1xuICAgICAgICAgICAgKGUwLngwICsgZTEuZHkgLyBlMC5keSAqIGUwLmR4IDwgZTEueDEpIDpcbiAgICAgICAgICAgIChlMC54MSAtIGUxLmR5IC8gZTAuZHkgKiBlMC5keCA8IGUxLngwKSkge1xuICAgICAgICAgICAgdmFyIHQgPSBlMDsgZTAgPSBlMTsgZTEgPSB0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NhbiBsaW5lcyFcbiAgICAgICAgdmFyIG0wID0gZTAuZHggLyBlMC5keSxcbiAgICAgICAgICAgIG0xID0gZTEuZHggLyBlMS5keSxcbiAgICAgICAgICAgIGQwID0gZTAuZHggPiAwLCAvLyB1c2UgeSArIDEgdG8gY29tcHV0ZSB4MFxuICAgICAgICAgICAgZDEgPSBlMS5keCA8IDA7IC8vIHVzZSB5ICsgMSB0byBjb21wdXRlIHgxXG4gICAgICAgIGZvciAodmFyIHkgPSB5MDsgeSA8IHkxOyB5KyspIHtcbiAgICAgICAgICAgIHZhciB4MCA9IG0wICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTAuZHksIHkgKyBkMCAtIGUwLnkwKSkgKyBlMC54MCxcbiAgICAgICAgICAgICAgICB4MSA9IG0xICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTEuZHksIHkgKyBkMSAtIGUxLnkwKSkgKyBlMS54MDtcbiAgICAgICAgICAgIHNjYW5MaW5lKE1hdGguZmxvb3IoeDEpLCBNYXRoLmNlaWwoeDApLCB5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfel9vcmRlcjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKGIgJSAzMikgLSAoYSAlIDMyKTtcbiAgICB9LFxuXG4gICAgX2NlbnRlck91dDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICB2YXIgdHIgPSB0aGlzLm1hcC50cmFuc2Zvcm07XG4gICAgICAgIHZhciBhUG9zID0gVGlsZUNvb3JkLmZyb21JRChhKTtcbiAgICAgICAgdmFyIGJQb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGIpO1xuICAgICAgICB2YXIgYyA9IFRpbGVDb29yZC56b29tVG8odHIubG9jYXRpb25Db29yZGluYXRlKHRyLmNlbnRlciksIGFQb3Mueik7XG4gICAgICAgIHZhciBjZW50ZXIgPSBuZXcgUG9pbnQoYy5jb2x1bW4gLSAwLjUsIGMucm93IC0gMC41KTtcbiAgICAgICAgcmV0dXJuIGNlbnRlci5kaXN0KGFQb3MpIC0gY2VudGVyLmRpc3QoYlBvcyk7XG4gICAgfSxcbn0pO1xuXG52YXIgc291cmNlcyA9IHtcbiAgICB2ZWN0b3I6IFNvdXJjZSxcbiAgICByYXN0ZXI6IFNvdXJjZSxcbiAgICBnZW9qc29uOiByZXF1aXJlKCcuL2dlb2pzb25zb3VyY2UnKSxcbiAgICB2aWRlbzogcmVxdWlyZSgnLi92aWRlb3NvdXJjZScpXG59O1xuXG5Tb3VyY2UuY3JlYXRlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBzb3VyY2VzW3NvdXJjZS50eXBlXShzb3VyY2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsbWF0cml4ID0gcmVxdWlyZSgnLi4vbGliL2dsbWF0cml4LmpzJyksXG4gICAgbWF0MiA9IGdsbWF0cml4Lm1hdDIsXG4gICAgbWF0NCA9IGdsbWF0cml4Lm1hdDQsXG4gICAgdmVjMiA9IGdsbWF0cml4LnZlYzI7XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZTtcblxuZnVuY3Rpb24gVGlsZSgpIHt9XG5cblRpbGUucHJvdG90eXBlID0ge1xuICAgIC8vIHRvZG8gdW5oYXJkY29kZVxuICAgIHRpbGVFeHRlbnQ6IDQwOTYsXG5cbiAgICBjYWxjdWxhdGVNYXRyaWNlczogZnVuY3Rpb24oeiwgeCwgeSwgdHJhbnNmb3JtLCBwYWludGVyKSB7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtb2RlbC12aWV3IG1hdHJpeCB0aGF0IGNvbnZlcnRzIGZyb20gdGhlIHRpbGUgY29vcmRpbmF0ZXNcbiAgICAgICAgLy8gdG8gc2NyZWVuIGNvb3JkaW5hdGVzLlxuICAgICAgICB2YXIgdGlsZVNjYWxlID0gTWF0aC5wb3coMiwgeik7XG4gICAgICAgIHZhciBzY2FsZSA9IHRyYW5zZm9ybS53b3JsZFNpemUgLyB0aWxlU2NhbGU7XG5cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcblxuICAgICAgICAvLyBUaGUgcG9zaXRpb24gbWF0cml4XG4gICAgICAgIHRoaXMucG9zTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5wb3NNYXRyaXgsIHRoaXMucG9zTWF0cml4LCBbdHJhbnNmb3JtLmNlbnRlclBvaW50LngsIHRyYW5zZm9ybS5jZW50ZXJQb2ludC55LCAwXSk7XG4gICAgICAgIG1hdDQucm90YXRlWih0aGlzLnBvc01hdHJpeCwgdGhpcy5wb3NNYXRyaXgsIHRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMucG9zTWF0cml4LCB0aGlzLnBvc01hdHJpeCwgWy10cmFuc2Zvcm0uY2VudGVyUG9pbnQueCwgLXRyYW5zZm9ybS5jZW50ZXJQb2ludC55LCAwXSk7XG5cbiAgICAgICAgdmFyIHBpeGVsWCA9IHRyYW5zZm9ybS53aWR0aCAvIDIgLSB0cmFuc2Zvcm0ueCxcbiAgICAgICAgICAgIHBpeGVsWSA9IHRyYW5zZm9ybS5oZWlnaHQgLyAyIC0gdHJhbnNmb3JtLnk7XG5cbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5wb3NNYXRyaXgsIHRoaXMucG9zTWF0cml4LCBbcGl4ZWxYICsgeCAqIHNjYWxlLCBwaXhlbFkgKyB5ICogc2NhbGUsIDFdKTtcblxuICAgICAgICAvLyBDcmVhdGUgaW52ZXJ0ZWQgbWF0cml4IGZvciBpbnRlcmFjdGlvblxuICAgICAgICB0aGlzLmludlBvc01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIG1hdDQuaW52ZXJ0KHRoaXMuaW52UG9zTWF0cml4LCB0aGlzLnBvc01hdHJpeCk7XG5cbiAgICAgICAgbWF0NC5zY2FsZSh0aGlzLnBvc01hdHJpeCwgdGhpcy5wb3NNYXRyaXgsIFsgc2NhbGUgLyB0aGlzLnRpbGVFeHRlbnQsIHNjYWxlIC8gdGhpcy50aWxlRXh0ZW50LCAxIF0pO1xuICAgICAgICBtYXQ0Lm11bHRpcGx5KHRoaXMucG9zTWF0cml4LCBwYWludGVyLnByb2plY3Rpb25NYXRyaXgsIHRoaXMucG9zTWF0cml4KTtcblxuICAgICAgICAvLyBUaGUgZXh0cnVzaW9uIG1hdHJpeC5cbiAgICAgICAgdGhpcy5leE1hdHJpeCA9IG1hdDQuY2xvbmUocGFpbnRlci5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgICAgbWF0NC5yb3RhdGVaKHRoaXMuZXhNYXRyaXgsIHRoaXMuZXhNYXRyaXgsIHRyYW5zZm9ybS5hbmdsZSk7XG5cbiAgICAgICAgLy8gMngyIG1hdHJpeCBmb3Igcm90YXRpbmcgcG9pbnRzXG4gICAgICAgIHRoaXMucm90YXRpb25NYXRyaXggPSBtYXQyLmNyZWF0ZSgpO1xuICAgICAgICBtYXQyLnJvdGF0ZSh0aGlzLnJvdGF0aW9uTWF0cml4LCB0aGlzLnJvdGF0aW9uTWF0cml4LCB0cmFuc2Zvcm0uYW5nbGUpO1xuICAgIH0sXG5cbiAgICBwb3NpdGlvbkF0OiBmdW5jdGlvbihpZCwgcG9pbnQpIHtcbiAgICAgICAgLy8gdGlsZSBoYXNuJ3QgZmluaXNoZWQgbG9hZGluZ1xuICAgICAgICBpZiAoIXRoaXMuaW52UG9zTWF0cml4KSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgcG9zID0gdmVjMi50cmFuc2Zvcm1NYXQ0KFtdLCBbcG9pbnQueCwgcG9pbnQueV0sIHRoaXMuaW52UG9zTWF0cml4KTtcbiAgICAgICAgdmVjMi5zY2FsZShwb3MsIHBvcywgNDA5NiAvIHRoaXMuc2NhbGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9zLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc291cmNlLm1hcC5kaXNwYXRjaGVyLnNlbmQoJ3F1ZXJ5IGZlYXR1cmVzJywge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgIHk6IHBvcy55LFxuICAgICAgICAgICAgc2NhbGU6IHBvcy5zY2FsZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UuaWQsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9LCBjYWxsYmFjaywgdGhpcy53b3JrZXJJRCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAqIFRpbGVzIGFyZSBnZW5lcmFsbHkgcmVwcmVzZW50ZWQgYXMgcGFja2VkIGludGVnZXIgaWRzIGNvbnN0cnVjdGVkIGJ5XG4gKiBgVGlsZUNvb3JkLnRvSUQoeCwgeSwgeilgXG4gKi9cblxudmFyIFRpbGVDb29yZCA9IGV4cG9ydHM7XG5cblRpbGVDb29yZC50b0lEID0gZnVuY3Rpb24oeiwgeCwgeSwgdykge1xuICAgIHcgPSB3IHx8IDA7XG4gICAgdyAqPSAyO1xuICAgIGlmICh3IDwgMCkgdyA9IHcgKiAtMSAtMTtcbiAgICB2YXIgZGltID0gMSA8PCB6O1xuICAgIHJldHVybiAoKGRpbSAqIGRpbSAqIHcgKyBkaW0gKiB5ICsgeCkgKiAzMikgKyB6O1xufTtcblxuVGlsZUNvb3JkLmFzU3RyaW5nID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XG4gICAgcmV0dXJuIHBvcy56ICsgXCIvXCIgKyBwb3MueCArIFwiL1wiICsgcG9zLnk7XG59O1xuXG4vKlxuICogUGFyc2UgYSBwYWNrZWQgaW50ZWdlciBpZCBpbnRvIGFuIG9iamVjdCB3aXRoIHgsIHksIGFuZCB6IHByb3BlcnRpZXNcbiAqL1xuVGlsZUNvb3JkLmZyb21JRCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHogPSBpZCAlIDMyLCBkaW0gPSAxIDw8IHo7XG4gICAgdmFyIHh5ID0gKChpZCAtIHopIC8gMzIpO1xuICAgIHZhciB4ID0geHkgJSBkaW0sIHkgPSAoKHh5IC0geCkgLyBkaW0pICUgZGltO1xuICAgIHZhciB3ID0gTWF0aC5mbG9vcih4eSAvIChkaW0gKiBkaW0pKTtcbiAgICBpZiAodyAlIDIgIT09IDApIHcgPSB3ICogLTEgLTE7XG4gICAgdyAvPSAyO1xuICAgIHJldHVybiB7IHo6IHosIHg6IHgsIHk6IHksIHc6IHcgfTtcbn07XG5cbi8qXG4gKiBHaXZlbiBhIHBhY2tlZCBpbnRlZ2VyIGlkLCByZXR1cm4gaXRzIHpvb20gbGV2ZWxcbiAqL1xuVGlsZUNvb3JkLnpvb20gPSBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBpZCAlIDMyO1xufTtcblxuLy8gR2l2ZW4gYW4gaWQgYW5kIGEgbGlzdCBvZiB1cmxzLCBjaG9vc2UgYSB1cmwgdGVtcGxhdGUgYW5kIHJldHVybiBhIHRpbGUgVVJMXG5UaWxlQ29vcmQudXJsID0gZnVuY3Rpb24oaWQsIHVybHMpIHtcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XG5cbiAgICByZXR1cm4gdXJsc1socG9zLnggKyBwb3MueSkgJSB1cmxzLmxlbmd0aF1cbiAgICAgICAgLnJlcGxhY2UoJ3tofScsIChwb3MueCAlIDE2KS50b1N0cmluZygxNikgKyAocG9zLnkgJSAxNikudG9TdHJpbmcoMTYpKVxuICAgICAgICAucmVwbGFjZSgne3p9JywgcG9zLnopXG4gICAgICAgIC5yZXBsYWNlKCd7eH0nLCBwb3MueClcbiAgICAgICAgLnJlcGxhY2UoJ3t5fScsIHBvcy55KTtcbn07XG5cbi8qXG4gKiBHaXZlbiBhIHBhY2tlZCBpbnRlZ2VyIGlkLCByZXR1cm4gdGhlIGlkIG9mIGl0cyBwYXJlbnQgdGlsZVxuICovXG5UaWxlQ29vcmQucGFyZW50ID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XG4gICAgaWYgKHBvcy56ID09PSAwKSByZXR1cm4gaWQ7XG4gICAgZWxzZSByZXR1cm4gVGlsZUNvb3JkLnRvSUQocG9zLnogLSAxLCBNYXRoLmZsb29yKHBvcy54IC8gMiksIE1hdGguZmxvb3IocG9zLnkgLyAyKSk7XG59O1xuXG5UaWxlQ29vcmQucGFyZW50V2l0aFpvb20gPSBmdW5jdGlvbihpZCwgem9vbSkge1xuICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcbiAgICB3aGlsZSAocG9zLnogPiB6b29tKSB7XG4gICAgICAgIHBvcy56LS07XG4gICAgICAgIHBvcy54ID0gTWF0aC5mbG9vcihwb3MueCAvIDIpO1xuICAgICAgICBwb3MueSA9IE1hdGguZmxvb3IocG9zLnkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCwgcG9zLnkpO1xufTtcblxuLypcbiAqIEdpdmVuIGEgcGFja2VkIGludGVnZXIgaWQsIHJldHVybiBhbiBhcnJheSBvZiBpbnRlZ2VyIGlkcyByZXByZXNlbnRpbmdcbiAqIGl0cyBmb3VyIGNoaWxkcmVuLlxuICovXG5UaWxlQ29vcmQuY2hpbGRyZW4gPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcbiAgICBwb3MueiArPSAxO1xuICAgIHBvcy54ICo9IDI7XG4gICAgcG9zLnkgKj0gMjtcbiAgICByZXR1cm4gW1xuICAgICAgICBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLngsIHBvcy55LCBwb3MudyksXG4gICAgICAgIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCArIDEsIHBvcy55LCBwb3MudyksXG4gICAgICAgIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCwgcG9zLnkgKyAxLCBwb3MudyksXG4gICAgICAgIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCArIDEsIHBvcy55ICsgMSwgcG9zLncpXG4gICAgXTtcbn07XG5cblRpbGVDb29yZC56b29tVG8gPSBmdW5jdGlvbihjLCB6KSB7XG4gICAgYy5jb2x1bW4gPSBjLmNvbHVtbiAqIE1hdGgucG93KDIsIHogLSBjLnpvb20pO1xuICAgIGMucm93ID0gYy5yb3cgKiBNYXRoLnBvdygyLCB6IC0gYy56b29tKTtcbiAgICBjLnpvb20gPSB6O1xuICAgIHJldHVybiBjO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmV3aW5kID0gcmVxdWlyZSgnZ2VvanNvbi1yZXdpbmQnKTtcblxudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZWNvb3JkLmpzJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vZ2VvL3RyYW5zZm9ybS5qcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBMYXRMbmcgPSByZXF1aXJlKCcuLi9nZW8vbGF0bG5nLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGlsZUdlb0pTT047XG5cbmZ1bmN0aW9uIHRpbGVHZW9KU09OKGdlb2pzb24sIHpvb20pIHtcbiAgICB2YXIgdGlsZXMgPSB7fTtcbiAgICB2YXIgdGlsZUV4dGVudCA9IDQwOTY7XG4gICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICB0cmFuc2Zvcm0uem9vbSA9IHpvb207XG5cbiAgICBnZW9qc29uID0gcmV3aW5kKGdlb2pzb24pO1xuXG4gICAgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRpbGVGZWF0dXJlKGdlb2pzb24uZmVhdHVyZXNbaV0sIHRyYW5zZm9ybSwgdGlsZXMsIHRpbGVFeHRlbnQpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIHRpbGVGZWF0dXJlKGdlb2pzb24sIHRyYW5zZm9ybSwgdGlsZXMsIHRpbGVFeHRlbnQpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3coJ1VucmVjb2duaXplZCBnZW9qc29uIHR5cGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlsZXM7XG59XG5cbmZ1bmN0aW9uIHRpbGVGZWF0dXJlKGZlYXR1cmUsIHRyYW5zZm9ybSwgdGlsZXMsIHRpbGVFeHRlbnQpIHtcbiAgICB2YXIgY29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICB2YXIgdHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcblxuICAgIHZhciB0aWxlZDtcbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICB0aWxlZCA9IHRpbGVMaW5lU3RyaW5nKFtjb29yZHNdLCB0cmFuc2Zvcm0sIHRpbGVFeHRlbnQpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycgfHwgdHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgIHRpbGVkID0gdGlsZUxpbmVTdHJpbmcoY29vcmRzLCB0cmFuc2Zvcm0sIHRpbGVFeHRlbnQpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9seWdvbicgfHwgdHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgdGlsZWQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aWxlZF8gPSB0aWxlTGluZVN0cmluZyhjb29yZHNbaV0sIHRyYW5zZm9ybSwgdGlsZUV4dGVudCwgdHlwZSA9PT0gJ1BvbHlnb24nKTtcbiAgICAgICAgICAgIGZvciAodmFyIHRpbGVJRCBpbiB0aWxlZF8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGVkW3RpbGVJRF0pIHRpbGVkW3RpbGVJRF0gPSBbXTtcbiAgICAgICAgICAgICAgICB0aWxlZFt0aWxlSURdID0gKHRpbGVkW3RpbGVJRF0gfHwgW10pLmNvbmNhdCh0aWxlZF9bdGlsZUlEXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgdGhyb3coXCJ0b2RvXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93KFwidW5yZWNvZ25pemVkIGdlb21ldHJ5IHR5cGVcIik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaWQgaW4gdGlsZWQpIHtcbiAgICAgICAgdGlsZXNbaWRdID0gdGlsZXNbaWRdIHx8IFtdO1xuICAgICAgICB0aWxlc1tpZF0ucHVzaCh7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBjb29yZHM6IHRpbGVkW2lkXSxcbiAgICAgICAgICAgIHR5cGU6IGZlYXR1cmUuZ2VvbWV0cnkudHlwZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRpbGVMaW5lU3RyaW5nKGNvb3JkcywgdHJhbnNmb3JtLCB0aWxlRXh0ZW50LCByZWpvaW4pIHtcblxuICAgIHZhciBwYWRkaW5nID0gMC4wMTtcbiAgICB2YXIgcGFkZGVkRXh0ZW50ID0gdGlsZUV4dGVudCAqICgxICsgMiAqIHBhZGRpbmcpO1xuICAgIHZhciBjb29yZCA9IHRyYW5zZm9ybS5sb2NhdGlvbkNvb3JkaW5hdGUobmV3IExhdExuZyhjb29yZHNbMF1bMV0sIGNvb3Jkc1swXVswXSkpO1xuICAgIHZhciBwcmV2Q29vcmQ7XG5cbiAgICB2YXIgdGlsZXMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZXZDb29yZCA9IGNvb3JkO1xuICAgICAgICBjb29yZCA9IHRyYW5zZm9ybS5sb2NhdGlvbkNvb3JkaW5hdGUobmV3IExhdExuZyhjb29yZHNbaV1bMV0sIGNvb3Jkc1tpXVswXSkpO1xuXG4gICAgICAgIHZhciBkeCA9IGNvb3JkLmNvbHVtbiAtIHByZXZDb29yZC5jb2x1bW4gfHwgTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIGR5ID0gY29vcmQucm93IC0gcHJldkNvb3JkLnJvdyB8fCBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgZGlyWCA9IGR4IC8gTWF0aC5hYnMoZHgpLFxuICAgICAgICAgICAgZGlyWSA9IGR5IC8gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGJveCwgaW4gdGlsZXMsIG9mIHRoZSBwb2x5Z29uXG4gICAgICAgIHZhciBzdGFydFRpbGVYID0gTWF0aC5mbG9vcihwcmV2Q29vcmQuY29sdW1uIC0gZGlyWCAqIHBhZGRpbmcpO1xuICAgICAgICB2YXIgZW5kVGlsZVggPSBNYXRoLmZsb29yKGNvb3JkLmNvbHVtbiArIGRpclggKiBwYWRkaW5nKTtcbiAgICAgICAgdmFyIHN0YXJ0VGlsZVkgPSBNYXRoLmZsb29yKHByZXZDb29yZC5yb3cgLSBkaXJZICogcGFkZGluZyk7XG4gICAgICAgIHZhciBlbmRUaWxlWSA9IE1hdGguZmxvb3IoY29vcmQucm93ICsgZGlyWSAqIHBhZGRpbmcpO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgdGlsZXMgdGhlIHNlZ21lbnQgbWlnaHQgaW50ZXJzZWN0XG4gICAgICAgIC8vIGFuZCBzcGxpdCB0aGUgc2VnbWVudCBhY3Jvc3MgdGhvc2UgdGlsZXNcbiAgICAgICAgZm9yICh2YXIgeCA9IHN0YXJ0VGlsZVg7ICh4IC0gZW5kVGlsZVgpICogZGlyWCA8PSAwOyB4ICs9IGRpclgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0WCA9ICh4IC0gcGFkZGluZyAtIHByZXZDb29yZC5jb2x1bW4pIC8gZHg7XG4gICAgICAgICAgICB2YXIgcmlnaHRYID0gKHggKyAxICsgcGFkZGluZyAtIHByZXZDb29yZC5jb2x1bW4pIC8gZHg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHkgPSBzdGFydFRpbGVZOyAoeSAtIGVuZFRpbGVZKSAqIGRpclkgPD0gMDsgeSArPSBkaXJZKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvcFkgPSAoeSAtIHBhZGRpbmcgLSBwcmV2Q29vcmQucm93KSAvIGR5O1xuICAgICAgICAgICAgICAgIHZhciBib3R0b21ZID0gKHkgKyAxICsgcGFkZGluZyAtIHByZXZDb29yZC5yb3cpIC8gZHk7XG5cbiAgICAgICAgICAgICAgICAvLyBmcmFjdGlvbiBvZiB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIHNlZ21lbnQgYXQgd2hpY2ggdGhlIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAvLyBlbnRlcnMgb3IgZXhpdHMgdGhlIHRpbGVcbiAgICAgICAgICAgICAgICB2YXIgZW50ZXIgPSBNYXRoLm1heChNYXRoLm1pbihsZWZ0WCwgcmlnaHRYKSwgTWF0aC5taW4odG9wWSwgYm90dG9tWSkpO1xuICAgICAgICAgICAgICAgIHZhciBleGl0ID0gTWF0aC5taW4oTWF0aC5tYXgobGVmdFgsIHJpZ2h0WCksIE1hdGgubWF4KHRvcFksIGJvdHRvbVkpKTtcblxuICAgICAgICAgICAgICAgIHZhciB0aWxlSUQgPSBUaWxlQ29vcmQudG9JRCh0cmFuc2Zvcm0udGlsZVpvb20sIHgsIHkpLFxuICAgICAgICAgICAgICAgICAgICB0aWxlID0gdGlsZXNbdGlsZUlEXSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBzdGFydHMgb3V0c2lkZSB0aGUgdGlsZSwgYWRkIGVudHJ5IHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gZW50ZXIgJiYgZW50ZXIgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgKChwcmV2Q29vcmQuY29sdW1uICsgZW50ZXIgKiBkeCkgLSB4KSAqIHRpbGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHByZXZDb29yZC5yb3cgKyBlbnRlciAqIGR5KSAtIHkpICogdGlsZUV4dGVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuY29udGludWVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpbGUpIHRpbGVzW3RpbGVJRF0gPSB0aWxlID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRpbGUucHVzaChbcG9pbnRdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBlbmRzIG91dHNpZGUgdGhlIHRpbGUsIGFkZCBleGl0IHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gZXhpdCAmJiBleGl0IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICgocHJldkNvb3JkLmNvbHVtbiArIGV4aXQgKiBkeCkgLSB4KSAqIHRpbGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHByZXZDb29yZC5yb3cgKyBleGl0ICogZHkpIC0geSkgKiB0aWxlRXh0ZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBwb2ludC5jb250aW51ZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRpbGVbdGlsZS5sZW5ndGggLSAxXS5wdXNoKHBvaW50KTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgcG9pbnQgaXRzZWxmXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29vcmQuY29sdW1uIC0geCkgKiB0aWxlRXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvb3JkLnJvdyAtIHkpICogdGlsZUV4dGVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aWxlKSB0aWxlc1t0aWxlSURdID0gdGlsZSA9IFtbcG9pbnRdXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB0aWxlW3RpbGUubGVuZ3RoIC0gMV0ucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlam9pbikge1xuICAgICAgICAvLyByZWFzc2VtYmxlIHRoZSBkaXNjb25uZWN0ZWQgc2VnbWVudHMgaW50byBhIGxpbmVzdHJpbmdcbiAgICAgICAgLy8gc2VjdGlvbnMgb2YgdGhlIGxpbmVzdHJpbmcgb3V0c2lkZSB0aGUgdGlsZSBhcmUgcmVwbGFjZWQgd2l0aCBzZWdtZW50c1xuICAgICAgICAvLyB0aGF0IGZvbGxvdyB0aGUgdGlsZSdzIGVkZ2VcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGlsZXMpIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gdGlsZXNbaWRdO1xuXG4gICAgICAgICAgICBpZiAoIXNlZ21lbnRzWzBdWzBdLmNvbnRpbnVlcyAmJiBzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZpcnN0IHNlZ21lbnQgaXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZXN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gam9pbiBpdCB3aXRoIHRoZSBsYXN0IHNvIHRoYXQgYWxsIHNlZ21lbnRzIHN0YXJ0IGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZCBhdCB0aWxlIGJvdW5kYXJpZXNcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KHNlZ21lbnRzWzBdLCBsYXN0LnNsaWNlKDAsIGxhc3QubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBlZGdlRGlzdChzZWdtZW50c1swXVswXSwgdGlsZUV4dGVudCwgcGFkZGluZyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VnbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIHRpbGUgY29ybmVycyBhbG9uZyB0aGUgcGF0aCBiZXR3ZWVuIHRoZSBjdXJyZW50IHNlZ21lbnQncyBleGl0IHBvaW50XG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBuZXh0IHNlZ21lbnQncyBlbnRyeSBwb2ludFxuXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNFeGl0ID0gZWRnZURpc3Qoc2VnbWVudHNba11bc2VnbWVudHNba10ubGVuZ3RoIC0gMV0sIHBhZGRlZEV4dGVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRFbnRyeSA9IGVkZ2VEaXN0KHNlZ21lbnRzWyhrICsgMSkgJSBzZWdtZW50cy5sZW5ndGhdWzBdLCBwYWRkZWRFeHRlbnQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VG9FeGl0ID0gKHRoaXNFeGl0IC0gc3RhcnQgKyA0KSAlIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VG9OZXh0RW50cnkgPSAobmV4dEVudHJ5IC0gc3RhcnQgKyA0KSAlIDQ7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9ICh0aGlzRXhpdCA9PT0gbmV4dEVudHJ5IHx8IHN0YXJ0VG9FeGl0IDwgc3RhcnRUb05leHRFbnRyeSkgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgdmFyIHJvdW5kRm4gPSBkaXJlY3Rpb24gPiAwID8gTWF0aC5jZWlsIDogTWF0aC5mbG9vcjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSByb3VuZEZuKHRoaXNFeGl0KSAlIDQ7IGMgIT0gcm91bmRGbihuZXh0RW50cnkpICUgNDsgYyA9IChjICsgZGlyZWN0aW9uICsgNCkgJSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2NdO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1trXS5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb3JuZXIueCArIChjb3JuZXIueCAtIDAuNSA+IDAgPyAxIDogLTEpICogcGFkZGluZykgKiB0aWxlRXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvcm5lci55ICsgKGNvcm5lci55IC0gMC41ID4gMCA/IDEgOiAtMSkgKiBwYWRkaW5nKSAqIHRpbGVFeHRlbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEpvaW4gYWxsIHNlZ21lbnRzXG4gICAgICAgICAgICB0aWxlc1tpZF0gPSBbQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgc2VnbWVudHMpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aWxlcztcblxufVxuXG52YXIgY29ybmVycyA9IFtcbiAgICBuZXcgUG9pbnQoMCwgMCksXG4gICAgbmV3IFBvaW50KDEsIDApLFxuICAgIG5ldyBQb2ludCgxLCAxKSxcbiAgICBuZXcgUG9pbnQoMCwgMSldO1xuXG4vKlxuICogQ29udmVydHMgdG8gYSBwb2ludCB0byB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGVkZ2Ugb2YgdGhlIHRpbGUgKG91dCBvZiA0KS5cbiAqXG4gKiAgICAgICAgIDAuNVxuICogICAgIDAgX19fX19fXyAxXG4gKiAgICAgIHwgICAgICAgfFxuICogIDMuNSB8ICAgICAgIHwgMS41XG4gKiAgICAgIHwgICAgICAgfFxuICogICAgICB8X19fX19fX3xcbiAqICAgICAzICAgMi41ICAgMlxuICovXG5mdW5jdGlvbiBlZGdlRGlzdChwb2ludCwgZXh0ZW50KSB7XG4gICAgdmFyIHggPSBwb2ludC54IC8gZXh0ZW50O1xuICAgIHZhciB5ID0gcG9pbnQueSAvIGV4dGVudDtcbiAgICB2YXIgZDtcbiAgICBpZiAoTWF0aC5hYnMoeSAtIDAuNSkgPj0gTWF0aC5hYnMoeCAtIDAuNSkpIHtcbiAgICAgICAgZCA9IE1hdGgucm91bmQoeSkgKiAyICsgKHkgPCAwLjUgPyB4IDogMSAtIHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSBNYXRoLnJvdW5kKDEgLSB4KSAqIDIgKyAoeCA+IDAuNSA/IHkgOiAxIC0geSkgKyAxO1xuICAgIH1cblxuICAgIHJldHVybiBkICUgNDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRpbGUgPSByZXF1aXJlKCcuL3RpbGUuanMnKSxcbiAgICBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVjb29yZC5qcycpLFxuICAgIEJ1ZmZlclNldCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyL2J1ZmZlcnNldC5qcycpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcblxudmFyIGNyZWF0ZUJ1Y2tldCA9IHJlcXVpcmUoJy4uL2RhdGEvY3JlYXRlYnVja2V0LmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZShpZCwgc291cmNlLCB1cmwsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy56b29tID0gVGlsZUNvb3JkLmZyb21JRChpZCkuejtcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG4gICAgdGhpcy5pZCA9IHV0aWwudW5pcXVlSWQoKTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICBpZiAodGhpcy56b29tID49IHNvdXJjZS5tYXh6b29tKSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLm1hcC5vcHRpb25zLm1heFpvb20gLSB0aGlzLnpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDE7XG4gICAgfVxuICAgIHRoaXMudXNlcyA9IDE7XG4gICAgdGhpcy5fbG9hZCgpO1xufVxuXG5WZWN0b3JUaWxlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChUaWxlLCB7XG5cbiAgICBfbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcztcbiAgICAgICAgdGhpcy53b3JrZXJJRCA9IHRoaXMubWFwLmRpc3BhdGNoZXIuc2VuZCgnbG9hZCB0aWxlJywge1xuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgem9vbTogdGhpcy56b29tLFxuICAgICAgICAgICAgbWF4Wm9vbTogdGhpcy5zb3VyY2UubWF4em9vbSxcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnNvdXJjZS50aWxlU2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UuaWQsXG4gICAgICAgICAgICBkZXB0aDogdGhpcy5kZXB0aFxuICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZXJyICYmIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aWxlLm9uVGlsZUxvYWQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aWxlLmNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvblRpbGVMb2FkOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgLy8gVGlsZSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcFxuICAgICAgICBpZiAoIXRoaXMubWFwKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5idWZmZXJzID0gbmV3IEJ1ZmZlclNldChkYXRhLmJ1ZmZlcnMpO1xuXG4gICAgICAgIHRoaXMuYnVja2V0cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBiIGluIGRhdGEuZWxlbWVudEdyb3Vwcykge1xuICAgICAgICAgICAgdGhpcy5idWNrZXRzW2JdID0gY3JlYXRlQnVja2V0KHRoaXMubWFwLnN0eWxlLmJ1Y2tldHNbYl0sIHRoaXMuYnVmZmVycywgdW5kZWZpbmVkLCBkYXRhLmVsZW1lbnRHcm91cHNbYl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHJldXNlIHByZXJlbmRlcmVkIHRleHR1cmVzXG4gICAgICAgIGZvciAodmFyIGJ1Y2tldCBpbiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Y2tldHNbYnVja2V0XS5wcmVyZW5kZXJlZCkgdGhpcy5tYXAucGFpbnRlci5zYXZlVGV4dHVyZSh0aGlzLmJ1Y2tldHNbYnVja2V0XS5wcmVyZW5kZXJlZC50ZXh0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFwLmRpc3BhdGNoZXIuc2VuZCgncmVtb3ZlIHRpbGUnLCB7IGlkOiB0aGlzLmlkLCBzb3VyY2U6IHRoaXMuc291cmNlLmlkIH0sIG51bGwsIHRoaXMud29ya2VySUQpO1xuICAgICAgICB0aGlzLm1hcC5wYWludGVyLmdseXBoQXRsYXMucmVtb3ZlR2x5cGhzKHRoaXMuaWQpO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMubWFwLnBhaW50ZXIuZ2w7XG4gICAgICAgIHZhciBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuICAgICAgICBpZiAoYnVmZmVycykge1xuICAgICAgICAgICAgZm9yICh2YXIgYiBpbiBidWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyc1tiXS5kZXN0cm95KGdsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5tYXA7XG4gICAgfSxcblxuICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tYXAuZGlzcGF0Y2hlci5zZW5kKCdhYm9ydCB0aWxlJywgeyBpZDogdGhpcy5pZCwgc291cmNlOiB0aGlzLnNvdXJjZS5pZCB9LCBudWxsLCB0aGlzLndvcmtlcklEKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlLmpzJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlY29vcmQuanMnKTtcbnZhciBMYXRMbmcgPSByZXF1aXJlKCcuLi9nZW8vbGF0bG5nLmpzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlkZW9Tb3VyY2U7XG5cbmZ1bmN0aW9uIFZpZGVvU291cmNlKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB0aGlzLnZpZGVvLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgdGhpcy52aWRlby5sb29wID0gdHJ1ZTtcblxuICAgIHZhciB1cmxzID0gKHR5cGVvZiBvcHRpb25zLnVybCA9PT0gJ3N0cmluZycpID8gW29wdGlvbnMudXJsXSA6IG9wdGlvbnMudXJsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG4gICAgICAgIHMuc3JjID0gdXJsc1tpXTtcbiAgICAgICAgdGhpcy52aWRlby5hcHBlbmRDaGlsZChzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gb3B0aW9ucy5jb29yZGluYXRlcztcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgdmFyIGxvb3BJRDtcbiAgICB2YXIgc291cmNlID0gdGhpcztcblxuICAgIC8vIHN0YXJ0IHJlcGFpbnRpbmcgd2hlbiB2aWRlbyBzdGFydHMgcGxheWluZ1xuICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBsb29wSUQgPSBzb3VyY2UubWFwLnN0eWxlLmFuaW1hdGlvbkxvb3Auc2V0KEluZmluaXR5KTtcbiAgICAgICAgc291cmNlLm1hcC5fcmVyZW5kZXIoKTtcbiAgICB9KTtcblxuICAgIC8vIHN0b3AgcmVwYWludGluZyB3aGVuIHZpZGVvIHN0b3BzXG4gICAgdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzb3VyY2UubWFwLnN0eWxlLmFuaW1hdGlvbkxvb3AuY2FuY2VsKGxvb3BJRCk7XG4gICAgfSk7XG59XG5cblZpZGVvU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChTb3VyY2UsIHtcbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICB0aGlzLnZpZGVvLnBsYXkoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVUaWxlKCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBDYWxjdWxhdGUgd2hpY2ggbWVyY2F0b3IgdGlsZSBpcyBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHRoZSB2aWRlbyBpblxuICAgICAgICAgKiBhbmQgY3JlYXRlIGEgYnVmZmVyIHdpdGggdGhlIGNvcm5lciBjb29yZGluYXRlcy4gVGhlc2UgY29vcmRpbmF0ZXNcbiAgICAgICAgICogbWF5IGJlIG91dHNpZGUgdGhlIHRpbGUsIGJlY2F1c2UgcmFzdGVyIHRpbGVzIGFyZW4ndCBjbGlwcGVkIHdoZW4gcmVuZGVyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwO1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gTGF0TG5nLmNvbnZlcnQobGF0bG5nKTtcbiAgICAgICAgICAgIHJldHVybiBUaWxlQ29vcmQuem9vbVRvKG1hcC50cmFuc2Zvcm0ubG9jYXRpb25Db29yZGluYXRlKGxvYyksIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBjb29yZHNbaV0uY29sdW1uKTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBjb29yZHNbaV0ucm93KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBjb29yZHNbaV0uY29sdW1uKTtcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBjb29yZHNbaV0ucm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkeCA9IG1heFggLSBtaW5YO1xuICAgICAgICB2YXIgZHkgPSBtYXhZIC0gbWluWTtcbiAgICAgICAgdmFyIGRNYXggPSBNYXRoLm1heChkeCwgZHkpO1xuICAgICAgICB2YXIgY2VudGVyID0gVGlsZUNvb3JkLnpvb21Ubyh7XG4gICAgICAgICAgICBjb2x1bW46IChtaW5YICsgbWF4WCkgLyAyLFxuICAgICAgICAgICAgcm93OiAobWluWSArIG1heFkpIC8gMixcbiAgICAgICAgICAgIHpvb206IDBcbiAgICAgICAgfSwgTWF0aC5mbG9vcigtTWF0aC5sb2coZE1heCkgLyBNYXRoLkxOMikpO1xuXG4gICAgICAgIHZhciB0aWxlRXh0ZW50ID0gNDA5NjtcbiAgICAgICAgdmFyIHRpbGVDb29yZHMgPSBjb29yZHMubWFwKGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICB2YXIgem9vbWVkQ29vcmQgPSBUaWxlQ29vcmQuem9vbVRvKGNvb3JkLCBjZW50ZXIuem9vbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHpvb21lZENvb3JkLmNvbHVtbiAtIGNlbnRlci5jb2x1bW4pICogdGlsZUV4dGVudCksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoem9vbWVkQ29vcmQucm93IC0gY2VudGVyLnJvdykgKiB0aWxlRXh0ZW50KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBnbCA9IG1hcC5wYWludGVyLmdsO1xuICAgICAgICB2YXIgbWF4SW50MTYgPSAzMjc2NztcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IEludDE2QXJyYXkoW1xuICAgICAgICAgICAgdGlsZUNvb3Jkc1swXS54LCB0aWxlQ29vcmRzWzBdLnksIDAsIDAsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzFdLngsIHRpbGVDb29yZHNbMV0ueSwgbWF4SW50MTYsIDAsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzNdLngsIHRpbGVDb29yZHNbM10ueSwgMCwgbWF4SW50MTYsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzJdLngsIHRpbGVDb29yZHNbMl0ueSwgbWF4SW50MTYsIG1heEludDE2XG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmJvdW5kc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5ib3VuZHNCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICB0aGlzLnRpbGUgPSBuZXcgVGlsZSgpO1xuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGxheWVycykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy52aWRlby5yZWFkeVN0YXRlIDwgMikgcmV0dXJuOyAvLyBub3QgZW5vdWdoIGRhdGEgZm9yIGN1cnJlbnQgcG9zaXRpb25cblxuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbMF07XG5cbiAgICAgICAgdmFyIGJ1Y2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdyYXN0ZXInLFxuICAgICAgICAgICAgdGlsZTogdGhpcyxcbiAgICAgICAgICAgIGJvdW5kc0J1ZmZlcjogdGhpcy5ib3VuZHNCdWZmZXIsXG4gICAgICAgICAgICBiaW5kOiB0aGlzLmJpbmQuYmluZCh0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBidWNrZXRzID0ge307XG4gICAgICAgIGJ1Y2tldHNbbGF5ZXIuYnVja2V0XSA9IGJ1Y2tldDtcblxuICAgICAgICB2YXIgYyA9IHRoaXMuY2VudGVyO1xuICAgICAgICB0aGlzLnRpbGUuY2FsY3VsYXRlTWF0cmljZXMoYy56b29tLCBjLmNvbHVtbiwgYy5yb3csIHRoaXMubWFwLnRyYW5zZm9ybSwgdGhpcy5tYXAucGFpbnRlcik7XG4gICAgICAgIHRoaXMubWFwLnBhaW50ZXIudGlsZSA9IHRoaXMudGlsZTtcbiAgICAgICAgdGhpcy5tYXAucGFpbnRlci5hcHBseVN0eWxlKGxheWVyLCB0aGlzLm1hcC5zdHlsZSwgYnVja2V0cywge30pO1xuICAgIH0sXG5cbiAgICBiaW5kOiBmdW5jdGlvbihnbCkge1xuICAgICAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy52aWRlbyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9pbnQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gVE9ETyByZXR1cm4gcGl4ZWw/XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBY3RvciA9IHJlcXVpcmUoJy4uL3V0aWwvYWN0b3IuanMnKSxcbiAgICBidWNrZXRGaWx0ZXIgPSByZXF1aXJlKCcuLi9zdHlsZS9idWNrZXRmaWx0ZXIuanMnKSxcbiAgICBXb3JrZXJUaWxlID0gcmVxdWlyZSgnLi93b3JrZXJ0aWxlLmpzJyksXG4gICAgdGlsZUdlb0pTT04gPSByZXF1aXJlKCcuL3RpbGVnZW9qc29uLmpzJyksXG4gICAgV3JhcHBlciA9IHJlcXVpcmUoJy4vZ2VvanNvbndyYXBwZXIuanMnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyksXG4gICAgcXVldWUgPSByZXF1aXJlKCdxdWV1ZS1hc3luYycpLFxuICAgIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXguanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXI7XG5cbmZ1bmN0aW9uIFdvcmtlcihzZWxmKSB7XG4gICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICB0aGlzLmFjdG9yID0gbmV3IEFjdG9yKHNlbGYsIHRoaXMpO1xufVxuXG51dGlsLmV4dGVuZChXb3JrZXIucHJvdG90eXBlLCB7XG4gICAgYWxlcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2FsZXJ0IG1lc3NhZ2UnLFxuICAgICAgICAgICAgZGF0YTogW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGVzIHRoZSBzdHlsZSB0byB1c2UgZm9yIHRoaXMgbWFwLlxuICAgICdzZXQgYnVja2V0cyc6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGJ1Y2tldHMgPSBXb3JrZXJUaWxlLmJ1Y2tldHMgPSBkYXRhO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2ldO1xuICAgICAgICAgICAgYnVja2V0LmNvbXBhcmUgPSBidWNrZXRGaWx0ZXIoYnVja2V0LmZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3NldCBnbHlwaHMnOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIFdvcmtlclRpbGUucHJvdG90eXBlLmdseXBocyA9IGRhdGE7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogTG9hZCBhbmQgcGFyc2UgYSB0aWxlIGF0IGB1cmxgLCBhbmQgY2FsbCBgY2FsbGJhY2tgIHdpdGhcbiAgICAgKiAoZXJyLCByZXNwb25zZSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgICdsb2FkIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG5ldyBXb3JrZXJUaWxlKHBhcmFtcy51cmwsIHVuZGVmaW5lZCwgcGFyYW1zLmlkLCBwYXJhbXMuem9vbSwgcGFyYW1zLm1heFpvb20sIHBhcmFtcy50aWxlU2l6ZSwgcGFyYW1zLnNvdXJjZSwgcGFyYW1zLmRlcHRoLCB0aGlzLmFjdG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQWJvcnQgdGhlIHJlcXVlc3Qga2V5ZWQgdW5kZXIgYHVybGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKi9cbiAgICAnYWJvcnQgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBXb3JrZXJUaWxlLmNhbmNlbChwYXJhbXMuaWQsIHBhcmFtcy5zb3VyY2UpO1xuICAgIH0sXG5cbiAgICAncmVtb3ZlIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGlkID0gcGFyYW1zLmlkO1xuICAgICAgICB2YXIgc291cmNlID0gcGFyYW1zLnNvdXJjZTtcbiAgICAgICAgaWYgKFdvcmtlclRpbGUubG9hZGVkW3NvdXJjZV0gJiYgV29ya2VyVGlsZS5sb2FkZWRbc291cmNlXVtpZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBXb3JrZXJUaWxlLmxvYWRlZFtzb3VyY2VdW2lkXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncGFyc2UgZ2VvanNvbic6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSBwYXJhbXMuZGF0YSxcbiAgICAgICAgICAgIHpvb21zID0gcGFyYW1zLnpvb21zLFxuICAgICAgICAgICAgbGVuID0gem9vbXMubGVuZ3RoLFxuICAgICAgICAgICAgbWF4Wm9vbSA9IHpvb21zW2xlbiAtIDFdLFxuICAgICAgICAgICAgYWN0b3IgPSB0aGlzLmFjdG9yLFxuICAgICAgICAgICAgcSA9IHF1ZXVlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gd29ya2VyKGlkLCB0aWxlLCB6b29tLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgbmV3IFdvcmtlclRpbGUodW5kZWZpbmVkLCBuZXcgV3JhcHBlcih0aWxlKSwgaWQsIHpvb20sIG1heFpvb20sIHBhcmFtcy50aWxlU2l6ZSwgcGFyYW1zLnNvdXJjZSwgNCwgYWN0b3IsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIGRhdGEuaWQgPSBpZDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdGlsZURhdGEoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHpvb20gPSB6b29tc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdGlsZXMgPSB0aWxlR2VvSlNPTihkYXRhLCB6b29tKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aWxlcykge1xuICAgICAgICAgICAgICAgICAgICBxLmRlZmVyKHdvcmtlciwgaWQsIHRpbGVzW2lkXSwgem9vbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5hd2FpdEFsbChjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBhamF4LmdldEpTT04oZGF0YSwgdGlsZURhdGEpO1xuICAgICAgICBlbHNlIHRpbGVEYXRhKG51bGwsIGRhdGEpO1xuICAgIH0sXG5cbiAgICAncXVlcnkgZmVhdHVyZXMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aWxlID0gV29ya2VyVGlsZS5sb2FkZWRbcGFyYW1zLnNvdXJjZV0gJiYgV29ya2VyVGlsZS5sb2FkZWRbcGFyYW1zLnNvdXJjZV1bcGFyYW1zLmlkXTtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgIHRpbGUuZmVhdHVyZVRyZWUucXVlcnkocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmVUcmVlID0gcmVxdWlyZSgnLi4vZGF0YS9mZWF0dXJldHJlZS5qcycpO1xudmFyIFByb3RvYnVmID0gcmVxdWlyZSgncGJmJyk7XG52YXIgdnQgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpO1xudmFyIENvbGxpc2lvbiA9IHJlcXVpcmUoJy4uL3N5bWJvbC9jb2xsaXNpb24uanMnKTtcbnZhciBnZXRBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheC5qcycpLmdldEFycmF5QnVmZmVyO1xuXG52YXIgQnVmZmVyU2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWZmZXIvYnVmZmVyc2V0LmpzJyk7XG52YXIgY3JlYXRlQnVja2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9jcmVhdGVidWNrZXQuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXJUaWxlO1xuZnVuY3Rpb24gV29ya2VyVGlsZSh1cmwsIGRhdGEsIGlkLCB6b29tLCBtYXhab29tLCB0aWxlU2l6ZSwgc291cmNlLCBkZXB0aCwgYWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRpbGUgPSB0aGlzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIHRoaXMubWF4Wm9vbSA9IG1heFpvb207XG4gICAgdGhpcy50aWxlU2l6ZSA9IHRpbGVTaXplO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgQnVmZmVyU2V0KCk7XG5cbiAgICBmdW5jdGlvbiBsb2FkZWQoZGF0YSkge1xuICAgICAgICBXb3JrZXJUaWxlLmxvYWRlZFtzb3VyY2VdID0gV29ya2VyVGlsZS5sb2FkZWRbc291cmNlXSB8fCB7fTtcbiAgICAgICAgV29ya2VyVGlsZS5sb2FkZWRbc291cmNlXVtpZF0gPSB0aWxlO1xuICAgICAgICB0aWxlLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aWxlLnBhcnNlKGRhdGEsIGFjdG9yLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgaWYgKHVybCkge1xuICAgICAgICBpZiAoV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZV0gPT09IHVuZGVmaW5lZCkgV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZV0gPSB7fTtcbiAgICAgICAgV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZV1baWRdID0gZ2V0QXJyYXlCdWZmZXIodXJsLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBXb3JrZXJUaWxlLmxvYWRpbmdbc291cmNlXVtpZF07XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9hZGVkKG5ldyB2dC5WZWN0b3JUaWxlKG5ldyBQcm90b2J1ZihuZXcgVWludDhBcnJheShkYXRhKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGVkKGRhdGEpO1xuICAgIH1cbn1cblxuV29ya2VyVGlsZS5jYW5jZWwgPSBmdW5jdGlvbihpZCwgc291cmNlSUQpIHtcbiAgICB2YXIgc291cmNlID0gV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZUlEXTtcbiAgICBpZiAoc291cmNlICYmIHNvdXJjZVtpZF0pIHtcbiAgICAgICAgc291cmNlW2lkXS5hYm9ydCgpO1xuICAgICAgICBkZWxldGUgc291cmNlW2lkXTtcbiAgICB9XG59O1xuXG4vLyBTdG9yZXMgdGlsZXMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRpbmcuXG5Xb3JrZXJUaWxlLmxvYWRpbmcgPSB7fTtcblxuLy8gU3RvcmVzIHRpbGVzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQuXG5Xb3JrZXJUaWxlLmxvYWRlZCA9IHt9O1xuXG4vLyBTdG9yZXMgdGhlIHN0eWxlIGluZm9ybWF0aW9uLlxuV29ya2VyVGlsZS5idWNrZXRzID0gW107XG5cbi8qXG4gKiBHaXZlbiB0aWxlIGRhdGEsIHBhcnNlIHJhdyB2ZXJ0aWNlcyBhbmQgZGF0YSwgY3JlYXRlIGEgdmVjdG9yXG4gKiB0aWxlIGFuZCBwYXJzZSBpdCBpbnRvIHJlYWR5LXRvLXJlbmRlciB2ZXJ0aWNlcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVzcG9uZFxuICovXG5Xb3JrZXJUaWxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIGFjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciB0aWxlID0gdGhpcztcbiAgICB2YXIgYnVja2V0SW5mbyA9IFdvcmtlclRpbGUuYnVja2V0cztcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICB2YXIgdGlsZUV4dGVudCA9IDQwOTY7XG4gICAgdGhpcy5jb2xsaXNpb24gPSBuZXcgQ29sbGlzaW9uKHRoaXMuem9vbSwgdGlsZUV4dGVudCwgdGhpcy50aWxlU2l6ZSwgdGhpcy5kZXB0aCk7XG4gICAgdGhpcy5mZWF0dXJlVHJlZSA9IG5ldyBGZWF0dXJlVHJlZShnZXRHZW9tZXRyeSwgZ2V0VHlwZSk7XG5cbiAgICB2YXIgYnVja2V0cyA9IHRoaXMuYnVja2V0cyA9IHNvcnRUaWxlSW50b0J1Y2tldHModGhpcywgZGF0YSwgYnVja2V0SW5mbyk7XG5cbiAgICB2YXIga2V5LCBidWNrZXQ7XG4gICAgdmFyIHByZXZQbGFjZW1lbnRCdWNrZXQ7XG5cbiAgICB2YXIgcmVtYWluaW5nID0gV29ya2VyVGlsZS5idWNrZXRzLmxlbmd0aDtcblxuICAgIC8qXG4gICAgICogIFRoZSBhc3luYyBwYXJzaW5nIGhlcmUgaXMgYSBiaXQgdHJpY2t5LlxuICAgICAqICBTb21lIGJ1Y2tldHMgZGVwZW5kIG9uIHJlc291cmNlcyB0aGF0IG1heSBuZWVkIHRvIGJlIGxvYWRlZCBhc3luYyAoZ2x5cGhzKS5cbiAgICAgKiAgU29tZSBidWNrZXRzIG5lZWQgdG8gYmUgcGFyc2VkIGluIG9yZGVyICh0byBnZXQgcGxhY2VtZW50IHByaW9yaXRpZXMgcmlnaHQpLlxuICAgICAqXG4gICAgICogIERlcGVuZGVuY2llcyBjYWxscyBhcmUgaW5pdGlhdGVkIGZpcnN0IHRvIGdldCB0aG9zZSByb2xsaW5nLlxuICAgICAqICBCdWNrZXRzIHRoYXQgZG9uJ3QgbmVlZCB0byBiZSBwYXJzZWQgaW4gb3JkZXIsIGFyZW4ndCB0byBzYXZlIHRpbWUuXG4gICAgICovXG5cbiAgICB2YXIgb3JkZXJlZEJ1Y2tldHMgPSBXb3JrZXJUaWxlLmJ1Y2tldHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmVkQnVja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWNrZXQgPSBidWNrZXRzW29yZGVyZWRCdWNrZXRzW2ldLmlkXTtcbiAgICAgICAgaWYgKCFidWNrZXQpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICAgICAgY29udGludWU7IC8vIHJhc3RlciBidWNrZXQsIGV0Y1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbHRlciA9IGJ1Y2tldC5pbmZvLmZpbHRlcjtcbiAgICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuc291cmNlICE9PSB0aGlzLnNvdXJjZSkgY29udGludWU7XG5cbiAgICAgICAgLy8gTGluayBidWNrZXRzIHRoYXQgbmVlZCB0byBiZSBwYXJzZWQgaW4gb3JkZXJcbiAgICAgICAgaWYgKGJ1Y2tldC5jb2xsaXNpb24pIHtcbiAgICAgICAgICAgIGlmIChwcmV2UGxhY2VtZW50QnVja2V0KSB7XG4gICAgICAgICAgICAgICAgcHJldlBsYWNlbWVudEJ1Y2tldC5uZXh0ID0gYnVja2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWNrZXQucHJldmlvdXNQbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlBsYWNlbWVudEJ1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWNrZXQuZ2V0RGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBidWNrZXQuZ2V0RGVwZW5kZW5jaWVzKHRoaXMsIGFjdG9yLCBkZXBlbmRlbmNpZXNEb25lKGJ1Y2tldCkpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBwYXJzZSBidWNrZXRzIHdoZXJlIG9yZGVyIGRvZXNuJ3QgbWF0dGVyIGFuZCBubyBkZXBlbmRlbmNpZXNcbiAgICBmb3IgKGtleSBpbiBidWNrZXRzKSB7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldHNba2V5XTtcbiAgICAgICAgaWYgKCFidWNrZXQuZ2V0RGVwZW5kZW5jaWVzICYmICFidWNrZXQuY29sbGlzaW9uKSB7XG4gICAgICAgICAgICBwYXJzZUJ1Y2tldCh0aWxlLCBidWNrZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwZW5kZW5jaWVzRG9uZShidWNrZXQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYnVja2V0LmRlcGVuZGVuY2llc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBwYXJzZUJ1Y2tldCh0aWxlLCBidWNrZXQsIGVycik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0LCBza2lwKSB7XG4gICAgICAgIGlmIChidWNrZXQuZ2V0RGVwZW5kZW5jaWVzICYmICFidWNrZXQuZGVwZW5kZW5jaWVzTG9hZGVkKSByZXR1cm47XG4gICAgICAgIGlmIChidWNrZXQuY29sbGlzaW9uICYmICFidWNrZXQucHJldmlvdXNQbGFjZWQpIHJldHVybjtcblxuICAgICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC50eXBlICE9PSAncmFzdGVyJykgYnVja2V0LmFkZEZlYXR1cmVzKCk7XG4gICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCkgLSBub3c7XG4gICAgICAgICAgICBpZiAoYnVja2V0LmludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBidWNrZXQuZmVhdHVyZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRpbGUuZmVhdHVyZVRyZWUuaW5zZXJ0KGZlYXR1cmUuYmJveCgpLCBidWNrZXQubmFtZSwgZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNlbGYuYnVja2V0U3RhdHMgPSBzZWxmLmJ1Y2tldFN0YXRzIHx8IHtfdG90YWw6IDB9O1xuICAgICAgICAgICAgICAgIHNlbGYuYnVja2V0U3RhdHMuX3RvdGFsICs9IHRpbWU7XG4gICAgICAgICAgICAgICAgc2VsZi5idWNrZXRTdGF0c1tidWNrZXQubmFtZV0gPSAoc2VsZi5idWNrZXRTdGF0c1tidWNrZXQubmFtZV0gfHwgMCkgKyB0aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVtYWluaW5nLS07XG4gICAgICAgIGlmICghcmVtYWluaW5nKSByZXR1cm4gdGlsZS5kb25lKCk7XG5cbiAgICAgICAgLy8gdHJ5IHBhcnNpbmcgdGhlIG5leHQgYnVja2V0LCBpZiBpdCBpcyByZWFkeVxuICAgICAgICBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5uZXh0LnByZXZpb3VzUGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcnNlQnVja2V0KHRpbGUsIGJ1Y2tldC5uZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbldvcmtlclRpbGUucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBDb2xsZWN0IGFsbCBidWZmZXJzIHRvIG1hcmsgdGhlbSBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0LlxuICAgIHZhciBidWZmZXJzID0gW107XG5cbiAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuYnVmZmVycykge1xuICAgICAgICBidWZmZXJzLnB1c2godGhpcy5idWZmZXJzW3R5cGVdLmFycmF5KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGJ1Y2tldHMgdG8gYSB0cmFuc2ZlcmFibGUgZm9ybWF0XG4gICAgdmFyIGJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHM7XG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB7fTtcbiAgICBmb3IgKHZhciBiIGluIGJ1Y2tldHMpIGVsZW1lbnRHcm91cHNbYl0gPSBidWNrZXRzW2JdLmVsZW1lbnRHcm91cHM7XG5cbiAgICB0aGlzLmNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgZWxlbWVudEdyb3VwczogZWxlbWVudEdyb3VwcyxcbiAgICAgICAgYnVmZmVyczogdGhpcy5idWZmZXJzXG4gICAgfSwgYnVmZmVycyk7XG5cbiAgICAvLyB3ZSBkb24ndCBuZWVkIGFueXRoaW5nIGV4Y2VwdCBmZWF0dXJlVHJlZSBhdCB0aGlzIHBvaW50LCBzbyB3ZSBtYXJrIGl0IGZvciBHQ1xuICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5jb2xsaXNpb24gPSBudWxsO1xuICAgIHRoaXMuYnVja2V0cyA9IG51bGw7XG59O1xuXG5mdW5jdGlvbiBzb3J0VGlsZUludG9CdWNrZXRzKHRpbGUsIGRhdGEsIGJ1Y2tldEluZm8pIHtcblxuICAgIHZhciBzb3VyY2VMYXllcnMgPSB7fSxcbiAgICAgICAgYnVja2V0cyA9IHt9LFxuICAgICAgICBsYXllck5hbWU7XG5cbiAgICAvLyBGb3IgZWFjaCBzb3VyY2UgbGF5ZXIsIGZpbmQgYSBsaXN0IG9mIGJ1Y2tldHMgdGhhdCB1c2UgZGF0YSBmcm9tIGl0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXRJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmZvID0gYnVja2V0SW5mb1tpXTtcbiAgICAgICAgdmFyIGJ1Y2tldE5hbWUgPSBpbmZvLmlkO1xuXG4gICAgICAgIHZhciBtaW5ab29tID0gaW5mb1snbWluLXpvb20nXTtcbiAgICAgICAgdmFyIG1heFpvb20gPSBpbmZvWydtYXgtem9vbSddO1xuXG4gICAgICAgIGlmIChpbmZvLnNvdXJjZSAhPT0gdGlsZS5zb3VyY2UpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobWluWm9vbSAmJiB0aWxlLnpvb20gPCBtaW5ab29tICYmIG1pblpvb20gPCB0aWxlLm1heFpvb20pIGNvbnRpbnVlO1xuICAgICAgICBpZiAobWF4Wm9vbSAmJiB0aWxlLnpvb20gPj0gbWF4Wm9vbSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGJ1Y2tldCA9IGNyZWF0ZUJ1Y2tldChpbmZvLCB0aWxlLmJ1ZmZlcnMsIHRpbGUuY29sbGlzaW9uKTtcbiAgICAgICAgaWYgKCFidWNrZXQpIGNvbnRpbnVlO1xuICAgICAgICBidWNrZXQuZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgYnVja2V0Lm5hbWUgPSBidWNrZXROYW1lO1xuICAgICAgICBidWNrZXRzW2J1Y2tldE5hbWVdID0gYnVja2V0O1xuXG4gICAgICAgIGlmIChkYXRhLmxheWVycykge1xuICAgICAgICAgICAgLy8gdmVjdG9ydGlsZVxuICAgICAgICAgICAgbGF5ZXJOYW1lID0gaW5mb1snc291cmNlLWxheWVyJ107XG4gICAgICAgICAgICBpZiAoIXNvdXJjZUxheWVyc1tsYXllck5hbWVdKSBzb3VyY2VMYXllcnNbbGF5ZXJOYW1lXSA9IHt9O1xuICAgICAgICAgICAgc291cmNlTGF5ZXJzW2xheWVyTmFtZV1bYnVja2V0TmFtZV0gPSBpbmZvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2VvanNvbiB0aWxlXG4gICAgICAgICAgICBzb3VyY2VMYXllcnNbYnVja2V0TmFtZV0gPSBpbmZvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVhZCBlYWNoIGxheWVyLCBhbmQgc29ydCBpdHMgZmVhdHVyZSdzIGludG8gYnVja2V0c1xuICAgIGlmIChkYXRhLmxheWVycykge1xuICAgICAgICAvLyB2ZWN0b3J0aWxlXG4gICAgICAgIGZvciAobGF5ZXJOYW1lIGluIHNvdXJjZUxheWVycykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gZGF0YS5sYXllcnNbbGF5ZXJOYW1lXTtcbiAgICAgICAgICAgIGlmICghbGF5ZXIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgc29ydExheWVySW50b0J1Y2tldHMobGF5ZXIsIHNvdXJjZUxheWVyc1tsYXllck5hbWVdLCBidWNrZXRzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdlb2pzb25cbiAgICAgICAgc29ydExheWVySW50b0J1Y2tldHMoZGF0YSwgc291cmNlTGF5ZXJzLCBidWNrZXRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVja2V0cztcbn1cblxuLypcbiAqIFNvcnRzIGZlYXR1cmVzIGluIGEgbGF5ZXIgaW50byBkaWZmZXJlbnQgYnVja2V0cywgYWNjb3JkaW5nIHRvIHRoZSBtYXBpbmdcbiAqXG4gKiBMYXllcnMgaW4gdmVjdG9yIHRpbGVzIGNvbnRhaW4gbWFueSBkaWZmZXJlbnQgZmVhdHVyZXMsIGFuZCBmZWF0dXJlIHR5cGVzLFxuICogZS5nLiB0aGUgbGFuZHVzZSBsYXllciBoYXMgcGFya3MsIGluZHVzdHJpYWwgYnVpbGRpbmdzLCBmb3Jlc3RzLCBwbGF5Z3JvdW5kc1xuICogZXRjLiBIb3dldmVyLCB3aGVuIHN0eWxpbmcsIHdlIG5lZWQgdG8gc2VwYXJhdGUgdGhlc2UgZmVhdHVyZXMgc28gdGhhdCB3ZSBjYW5cbiAqIHJlbmRlciB0aGVtIHNlcGFyYXRlbHkgd2l0aCBkaWZmZXJlbnQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7VmVjdG9yVGlsZUxheWVyfSBsYXllclxuICogQHBhcmFtIHtNYXBwaW5nfSBtYXBwaW5nXG4gKi9cbmZ1bmN0aW9uIHNvcnRMYXllckludG9CdWNrZXRzKGxheWVyLCBtYXBwaW5nLCBidWNrZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGxheWVyLmZlYXR1cmUoaSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgICBpZiAobWFwcGluZ1trZXldLmNvbXBhcmUoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgICAgICBidWNrZXRzW2tleV0uZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0R2VvbWV0cnkoZmVhdHVyZSkge1xuICAgIHJldHVybiBmZWF0dXJlLmxvYWRHZW9tZXRyeSgpO1xufVxuXG5mdW5jdGlvbiBnZXRUeXBlKGZlYXR1cmUpIHtcbiAgICByZXR1cm4gdnQuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbZmVhdHVyZS50eXBlXTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25Mb29wO1xuXG5mdW5jdGlvbiBBbmltYXRpb25Mb29wKCkge1xuICAgIHRoaXMubiA9IDA7XG4gICAgdGhpcy50aW1lcyA9IFtdO1xufVxuXG4vLyBBcmUgYWxsIGFuaW1hdGlvbnMgZG9uZT9cbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLnN0b3BwZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC50aW1lID49IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICF0aGlzLnRpbWVzLmxlbmd0aDtcbn07XG5cbi8vIEFkZCBhIG5ldyBhbmltYXRpb24gdGhhdCB3aWxsIHJ1biB0IG1pbGxpc2Vjb25kc1xuLy8gUmV0dXJucyBhbiBpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCBpdCBsYXllclxuQW5pbWF0aW9uTG9vcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGltZXMucHVzaCh7IGlkOiB0aGlzLm4sIHRpbWU6IHQgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH0pO1xuICAgIHJldHVybiB0aGlzLm4rKztcbn07XG5cbi8vIENhbmNlbCBhbiBhbmltYXRpb25cbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC5pZCAhPSBuO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKS5WZWN0b3JUaWxlRmVhdHVyZTtcblxuZnVuY3Rpb24gaW5maXgob3BlcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgKyAnICcgKyBvcGVyYXRvciArICcgJyArIHJpZ2h0OyB9O1xufVxuXG52YXIgaW5maXhPcGVyYXRvcnMgPSB7XG4gICAgJz09JzogaW5maXgoJz09PScpLFxuICAgICc+JzogaW5maXgoJz4nKSwgJyRndCc6IGluZml4KCc+JyksXG4gICAgJzwnOiBpbmZpeCgnPCcpLCAnJGx0JzogaW5maXgoJzwnKSxcbiAgICAnPD0nOiBpbmZpeCgnPD0nKSwgJyRsdGUnOiBpbmZpeCgnPD0nKSxcbiAgICAnPj0nOiBpbmZpeCgnPj0nKSwgJyRndGUnOiBpbmZpeCgnPj0nKSxcbiAgICAnIT0nOiBpbmZpeCgnIT09JyksICckbmUnOiBpbmZpeCgnIT09JyksXG4gICAgJyRleGlzdHMnOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICsgJyAhPT0gdW5kZWZpbmVkJzsgfVxufTtcblxuZnVuY3Rpb24gb3IoaXRlbXMpICB7IHJldHVybiAnKCcgKyBpdGVtcy5qb2luKCcgfHwgJykgKyAnKSc7IH1cbmZ1bmN0aW9uIGFuZChpdGVtcykgeyByZXR1cm4gJygnICsgaXRlbXMuam9pbignICYmICcpICsgJyknOyB9XG5mdW5jdGlvbiBub3QoaXRlbSkgIHsgcmV0dXJuICchJyArIGl0ZW07IH1cbmZ1bmN0aW9uIG5vcihpdGVtcykgeyByZXR1cm4gbm90KG9yKGl0ZW1zKSk7IH1cblxudmFyIGFycmF5T3BlcmF0b3JzID0ge1xuICAgICd8fCc6IG9yLCAnJG9yJzogb3IsXG4gICAgJyYmJzogYW5kLCAnJGFuZCc6IGFuZCxcbiAgICAnISc6IG5vciwgJyRub3InOiBub3Jcbn07XG5cbnZhciBvYmpPcGVyYXRvcnMgPSB7XG4gICAgJyEnOiBub3QsICckbm90Jzogbm90XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAvLyBzaW1wbGUga2V5ICYgdmFsdWUgY29tcGFyaXNvblxuICAgIGZ1bmN0aW9uIHZhbHVlRmlsdGVyKGtleSwgdmFsdWUsIG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRvcigncFsnICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddJywgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlcyBrZXkgJiB2YWx1ZSBvciBrZXkgJiBvcih2YWx1ZXMpXG4gICAgZnVuY3Rpb24gc2ltcGxlRmllbGRGaWx0ZXIoa2V5LCB2YWx1ZSwgb3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yRm4gPSBpbmZpeE9wZXJhdG9yc1tvcGVyYXRvciB8fCAnPT0nXTtcbiAgICAgICAgaWYgKCFvcGVyYXRvckZuKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gb3BlcmF0b3I6ICcgKyBvcGVyYXRvcik7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3IodmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlRmlsdGVyKGtleSwgdiwgb3BlcmF0b3JGbik7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgfSBlbHNlIHJldHVybiB2YWx1ZUZpbHRlcihrZXksIHZhbHVlLCBvcGVyYXRvckZuKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGVzIGFueSBmaWx0ZXIga2V5L3ZhbHVlIHBhaXJcbiAgICBmdW5jdGlvbiBmaWVsZEZpbHRlcihrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGFycmF5T3BlcmF0b3JzKSB7IC8vIGhhbmRsZSBhbmQvb3Igb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5T3BlcmF0b3JzW2tleV0odmFsdWUubWFwKGZpZWxkc0ZpbHRlcikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbm90IG9wZXJhdG9yXG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iak9wZXJhdG9ycykgcmV0dXJuIG9iak9wZXJhdG9yc1trZXldKGZpZWxkc0ZpbHRlcih2YWx1ZSkpO1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUge2tleToge29wZXJhdG9yOiB2YWx1ZX19IG5vdGF0aW9uXG4gICAgICAgICAgICB2YXIgZmlsdGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goc2ltcGxlRmllbGRGaWx0ZXIoa2V5LCB2YWx1ZVtvcF0sIG9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5kKGZpbHRlcnMpO1xuXG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIHNpbXBsZSBrZXkvdmFsdWUgb3Iga2V5L3ZhbHVlcyBjb21wYXJpc29uXG4gICAgICAgIHJldHVybiBzaW1wbGVGaWVsZEZpbHRlcihrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0eXBlRmlsdGVyKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICdmLnR5cGUgPT09ICcgKyBWZWN0b3JUaWxlRmVhdHVyZS50eXBlcy5pbmRleE9mKHR5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpZWxkc0ZpbHRlcihvYmopIHtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJHR5cGUnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHR5cGVGaWx0ZXIob2JqW2tleV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKGZpZWxkRmlsdGVyKGtleSwgb2JqW2tleV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXJzLmxlbmd0aCA/IGFuZChmaWx0ZXJzKSA6ICd0cnVlJztcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyU3RyID0gJ3ZhciBwID0gZi5wcm9wZXJ0aWVzIHx8IHt9OyByZXR1cm4gJyArIGZpZWxkc0ZpbHRlcihmaWx0ZXIgfHwge30pICsgJzsnO1xuXG4gICAgLy8ganNoaW50IGV2aWw6IHRydWVcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdmJywgZmlsdGVyU3RyKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3JlZmVyZW5jZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5yZWZlcmVuY2VbJ2NsYXNzJ10uZm9yRWFjaChmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICB2YXIgQ2FsY3VsYXRlZCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHN0eWxlID0gcmVmZXJlbmNlW2NsYXNzTmFtZV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICBpZiAoc3R5bGVbcHJvcF1bJ2RlZmF1bHQnXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgQ2FsY3VsYXRlZC5wcm90b3R5cGVbcHJvcF0gPSBzdHlsZVtwcm9wXVsnZGVmYXVsdCddO1xuICAgIH1cbiAgICBDYWxjdWxhdGVkLnByb3RvdHlwZS5oaWRkZW4gPSBmYWxzZTtcbiAgICBtb2R1bGUuZXhwb3J0c1tjbGFzc05hbWUucmVwbGFjZSgnY2xhc3NfJywnJyldID0gQ2FsY3VsYXRlZDtcbn0pO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkLmpzJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheC5qcycpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVNwcml0ZTtcblxuZnVuY3Rpb24gSW1hZ2VTcHJpdGUoYmFzZSkge1xuXG4gICAgdmFyIHNwcml0ZSA9IHRoaXM7XG4gICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICB0aGlzLnJldGluYSA9IGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG5cbiAgICBiYXNlID0gc3ByaXRlLmJhc2UgKyAoc3ByaXRlLnJldGluYSA/ICdAMngnIDogJycpO1xuXG4gICAgYWpheC5nZXRKU09OKGJhc2UgKyAnLmpzb24nLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgLy8gQFRPRE8gaGFuZGxlIGVycm9ycyB2aWEgc3ByaXRlIGV2ZW50LlxuICAgICAgICBpZiAoZXJyKSByZXR1cm47XG4gICAgICAgIHNwcml0ZS5kYXRhID0gZGF0YTtcbiAgICAgICAgaWYgKHNwcml0ZS5pbWcpIHNwcml0ZS5maXJlKCdsb2FkZWQnKTtcbiAgICB9KTtcblxuICAgIGFqYXguZ2V0SW1hZ2UoYmFzZSArICcucG5nJywgZnVuY3Rpb24oZXJyLCBpbWcpIHtcbiAgICAgICAgLy8gQFRPRE8gaGFuZGxlIGVycm9ycyB2aWEgc3ByaXRlIGV2ZW50LlxuICAgICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgICAgLy8gcHJlbXVsdGlwbHkgdGhlIHNwcml0ZVxuICAgICAgICB2YXIgZGF0YSA9IGltZy5nZXREYXRhKCk7XG4gICAgICAgIHZhciBuZXdkYXRhID0gaW1nLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrPTQpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGRhdGFbaSArIDNdIC8gMjU1O1xuICAgICAgICAgICAgbmV3ZGF0YVtpICsgMF0gPSBkYXRhW2kgKyAwXSAqIGFscGhhO1xuICAgICAgICAgICAgbmV3ZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSAqIGFscGhhO1xuICAgICAgICAgICAgbmV3ZGF0YVtpICsgMl0gPSBkYXRhW2kgKyAyXSAqIGFscGhhO1xuICAgICAgICAgICAgbmV3ZGF0YVtpICsgM10gPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwcml0ZS5pbWcgPSBpbWc7XG4gICAgICAgIGlmIChzcHJpdGUuZGF0YSkgc3ByaXRlLmZpcmUoJ2xvYWRlZCcpO1xuICAgIH0pO1xufVxuXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50ZWQpO1xuXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZTtcbn07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYmIHRoaXMuaW1nKTtcbn07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbihnbCkge1xuICAgIHZhciBzcHJpdGUgPSB0aGlzO1xuICAgIGlmIChicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxICE9PSBzcHJpdGUucmV0aW5hKSB7XG5cbiAgICAgICAgdmFyIG5ld1Nwcml0ZSA9IG5ldyBJbWFnZVNwcml0ZShzcHJpdGUuYmFzZSk7XG4gICAgICAgIG5ld1Nwcml0ZS5vbignbG9hZGVkJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHNwcml0ZS5pbWcgPSBuZXdTcHJpdGUuaW1nO1xuICAgICAgICAgICAgc3ByaXRlLmRhdGEgPSBuZXdTcHJpdGUuZGF0YTtcbiAgICAgICAgICAgIHNwcml0ZS5yZXRpbmEgPSBuZXdTcHJpdGUucmV0aW5hO1xuXG4gICAgICAgICAgICBpZiAoc3ByaXRlLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHNwcml0ZS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3ByaXRlLnRleHR1cmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCwgbGluZWFyKSB7XG4gICAgdmFyIHNwcml0ZSA9IHRoaXM7XG5cbiAgICBpZiAoIXNwcml0ZS5sb2FkZWQoKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKCFzcHJpdGUudGV4dHVyZSkge1xuICAgICAgICBzcHJpdGUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc3ByaXRlLnRleHR1cmUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIHZhciBpbWcgPSBzcHJpdGUuaW1nO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGltZy53aWR0aCwgaW1nLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nLmRhdGEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc3ByaXRlLnRleHR1cmUpO1xuICAgIH1cblxuICAgIHZhciBmaWx0ZXIgPSBsaW5lYXIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUO1xuICAgIGlmIChmaWx0ZXIgIT09IHNwcml0ZS5maWx0ZXIpIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlcik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXIpO1xuICAgIH1cbn07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHJlcGVhdGluZykge1xuXG4gICAgLy8gYHJlcGVhdGluZ2AgaW5kaWNhdGVzIHRoYXQgdGhlIGltYWdlIHdpbGwgYmUgdXNlZCBpbiBhIHJlcGVhdGluZyBwYXR0ZXJuXG4gICAgLy8gcmVwZWF0aW5nIHBhdHRlcm4gaW1hZ2VzIGFyZSBhc3N1bWVkIHRvIGhhdmUgYSAxcHggcGFkZGluZyB0aGF0IG1pcnJvcnMgdGhlIG9wcG9zaXRlIGVkZ2VcbiAgICAvLyBwb3NpdGlvbnMgZm9yIHJlcGVhdGluZyBpbWFnZXMgYXJlIGFkanVzdGVkIHRvIGV4Y2x1ZGUgdGhlIGVkZ2VcbiAgICByZXBlYXRpbmcgPSByZXBlYXRpbmcgPT09IHRydWUgPyAxIDogMDtcblxuICAgIHZhciBwb3MgPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW25hbWVdO1xuICAgIGlmIChwb3MgJiYgdGhpcy5pbWcpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5pbWcud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmltZy5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaXplOiBbcG9zLndpZHRoIC8gcG9zLnBpeGVsUmF0aW8sIHBvcy5oZWlnaHQgLyBwb3MucGl4ZWxSYXRpb10sXG4gICAgICAgICAgICB0bDogWyhwb3MueCArIHJlcGVhdGluZykvIHdpZHRoLCAocG9zLnkgKyByZXBlYXRpbmcpIC8gaGVpZ2h0XSxcbiAgICAgICAgICAgIGJyOiBbKHBvcy54ICsgcG9zLndpZHRoIC0gMiAqIHJlcGVhdGluZykgLyB3aWR0aCwgKHBvcy55ICsgcG9zLmhlaWdodCAtIDIgKiByZXBlYXRpbmcpIC8gaGVpZ2h0XVxuICAgICAgICB9O1xuICAgIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS92NScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVmZXJlbmNlID0gcmVxdWlyZSgnLi9yZWZlcmVuY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucmVmZXJlbmNlLnJlbmRlci5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBwcm9wcykge1xuICAgICAgICAgICAgdGhpc1twXSA9IHByb3BzW3BdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gcmVmZXJlbmNlW2NsYXNzTmFtZV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW3Byb3BdWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgIFByb3BlcnRpZXMucHJvdG90eXBlW3Byb3BdID0gcHJvcGVydGllc1twcm9wXVsnZGVmYXVsdCddO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0c1tjbGFzc05hbWUucmVwbGFjZSgncmVuZGVyXycsJycpXSA9IFByb3BlcnRpZXM7XG59KTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZC5qcycpO1xuXG52YXIgU3R5bGVUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9zdHlsZXRyYW5zaXRpb24uanMnKTtcbnZhciBTdHlsZURlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9zdHlsZWRlY2xhcmF0aW9uLmpzJyk7XG52YXIgU3R5bGVDb25zdGFudCA9IHJlcXVpcmUoJy4vc3R5bGVjb25zdGFudC5qcycpO1xudmFyIENhbGN1bGF0ZWRTdHlsZSA9IHJlcXVpcmUoJy4vY2FsY3VsYXRlZHN0eWxlLmpzJyk7XG52YXIgSW1hZ2VTcHJpdGUgPSByZXF1aXJlKCcuL2ltYWdlc3ByaXRlLmpzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cbi8qXG4gKiBUaGUgbWFwIHN0eWxlJ3MgY3VycmVudCBzdGF0ZVxuICpcbiAqIFRoZSBzdHlsZXNoZWV0IG9iamVjdCBpcyBub3QgbW9kaWZpZWQuIFRvIGNoYW5nZSB0aGUgc3R5bGUsIGp1c3QgY2hhbmdlXG4gKiB0aGUgdGhlIHN0eWxlc2hlZXQgb2JqZWN0IGFuZCB0cmlnZ2VyIGEgY2FzY2FkZS5cbiAqL1xuZnVuY3Rpb24gU3R5bGUoc3R5bGVzaGVldCwgYW5pbWF0aW9uTG9vcCkge1xuICAgIGlmIChzdHlsZXNoZWV0LnZlcnNpb24gIT09IDUpIGNvbnNvbGUud2FybignU3R5bGVzaGVldCB2ZXJzaW9uIG11c3QgYmUgNScpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZXNoZWV0LmxheWVycykpIGNvbnNvbGUud2FybignU3R5bGVzaGVldCBtdXN0IGhhdmUgbGF5ZXJzJyk7XG5cbiAgICB0aGlzLmNsYXNzZXMgPSB7fTtcbiAgICB0aGlzLnN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0O1xuICAgIHRoaXMuYW5pbWF0aW9uTG9vcCA9IGFuaW1hdGlvbkxvb3A7XG5cbiAgICB0aGlzLmJ1Y2tldHMgPSB7fTtcbiAgICB0aGlzLm9yZGVyZWRCdWNrZXRzID0gW107XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IHt9O1xuICAgIHRoaXMuY29tcHV0ZWQgPSB7fTtcbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcblxuICAgIHRoaXMuY2FzY2FkZSh7dHJhbnNpdGlvbjogZmFsc2V9KTtcblxuICAgIGlmIChzdHlsZXNoZWV0LnNwcml0ZSkgdGhpcy5zZXRTcHJpdGUoc3R5bGVzaGVldC5zcHJpdGUpO1xufVxuXG5TdHlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50ZWQpO1xuXG5mdW5jdGlvbiBwcmVtdWx0aXBseUxheWVyKGxheWVyLCB0eXBlKSB7XG4gICAgdmFyIGNvbG9yUHJvcCA9IHR5cGUgKyAnLWNvbG9yJyxcbiAgICAgICAgaGFsb1Byb3AgPSB0eXBlICsgJy1oYWxvLWNvbG9yJyxcbiAgICAgICAgb3V0bGluZVByb3AgPSB0eXBlICsgJy1vdXRsaW5lLWNvbG9yJyxcbiAgICAgICAgY29sb3IgPSBsYXllcltjb2xvclByb3BdLFxuICAgICAgICBoYWxvQ29sb3IgPSBsYXllcltoYWxvUHJvcF0sXG4gICAgICAgIG91dGxpbmVDb2xvciA9IGxheWVyW291dGxpbmVQcm9wXSxcbiAgICAgICAgb3BhY2l0eSA9IGxheWVyW3R5cGUgKyAnLW9wYWNpdHknXTtcblxuICAgIHZhciBjb2xvck9wYWNpdHkgPSBjb2xvciAmJiAob3BhY2l0eSAqIGNvbG9yWzNdKTtcbiAgICB2YXIgaGFsb09wYWNpdHkgPSBoYWxvQ29sb3IgJiYgKG9wYWNpdHkgKiBoYWxvQ29sb3JbM10pO1xuICAgIHZhciBvdXRsaW5lT3BhY2l0eSA9IG91dGxpbmVDb2xvciAmJiAob3BhY2l0eSAqIG91dGxpbmVDb2xvclszXSk7XG5cbiAgICBpZiAoY29sb3JPcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgY29sb3JPcGFjaXR5IDwgMSkge1xuICAgICAgICBsYXllcltjb2xvclByb3BdID0gdXRpbC5wcmVtdWx0aXBseShbY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgY29sb3JPcGFjaXR5XSk7XG4gICAgfVxuICAgIGlmIChoYWxvT3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIGhhbG9PcGFjaXR5IDwgMSkge1xuICAgICAgICBsYXllcltoYWxvUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtoYWxvQ29sb3JbMF0sIGhhbG9Db2xvclsxXSwgaGFsb0NvbG9yWzJdLCBoYWxvT3BhY2l0eV0pO1xuICAgIH1cbiAgICBpZiAob3V0bGluZU9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBvdXRsaW5lT3BhY2l0eSA8IDEpIHtcbiAgICAgICAgbGF5ZXJbb3V0bGluZVByb3BdID0gdXRpbC5wcmVtdWx0aXBseShbb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3V0bGluZU9wYWNpdHldKTtcbiAgICB9XG59XG5cbi8vIEZvcm1lcmx5IGtub3duIGFzIHpvb21lZCBzdHlsZXNcblN0eWxlLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uKHopIHtcbiAgICBpZiAodHlwZW9mIHogIT09ICdudW1iZXInKSBjb25zb2xlLndhcm4oJ3JlY2FsY3VsYXRlIGV4cGVjdHMgem9vbSBsZXZlbCcpO1xuXG4gICAgdmFyIHRyYW5zaXRpb25zID0gdGhpcy50cmFuc2l0aW9ucztcbiAgICB2YXIgbGF5ZXJWYWx1ZXMgPSB7fTtcblxuICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgdGhpcy5yYXN0ZXJGYWRlRHVyYXRpb24gPSAzMDA7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRyYW5zaXRpb25zKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRyYW5zaXRpb25zW25hbWVdLFxuICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5idWNrZXRzW2xheWVyLnJlZiB8fCBuYW1lXSxcbiAgICAgICAgICAgIGxheWVyVHlwZSA9IHRoaXMubGF5ZXJtYXBbbmFtZV0udHlwZTtcblxuICAgICAgICBpZiAoIUNhbGN1bGF0ZWRTdHlsZVtsYXllclR5cGVdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3Vua25vd24gbGF5ZXIgdHlwZSAnICsgbGF5ZXJUeXBlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcHBsaWVkTGF5ZXIgPSBsYXllclZhbHVlc1tuYW1lXSA9IG5ldyBDYWxjdWxhdGVkU3R5bGVbbGF5ZXJUeXBlXSgpO1xuICAgICAgICBmb3IgKHZhciBydWxlIGluIGxheWVyKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGxheWVyW3J1bGVdO1xuICAgICAgICAgICAgYXBwbGllZExheWVyW3J1bGVdID0gdHJhbnNpdGlvbi5hdCh6KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllclR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICBpZiAoKGFwcGxpZWRMYXllclsndGV4dC1vcGFjaXR5J10gPT09IDAgfHwgIWJ1Y2tldC5yZW5kZXJbJ3RleHQtZmllbGQnXSkgJiZcbiAgICAgICAgICAgICAgICAoYXBwbGllZExheWVyWydpY29uLW9wYWNpdHknXSA9PT0gMCB8fCAhYnVja2V0LnJlbmRlclsnaWNvbi1pbWFnZSddKSkge1xuICAgICAgICAgICAgICAgIGFwcGxpZWRMYXllci5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGFwcGxpZWRMYXllciwgJ3RleHQnKTtcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGFwcGxpZWRMYXllciwgJ2ljb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhcHBsaWVkTGF5ZXJbbGF5ZXJUeXBlICsgJy1vcGFjaXR5J10gPT09IDApIHtcbiAgICAgICAgICAgICAgICBhcHBsaWVkTGF5ZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlbXVsdGlwbHlMYXllcihhcHBsaWVkTGF5ZXIsIGxheWVyVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgc291cmNlcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgdXNlZFxuICAgICAgICAvLyBzbyB0aGF0IHdlIGNhbiBhdXRvbWF0aWNhbGx5IGVuYWJsZS9kaXNhYmxlIHRoZW0gYXMgbmVlZGVkXG4gICAgICAgIGlmICghYXBwbGllZExheWVyLmhpZGRlbikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGJ1Y2tldCAmJiBidWNrZXQuc291cmNlO1xuXG4gICAgICAgICAgICAvLyBtYXJrIHNvdXJjZSBhcyB1c2VkIHNvIHRoYXQgdGlsZXMgYXJlIGRvd25sb2FkZWRcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHRoaXMuc291cmNlc1tzb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcHBsaWVkTGF5ZXJbJ3Jhc3Rlci1mYWRlLWR1cmF0aW9uJ10pIHtcbiAgICAgICAgICAgIHRoaXMucmFzdGVyRmFkZUR1cmF0aW9uID0gTWF0aC5tYXgodGhpcy5yYXN0ZXJGYWRlRHVyYXRpb24sIGFwcGxpZWRMYXllclsncmFzdGVyLWZhZGUtZHVyYXRpb24nXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXB1dGVkID0gbGF5ZXJWYWx1ZXM7XG5cbiAgICB0aGlzLnogPSB6O1xuICAgIHRoaXMuZmlyZSgnem9vbScpO1xufTtcblxuU3R5bGUucHJvdG90eXBlLl9zaW1wbGVMYXllciA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIHNpbXBsZSA9IHt9O1xuICAgIHNpbXBsZS5pZCA9IGxheWVyLmlkO1xuXG4gICAgdmFyIGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdO1xuICAgIGlmIChidWNrZXQpIHNpbXBsZS5idWNrZXQgPSBidWNrZXQuaWQ7XG4gICAgaWYgKGxheWVyLnR5cGUpIHNpbXBsZS50eXBlID0gbGF5ZXIudHlwZTtcblxuICAgIGlmIChsYXllci5sYXllcnMpIHtcbiAgICAgICAgc2ltcGxlLmxheWVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2ltcGxlLmxheWVycy5wdXNoKHRoaXMuX3NpbXBsZUxheWVyKGxheWVyLmxheWVyc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGU7XG59O1xuXG4vLyBTcGxpdCB0aGUgbGF5ZXJzIGludG8gZ3JvdXBzIG9mIGNvbnNlY3V0aXZlIGxheWVycyB3aXRoIHRoZSBzYW1lIGRhdGFzb3VyY2VcblN0eWxlLnByb3RvdHlwZS5fZ3JvdXBMYXllcnMgPSBmdW5jdGlvbihsYXllcnMpIHtcbiAgICB2YXIgZyA9IDA7XG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIHZhciBncm91cDtcblxuICAgIC8vIGxvb3Agb3ZlciBsYXllcnMgdG9wIGRvd25cbiAgICBmb3IgKHZhciBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgICB2YXIgYnVja2V0ID0gdGhpcy5idWNrZXRzW2xheWVyLnJlZiB8fCBsYXllci5pZF07XG4gICAgICAgIHZhciBzb3VyY2UgPSBidWNrZXQgJiYgYnVja2V0LnNvdXJjZTtcblxuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBsYXllciBpcyBpbiBhIGRpZmZlcmVudCBzb3VyY2VcbiAgICAgICAgaWYgKGdyb3VwICYmIHNvdXJjZSAhPT0gZ3JvdXAuc291cmNlKSBnKys7XG5cbiAgICAgICAgaWYgKCFncm91cHNbZ10pIHtcbiAgICAgICAgICAgIGdyb3VwID0gW107XG4gICAgICAgICAgICBncm91cC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICBncm91cHNbZ10gPSBncm91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwLnB1c2godGhpcy5fc2ltcGxlTGF5ZXIobGF5ZXIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXBzO1xufTtcblxuLypcbiAqIFRha2UgYWxsIHRoZSBydWxlcyBhbmQgZGVjbGFyYXRpb25zIGZyb20gdGhlIHN0eWxlc2hlZXQsXG4gKiBhbmQgZmlndXJlIG91dCB3aGljaCBhcHBseSBjdXJyZW50bHlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmNhc2NhZGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlXG4gICAgfTtcblxuICAgIHZhciBhLCBiO1xuICAgIHZhciBpZDtcbiAgICB2YXIgcHJvcDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIGNsYXNzTmFtZTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZTtcbiAgICB2YXIgc3R5bGVUcmFucztcbiAgICB2YXIgY29uc3RhbnRzID0gdGhpcy5zdHlsZXNoZWV0LmNvbnN0YW50cztcblxuICAgIC8vIGRlcml2ZSBidWNrZXRzIGZyb20gbGF5ZXJzXG4gICAgdGhpcy5vcmRlcmVkQnVja2V0cyA9IFtdO1xuICAgIHRoaXMuYnVja2V0cyA9IGdldGJ1Y2tldHMoe30sIHRoaXMub3JkZXJlZEJ1Y2tldHMsIHRoaXMuc3R5bGVzaGVldC5sYXllcnMpO1xuICAgIGZ1bmN0aW9uIGdldGJ1Y2tldHMoYnVja2V0cywgb3JkZXJlZCwgbGF5ZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbGF5ZXJzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbYV07XG4gICAgICAgICAgICBpZiAobGF5ZXIubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgYnVja2V0cyA9IGdldGJ1Y2tldHMoYnVja2V0cywgb3JkZXJlZCwgbGF5ZXIubGF5ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGF5ZXIuc291cmNlIHx8ICFsYXllci50eXBlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0geyBpZDogbGF5ZXIuaWQgfTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKC9ec3R5bGUvKS50ZXN0KHByb3ApKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBidWNrZXRbcHJvcF0gPSBsYXllcltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5yZW5kZXIgPSBTdHlsZUNvbnN0YW50LnJlc29sdmUoYnVja2V0LnJlbmRlciwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGJ1Y2tldHNbbGF5ZXIuaWRdID0gYnVja2V0O1xuICAgICAgICAgICAgb3JkZXJlZC5wdXNoKGJ1Y2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1Y2tldHM7XG4gICAgfVxuXG4gICAgLy8gc3R5bGUgY2xhc3Mga2V5c1xuICAgIHZhciBzdHlsZU5hbWVzID0gWydzdHlsZSddO1xuICAgIGZvciAoY2xhc3NOYW1lIGluIHRoaXMuY2xhc3Nlcykgc3R5bGVOYW1lcy5wdXNoKCdzdHlsZS4nICsgY2xhc3NOYW1lKTtcblxuICAgIC8vIGFwcGx5IGxheWVyIGdyb3VwIGluaGVyaXRhbmNlIHJlc3VsdGluZyBpbiBhIGZsYXR0ZW5lZCBhcnJheVxuICAgIHZhciBmbGF0dGVuZWQgPSBmbGF0dGVuTGF5ZXJzKHRoaXMuc3R5bGVzaGVldC5sYXllcnMpO1xuXG4gICAgLy8gbWFwIGxheWVyIGlkcyB0byBsYXllciBkZWZpbml0aW9ucyBmb3IgcmVzb2x2aW5nIHJlZnNcbiAgICB2YXIgbGF5ZXJtYXAgPSB0aGlzLmxheWVybWFwID0ge307XG4gICAgZm9yIChhID0gMDsgYSA8IGZsYXR0ZW5lZC5sZW5ndGg7IGErKykge1xuICAgICAgICBsYXllciA9IGZsYXR0ZW5lZFthXTtcblxuICAgICAgICB2YXIgbmV3TGF5ZXIgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBsYXllcikge1xuICAgICAgICAgICAgaWYgKGsgPT09ICdsYXllcnMnKSBjb250aW51ZTtcbiAgICAgICAgICAgIG5ld0xheWVyW2tdID0gbGF5ZXJba107XG4gICAgICAgIH1cblxuICAgICAgICBsYXllcm1hcFtsYXllci5pZF0gPSBuZXdMYXllcjtcbiAgICAgICAgZmxhdHRlbmVkW2FdID0gbmV3TGF5ZXI7XG4gICAgfVxuXG4gICAgZm9yIChhID0gMDsgYSA8IGZsYXR0ZW5lZC5sZW5ndGg7IGErKykge1xuICAgICAgICBmbGF0dGVuZWRbYV0gPSByZXNvbHZlTGF5ZXIobGF5ZXJtYXAsIGZsYXR0ZW5lZFthXSk7XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBsYXllciByZWZlcmVuY2VzLlxuICAgIGZ1bmN0aW9uIHJlc29sdmVMYXllcihsYXllcm1hcCwgbGF5ZXIpIHtcbiAgICAgICAgaWYgKCFsYXllci5yZWYgfHwgIWxheWVybWFwW2xheWVyLnJlZl0pIHJldHVybiBsYXllcjtcblxuICAgICAgICB2YXIgcGFyZW50ID0gcmVzb2x2ZUxheWVyKGxheWVybWFwLCBsYXllcm1hcFtsYXllci5yZWZdKTtcbiAgICAgICAgbGF5ZXIucmVuZGVyID0gcGFyZW50LnJlbmRlcjtcbiAgICAgICAgbGF5ZXIudHlwZSA9IHBhcmVudC50eXBlO1xuICAgICAgICBsYXllci5maWx0ZXIgPSBwYXJlbnQuZmlsdGVyO1xuICAgICAgICBsYXllci5zb3VyY2UgPSBwYXJlbnQuc291cmNlO1xuICAgICAgICBsYXllclsnc291cmNlLWxheWVyJ10gPSBwYXJlbnRbJ3NvdXJjZS1sYXllciddO1xuICAgICAgICBsYXllclsnbWluLXpvb20nXSA9IHBhcmVudFsnbWluLXpvb20nXTtcbiAgICAgICAgbGF5ZXJbJ21heC16b29tJ10gPSBwYXJlbnRbJ21heC16b29tJ107XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cblxuICAgIC8vIEZsYXR0ZW4gY29tcG9zaXRlIGxheWVyIHN0cnVjdHVyZXMuXG4gICAgZnVuY3Rpb24gZmxhdHRlbkxheWVycyhsYXllcnMpIHtcbiAgICAgICAgdmFyIGZsYXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZsYXQucHVzaChsYXllcnNbaV0pO1xuICAgICAgICAgICAgaWYgKGxheWVyc1tpXS5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICBmbGF0LnB1c2guYXBwbHkoZmxhdCwgZmxhdHRlbkxheWVycyhsYXllcnNbaV0ubGF5ZXJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25zID0ge307XG4gICAgdmFyIGdsb2JhbFRyYW5zID0gdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb247XG5cbiAgICBmb3IgKGEgaW4gZmxhdHRlbmVkKSB7XG4gICAgICAgIGxheWVyID0gZmxhdHRlbmVkW2FdO1xuXG4gICAgICAgIGlkID0gbGF5ZXIuaWQ7XG4gICAgICAgIHN0eWxlID0ge307XG4gICAgICAgIHN0eWxlVHJhbnMgPSB7fTtcblxuICAgICAgICAvLyBiYXNpYyBjYXNjYWRpbmcgb2Ygc3R5bGVzXG4gICAgICAgIGZvciAoYiA9IDA7IGIgPCBzdHlsZU5hbWVzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZU5hbWVzW2JdO1xuICAgICAgICAgICAgaWYgKCFsYXllcltzdHlsZU5hbWVdKSBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIHNldCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gbGF5ZXJbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmluZGV4T2YoJ3RyYW5zaXRpb24tJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlW3Byb3BdID0gbGF5ZXJbc3R5bGVOYW1lXVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRyYW5zW3Byb3AucmVwbGFjZSgndHJhbnNpdGlvbi0nLCAnJyldID0gbGF5ZXJbc3R5bGVOYW1lXVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZSA9IFN0eWxlQ29uc3RhbnQucmVzb2x2ZShzdHlsZSwgY29uc3RhbnRzKTtcblxuICAgICAgICB2YXIgcmVuZGVyVHlwZSA9IGxheWVyLnR5cGU7XG4gICAgICAgIHRyYW5zaXRpb25zW2lkXSA9IHt9O1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBzdHlsZSkge1xuICAgICAgICAgICAgdmFyIG5ld0RlY2xhcmF0aW9uID0gbmV3IFN0eWxlRGVjbGFyYXRpb24ocmVuZGVyVHlwZSwgcHJvcCwgc3R5bGVbcHJvcF0pO1xuICAgICAgICAgICAgdmFyIG9sZFRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25zW2lkXSAmJiB0aGlzLnRyYW5zaXRpb25zW2lkXVtwcm9wXTtcbiAgICAgICAgICAgIHZhciBuZXdTdHlsZVRyYW5zID0ge307XG4gICAgICAgICAgICBuZXdTdHlsZVRyYW5zLmR1cmF0aW9uID0gc3R5bGVUcmFuc1twcm9wXSAmJiBzdHlsZVRyYW5zW3Byb3BdLmR1cmF0aW9uID8gc3R5bGVUcmFuc1twcm9wXS5kdXJhdGlvbiA6IGdsb2JhbFRyYW5zICYmIGdsb2JhbFRyYW5zLmR1cmF0aW9uID8gZ2xvYmFsVHJhbnMuZHVyYXRpb24gOiAzMDA7XG4gICAgICAgICAgICBuZXdTdHlsZVRyYW5zLmRlbGF5ID0gc3R5bGVUcmFuc1twcm9wXSAmJiBzdHlsZVRyYW5zW3Byb3BdLmRlbGF5ID8gc3R5bGVUcmFuc1twcm9wXS5kZWxheSA6IGdsb2JhbFRyYW5zICYmIGdsb2JhbFRyYW5zLmRlbGF5ID8gZ2xvYmFsVHJhbnMuZGVsYXkgOiAwO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIG5ld1N0eWxlVHJhbnMuZHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIG5ld1N0eWxlVHJhbnMuZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBhIG5ldyB0cmFuc2l0aW9uIGlmIHRoZSBkZWNsYXJhdGlvbiBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAoIW9sZFRyYW5zaXRpb24gfHwgb2xkVHJhbnNpdGlvbi5kZWNsYXJhdGlvbi5qc29uICE9PSBuZXdEZWNsYXJhdGlvbi5qc29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1RyYW5zaXRpb24gPSBuZXcgU3R5bGVUcmFuc2l0aW9uKG5ld0RlY2xhcmF0aW9uLCBvbGRUcmFuc2l0aW9uLCBuZXdTdHlsZVRyYW5zKTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1tpZF1bcHJvcF0gPSBuZXdUcmFuc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVuIHRoZSBhbmltYXRpb24gbG9vcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdUcmFuc2l0aW9uLmluc3RhbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUcmFuc2l0aW9uLmxvb3BJRCA9IHRoaXMuYW5pbWF0aW9uTG9vcC5zZXQobmV3VHJhbnNpdGlvbi5lbmRUaW1lIC0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9sZFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wLmNhbmNlbChvbGRUcmFuc2l0aW9uLmxvb3BJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1tpZF1bcHJvcF0gPSBvbGRUcmFuc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICAgIHRoaXMubGF5ZXJHcm91cHMgPSB0aGlzLl9ncm91cExheWVycyh0aGlzLnN0eWxlc2hlZXQubGF5ZXJzKTtcblxuICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG59O1xuXG4vKiBUaGlzIHNob3VsZCBiZSBtb3ZlZCBlbHNld2hlcmUuIExvY2FsaXppbmcgcmVzb3VyY2VzIGRvZXNuJ3QgYmVsb25nIGhlcmUgKi9cblN0eWxlLnByb3RvdHlwZS5zZXRTcHJpdGUgPSBmdW5jdGlvbihzcHJpdGUpIHtcbiAgICB0aGlzLnNwcml0ZSA9IG5ldyBJbWFnZVNwcml0ZShzcHJpdGUpO1xuICAgIHRoaXMuc3ByaXRlLm9uKCdsb2FkZWQnLCB0aGlzLmZpcmUuYmluZCh0aGlzLCAnY2hhbmdlJykpO1xufTtcblxuLy8gTW9kaWZ5IGNsYXNzZXNcblN0eWxlLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uKG4sIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5jbGFzc2VzW25dKSByZXR1cm47IC8vIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvblxuICAgIHRoaXMuY2xhc3Nlc1tuXSA9IHRydWU7XG4gICAgdGhpcy5jYXNjYWRlKG9wdGlvbnMpO1xufTtcblxuU3R5bGUucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24obiwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jbGFzc2VzW25dKSByZXR1cm47IC8vIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvblxuICAgIGRlbGV0ZSB0aGlzLmNsYXNzZXNbbl07XG4gICAgdGhpcy5jYXNjYWRlKG9wdGlvbnMpO1xufTtcblxuU3R5bGUucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiAhIXRoaXMuY2xhc3Nlc1tuXTtcbn07XG5cblN0eWxlLnByb3RvdHlwZS5zZXRDbGFzc0xpc3QgPSBmdW5jdGlvbihsLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2xhc3Nlc1tsW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuY2FzY2FkZShvcHRpb25zKTtcbn07XG5cblN0eWxlLnByb3RvdHlwZS5nZXRDbGFzc0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jbGFzc2VzKTtcbn07XG5cblN0eWxlLnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJtYXBbaWRdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcblxubW9kdWxlLmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBjb25zdGFudHMpIHtcbiAgICBpZiAoIWNvbnN0YW50cylcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG5cbiAgICB2YXIgcmVzdWx0ID0ge30sIGk7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnQCcgPyBjb25zdGFudHNbdmFsdWVdIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzb2x2ZShwcm9wZXJ0aWVzW2tleV0pO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbaV0gaW4gY29uc3RhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzb2x2ZSh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLnN0b3BzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwuZXh0ZW5kKHt9LCB2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZS5zdG9wcyA9IHZhbHVlLnN0b3BzLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5zdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdG9wc1tpXVsxXSBpbiBjb25zdGFudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3RvcHNbaV0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnN0b3BzW2ldWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZS5zdG9wc1tpXVsxXSlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpLFxuICAgIHJlZmVyZW5jZSA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlJyksXG4gICAgcGFyc2VDU1NDb2xvciA9IHJlcXVpcmUoJ2Nzc2NvbG9ycGFyc2VyJykucGFyc2VDU1NDb2xvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZURlY2xhcmF0aW9uO1xuXG4vKlxuICogQSBwYXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYSBwcm9wZXJ0eTp2YWx1ZSBwYWlyXG4gKi9cbmZ1bmN0aW9uIFN0eWxlRGVjbGFyYXRpb24ocmVuZGVyVHlwZSwgcHJvcCwgdmFsdWUpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gJ2NsYXNzXycgKyByZW5kZXJUeXBlO1xuICAgIHZhciBwcm9wUmVmZXJlbmNlID0gcmVmZXJlbmNlW2NsYXNzTmFtZV0gJiYgcmVmZXJlbmNlW2NsYXNzTmFtZV1bcHJvcF07XG4gICAgaWYgKCFwcm9wUmVmZXJlbmNlKSByZXR1cm47XG5cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5wYXJzZVZhbHVlKHZhbHVlLCBwcm9wUmVmZXJlbmNlLnR5cGUsIHByb3BSZWZlcmVuY2UudmFsdWVzKTtcbiAgICB0aGlzLnByb3AgPSBwcm9wO1xuICAgIHRoaXMudHlwZSA9IHByb3BSZWZlcmVuY2UudHlwZTtcblxuICAgIC8vIGltbXVhdGFibGUgcmVwcmVzZW50YXRpb24gb2YgdmFsdWUuIHVzZWQgZm9yIGNvbXBhcmlzb25cbiAgICB0aGlzLmpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbn1cblxuU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24oeikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMudmFsdWUoeikgOiB0aGlzLnZhbHVlO1xufTtcblxuU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucGFyc2VWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB0eXBlLCB2YWx1ZXMpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICByZXR1cm4gcGFyc2VDb2xvcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyQXJyYXkodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VudW0nICYmIEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmluZGV4T2YodmFsdWUpID49IDAgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4odHlwZSArICcgaXMgbm90IGEgc3VwcG9ydGVkIHByb3BlcnR5IHR5cGUnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZU51bWJlcihudW0pIHtcbiAgICBpZiAobnVtLnN0b3BzKSBudW0gPSBzdG9wc0ZuKG51bSk7XG4gICAgdmFyIHZhbHVlID0gK251bTtcbiAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSA/IHZhbHVlIDogbnVtO1xufVxuXG5mdW5jdGlvbiBwYXJzZU51bWJlckFycmF5KGFycmF5KSB7XG4gICAgdmFyIHdpZHRocyA9IGFycmF5Lm1hcChwYXJzZU51bWJlcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlb2Ygd2lkdGhzW2ldID09PSAnZnVuY3Rpb24nID8gd2lkdGhzW2ldKHopIDogd2lkdGhzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbnZhciBjb2xvckNhY2hlID0ge307XG5cbmZ1bmN0aW9uIHBhcnNlQ29sb3IodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuc3RvcHMpIHJldHVybiBzdG9wc0ZuKHZhbHVlLCB0cnVlKTtcbiAgICBpZiAoY29sb3JDYWNoZVt2YWx1ZV0pIHJldHVybiBjb2xvckNhY2hlW3ZhbHVlXTtcblxuICAgIHZhciBjb2xvciA9IGNvbG9yQ2FjaGVbdmFsdWVdID0gcHJlcGFyZUNvbG9yKHBhcnNlQ1NTQ29sb3IodmFsdWUpKTtcbiAgICByZXR1cm4gY29sb3I7XG59XG5cbmZ1bmN0aW9uIHN0b3BzRm4ocGFyYW1zLCBjb2xvcikge1xuICAgIHZhciBzdG9wcyA9IHBhcmFtcy5zdG9wcztcbiAgICB2YXIgYmFzZSA9IHBhcmFtcy5iYXNlIHx8IHJlZmVyZW5jZS5mdW5jdGlvbi5iYXNlLmRlZmF1bHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeikge1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHR3byBzdG9wcyB3aGljaCB0aGUgY3VycmVudCB6IGlzIGJldHdlZW5cbiAgICAgICAgdmFyIGxvdywgaGlnaDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldO1xuICAgICAgICAgICAgaWYgKHN0b3BbMF0gPD0geikgbG93ID0gc3RvcDtcbiAgICAgICAgICAgIGlmIChzdG9wWzBdID4geikge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBzdG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvdyAmJiBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgem9vbURpZmYgPSBoaWdoWzBdIC0gbG93WzBdLFxuICAgICAgICAgICAgICAgIHpvb21Qcm9ncmVzcyA9IHogLSBsb3dbMF0sXG5cbiAgICAgICAgICAgICAgICB0ID0gYmFzZSA9PT0gMSA/XG4gICAgICAgICAgICAgICAgICAgIHpvb21Qcm9ncmVzcyAvIHpvb21EaWZmIDpcbiAgICAgICAgICAgICAgICAgICAgKE1hdGgucG93KGJhc2UsIHpvb21Qcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCB6b29tRGlmZikgLSAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbG9yKSByZXR1cm4gaW50ZXJwQ29sb3IocGFyc2VDb2xvcihsb3dbMV0pLCBwYXJzZUNvbG9yKGhpZ2hbMV0pLCB0KTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHV0aWwuaW50ZXJwKGxvd1sxXSwgaGlnaFsxXSwgdCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChsb3cpIHtcbiAgICAgICAgICAgIGlmIChjb2xvcikgcmV0dXJuIHBhcnNlQ29sb3IobG93WzFdKTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGxvd1sxXTtcblxuICAgICAgICB9IGVsc2UgaWYgKGhpZ2gpIHtcbiAgICAgICAgICAgIGlmIChjb2xvcikgcmV0dXJuIHBhcnNlQ29sb3IoaGlnaFsxXSk7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBoaWdoWzFdO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29sb3IpIHJldHVybiBbMCwgMCwgMCwgMV07XG4gICAgICAgICAgICBlbHNlIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbG9yKGMpIHtcbiAgICByZXR1cm4gW2NbMF0gLyAyNTUsIGNbMV0gLyAyNTUsIGNbMl0gLyAyNTUsIGNbM10gLyAxXTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwQ29sb3IoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB1dGlsLmludGVycChmcm9tWzBdLCB0b1swXSwgdCksXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bMV0sIHRvWzFdLCB0KSxcbiAgICAgICAgdXRpbC5pbnRlcnAoZnJvbVsyXSwgdG9bMl0sIHQpLFxuICAgICAgICB1dGlsLmludGVycChmcm9tWzNdLCB0b1szXSwgdClcbiAgICBdO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlVHJhbnNpdGlvbjtcblxuLypcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2l0aW9uIGJldHdlZW4gdHdvIGRlY2xhcmF0aW9uc1xuICovXG5mdW5jdGlvbiBTdHlsZVRyYW5zaXRpb24oZGVjbGFyYXRpb24sIG9sZFRyYW5zaXRpb24sIHZhbHVlKSB7XG5cbiAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmVuZFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgdmFyIHR5cGUgPSBkZWNsYXJhdGlvbi50eXBlO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmludGVycCA9IHV0aWwuaW50ZXJwO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICB0aGlzLmludGVycCA9IGludGVycENvbG9yO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICB0aGlzLmludGVycCA9IGludGVycE51bWJlckFycmF5O1xuICAgIH1cblxuICAgIHRoaXMub2xkVHJhbnNpdGlvbiA9IG9sZFRyYW5zaXRpb247XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZhbHVlLmR1cmF0aW9uIHx8IDA7XG4gICAgdGhpcy5kZWxheSA9IHZhbHVlLmRlbGF5IHx8IDA7XG5cbiAgICBpZiAoIXRoaXMuaW5zdGFudCgpKSB7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lICsgdGhpcy5kdXJhdGlvbiArIHRoaXMuZGVsYXk7XG4gICAgICAgIHRoaXMuZWFzZSA9IHV0aWwuZWFzZUN1YmljSW5PdXQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFRyYW5zaXRpb24gJiYgb2xkVHJhbnNpdGlvbi5lbmRUaW1lIDw9IHRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE9sZCB0cmFuc2l0aW9uIGlzIGRvbmUgcnVubmluZywgc28gd2UgY2FuXG4gICAgICAgIC8vIGRlbGV0ZSBpdHMgcmVmZXJlbmNlIHRvIGl0cyBvbGQgdHJhbnNpdGlvbi5cblxuICAgICAgICBkZWxldGUgb2xkVHJhbnNpdGlvbi5vbGRUcmFuc2l0aW9uO1xuICAgIH1cbn1cblxuU3R5bGVUcmFuc2l0aW9uLnByb3RvdHlwZS5pbnN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm9sZFRyYW5zaXRpb24gfHwgIXRoaXMuaW50ZXJwIHx8ICh0aGlzLmR1cmF0aW9uID09PSAwICYmIHRoaXMuZGVsYXkgPT09IDApO1xufTtcblxuLypcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHRyYW5zaXRpb25pbmcgcHJvcGVydHkgYXQgem9vbSBsZXZlbCBgemAgYW5kIG9wdGlvbmFsIHRpbWUgYHRgXG4gKi9cblN0eWxlVHJhbnNpdGlvbi5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbih6LCB0KSB7XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLmRlY2xhcmF0aW9uLmNhbGN1bGF0ZSh6KTtcblxuICAgIGlmICh0aGlzLmluc3RhbnQoKSkgcmV0dXJuIHZhbHVlO1xuXG4gICAgdCA9IHQgfHwgRGF0ZS5ub3coKTtcblxuICAgIGlmICh0IDwgdGhpcy5lbmRUaW1lKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMub2xkVHJhbnNpdGlvbi5hdCh6LCB0aGlzLnN0YXJ0VGltZSk7XG4gICAgICAgIHZhciBlYXNlZCA9IHRoaXMuZWFzZSgodCAtIHRoaXMuc3RhcnRUaW1lIC0gdGhpcy5kZWxheSkgLyB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmludGVycChvbGRWYWx1ZSwgdmFsdWUsIGVhc2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG5cbn07XG5cbmZ1bmN0aW9uIGludGVycE51bWJlckFycmF5KGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIGZyb20ubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaW50ZXJwKGQsIHRvW2ldLCB0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwQ29sb3IoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB1dGlsLmludGVycChmcm9tWzBdLCB0b1swXSwgdCksXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bMV0sIHRvWzFdLCB0KSxcbiAgICAgICAgdXRpbC5pbnRlcnAoZnJvbVsyXSwgdG9bMl0sIHQpLFxuICAgICAgICB1dGlsLmludGVycChmcm9tWzNdLCB0b1szXSwgdClcbiAgICBdO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuY2hvcjtcblxuZnVuY3Rpb24gQW5jaG9yKHgsIHksIGFuZ2xlLCBzY2FsZSwgc2VnbWVudCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuXG4gICAgaWYgKHNlZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlZ21lbnQgPSBzZWdtZW50O1xuICAgIH1cbn1cblxuQW5jaG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9pbnQucHJvdG90eXBlKTtcblxuQW5jaG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQW5jaG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLmFuZ2xlLCB0aGlzLnNjYWxlLCB0aGlzLnNlZ21lbnQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBCaW5QYWNrO1xuZnVuY3Rpb24gQmluUGFjayh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZnJlZSA9IFt7IHg6IDAsIHk6IDAsIHc6IHdpZHRoLCBoOiBoZWlnaHQgfV07XG59XG5cbkJpblBhY2sucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgLy8gU2ltcGxlIGFsZ29yaXRobSB0byByZWN1cnNpdmVseSBtZXJnZSB0aGUgbmV3bHkgcmVsZWFzZWQgY2VsbCB3aXRoIGl0c1xuICAgIC8vIG5laWdoYm9yLiBUaGlzIGRvZXNuJ3QgbWVyZ2UgbW9yZSB0aGFuIHR3byBjZWxscyBhdCBhIHRpbWUsIGFuZCBmYWlsc1xuICAgIC8vIGZvciBjb21wbGljYXRlZCBtZXJnZXMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZyZWUgPSB0aGlzLmZyZWVbaV07XG4gICAgICAgIGlmIChmcmVlLnkgPT0gcmVjdC55ICYmIGZyZWUuaCA9PSByZWN0LmggJiYgZnJlZS54ICsgZnJlZS53ID09IHJlY3QueCkge1xuICAgICAgICAgICAgZnJlZS53ICs9IHJlY3QudztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcmVlLnggPT0gcmVjdC54ICYmIGZyZWUudyA9PSByZWN0LncgJiYgZnJlZS55ICsgZnJlZS5oID09IHJlY3QueSkge1xuICAgICAgICAgICAgZnJlZS5oICs9IHJlY3QuaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWN0LnkgPT0gZnJlZS55ICYmIHJlY3QuaCA9PSBmcmVlLmggJiYgcmVjdC54ICsgcmVjdC53ID09IGZyZWUueCkge1xuICAgICAgICAgICAgZnJlZS54ID0gcmVjdC54O1xuICAgICAgICAgICAgZnJlZS53ICs9IHJlY3QudztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWN0LnggPT0gZnJlZS54ICYmIHJlY3QudyA9PSBmcmVlLncgJiYgcmVjdC55ICsgcmVjdC5oID09IGZyZWUueSkge1xuICAgICAgICAgICAgZnJlZS55ID0gcmVjdC55O1xuICAgICAgICAgICAgZnJlZS5oICs9IHJlY3QuaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5yZWxlYXNlKGZyZWUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICB9XG4gICAgdGhpcy5mcmVlLnB1c2gocmVjdCk7XG59O1xuXG5CaW5QYWNrLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBGaW5kIHRoZSBzbWFsbGVzdCBmcmVlIHJlY3QgYW5nbGVcbiAgICB2YXIgcmVjdCA9IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB3OiBJbmZpbml0eSwgaDogSW5maW5pdHkgfTtcbiAgICB2YXIgc21hbGxlc3QgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5mcmVlW2ldO1xuICAgICAgICBpZiAod2lkdGggPD0gcmVmLncgJiYgaGVpZ2h0IDw9IHJlZi5oICYmIHJlZi55IDw9IHJlY3QueSAmJiByZWYueCA8PSByZWN0LngpIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWY7XG4gICAgICAgICAgICBzbWFsbGVzdCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc21hbGxlc3QgPCAwKSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gc3BhY2UgbGVmdCBmb3IgdGhpcyBjaGFyLlxuICAgICAgICByZXR1cm4geyB4OiAtMSwgeTogLTEgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZyZWUuc3BsaWNlKHNtYWxsZXN0LCAxKTtcblxuICAgICAgICAvLyBTaG9ydGVyL0xvbmdlciBBeGlzIFNwbGl0IFJ1bGUgKFNBUylcbiAgICAgICAgLy8gaHR0cDovL2NsYi5kZW1vbi5maS9maWxlcy9SZWN0YW5nbGVCaW5QYWNrLnBkZiBwLiAxNVxuICAgICAgICAvLyBJZ25vcmUgdGhlIGRpbWVuc2lvbiBvZiBSIGFuZCBqdXN0IHNwbGl0IGxvbmcgdGhlIHNob3J0ZXIgZGltZW5zaW9uXG4gICAgICAgIC8vIFNlZSBBbHNvOiBodHRwOi8vd3d3LmNzLnByaW5jZXRvbi5lZHUvfmNoYXplbGxlL3B1YnMvYmxiaW5wYWNraW5nLnBkZlxuICAgICAgICBpZiAocmVjdC53IDwgcmVjdC5oKSB7XG4gICAgICAgICAgICAvLyBzcGxpdCBob3Jpem9udGFsbHlcbiAgICAgICAgICAgIC8vICstLSstLS0rXG4gICAgICAgICAgICAvLyB8X198X19ffCAgPC0tIGIxXG4gICAgICAgICAgICAvLyArLS0tLS0tKyAgPC0tIGIyXG4gICAgICAgICAgICBpZiAocmVjdC53ID4gd2lkdGgpIHRoaXMuZnJlZS5wdXNoKHsgeDogcmVjdC54ICsgd2lkdGgsIHk6IHJlY3QueSwgdzogcmVjdC53IC0gd2lkdGgsIGg6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIGlmIChyZWN0LmggPiBoZWlnaHQpIHRoaXMuZnJlZS5wdXNoKHsgeDogcmVjdC54LCB5OiByZWN0LnkgKyBoZWlnaHQsIHc6IHJlY3QudywgaDogcmVjdC5oIC0gaGVpZ2h0IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc3BsaXQgdmVydGljYWxseVxuICAgICAgICAgICAgLy8gKy0tKy0tLStcbiAgICAgICAgICAgIC8vIHxfX3wgICB8IDwtLSBiMVxuICAgICAgICAgICAgLy8gKy0tfC0tLSsgPC0tIGIyXG4gICAgICAgICAgICBpZiAocmVjdC53ID4gd2lkdGgpIHRoaXMuZnJlZS5wdXNoKHsgeDogcmVjdC54ICsgd2lkdGgsIHk6IHJlY3QueSwgdzogcmVjdC53IC0gd2lkdGgsIGg6IHJlY3QuaCB9KTtcbiAgICAgICAgICAgIGlmIChyZWN0LmggPiBoZWlnaHQpIHRoaXMuZnJlZS5wdXNoKHsgeDogcmVjdC54LCB5OiByZWN0LnkgKyBoZWlnaHQsIHc6IHdpZHRoLCBoOiByZWN0LmggLSBoZWlnaHQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB4OiByZWN0LngsIHk6IHJlY3QueSwgdzogd2lkdGgsIGg6IGhlaWdodCB9O1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByYnVzaCA9IHJlcXVpcmUoJ3JidXNoJyksXG4gICAgcm90YXRpb25SYW5nZSA9IHJlcXVpcmUoJy4vcm90YXRpb25yYW5nZS5qcycpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb247XG5cbmZ1bmN0aW9uIENvbGxpc2lvbih6b29tLCB0aWxlRXh0ZW50LCB0aWxlU2l6ZSwgcGxhY2VtZW50RGVwdGgpIHtcbiAgICB0aGlzLmhUcmVlID0gcmJ1c2goKTsgLy8gdHJlZSBmb3IgaG9yaXpvbnRhbCBsYWJlbHNcbiAgICB0aGlzLmNUcmVlID0gcmJ1c2goKTsgLy8gdHJlZSBmb3IgZ2x5cGhzIGZyb20gY3VydmVkIGxhYmVsc1xuXG4gICAgLy8gdGlsZSBwaXhlbHMgcGVyIHNjcmVlbiBwaXhlbHMgYXQgdGhlIHRpbGUncyB6b29tIGxldmVsXG4gICAgdGhpcy50aWxlUGl4ZWxSYXRpbyA9IHRpbGVFeHRlbnQgLyB0aWxlU2l6ZTtcblxuICAgIHRoaXMuem9vbSA9IHpvb207XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1heGltdW0gc2NhbGUgd2UgY2FuIGdvIGRvd24gaW4gb3VyIGZha2UtM2QgcnRyZWUgc28gdGhhdFxuICAgIC8vIHBsYWNlbWVudCBzdGlsbCBtYWtlcyBzZW5zZS4gVGhpcyBpcyBjYWxjdWxhdGVkIHNvIHRoYXQgdGhlIG1pbmltdW1cbiAgICAvLyBwbGFjZW1lbnQgem9vbSBjYW4gYmUgYXQgbW9zdCAyNS41ICh3ZSB1c2UgYW4gdW5zaWduZWQgaW50ZWdlciB4MTAgdG9cbiAgICAvLyBzdG9yZSB0aGUgbWluaW11bSB6b29tKS5cbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcGxhY2UgbGFiZWxzIGFsbCB0aGUgd2F5IHRvIDI1LjUuIFRoaXMgbGV0cyB0b28gbWFueVxuICAgIC8vIGdseXBocyBiZSBwbGFjZWQsIHNsb3dpbmcgZG93biBjb2xsaXNpb24gY2hlY2tpbmcuIE9ubHkgcGxhY2UgbGFiZWxzIGlmXG4gICAgLy8gdGhleSB3aWxsIHNob3cgdXAgd2l0aGluIHRoZSBpbnRlbmRlZCB6b29tIHJhbmdlIG9mIHRoZSB0aWxlLlxuICAgIHBsYWNlbWVudERlcHRoID0gTWF0aC5taW4oMywgcGxhY2VtZW50RGVwdGggfHwgMSwgMjUuNSAtIHRoaXMuem9vbSk7XG4gICAgdGhpcy5tYXhQbGFjZW1lbnRTY2FsZSA9IE1hdGguZXhwKE1hdGguTE4yICogcGxhY2VtZW50RGVwdGgpO1xuXG4gICAgdmFyIG0gPSA0MDk2O1xuICAgIHZhciBlZGdlID0gbSAqIHRoaXMudGlsZVBpeGVsUmF0aW8gKiAyO1xuXG4gICAgdmFyIGZ1bGxSYW5nZSA9IFtNYXRoLlBJICogMiwgMF07XG5cbiAgICB0aGlzLmxlZnQgPSB7XG4gICAgICAgIGFuY2hvcjogbmV3IFBvaW50KDAsIDApLFxuICAgICAgICBib3g6IHsgeDE6IC1lZGdlLCB5MTogLWVkZ2UsIHgyOiAwLCB5MjogZWRnZSB9LFxuICAgICAgICBwbGFjZW1lbnRSYW5nZTogZnVsbFJhbmdlLFxuICAgICAgICBwbGFjZW1lbnRTY2FsZTogMC41LFxuICAgICAgICBtYXhTY2FsZTogSW5maW5pdHksXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuXG4gICAgdGhpcy50b3AgPSB7XG4gICAgICAgIGFuY2hvcjogbmV3IFBvaW50KDAsIDApLFxuICAgICAgICBib3g6IHsgeDE6IC1lZGdlLCB5MTogLWVkZ2UsIHgyOiBlZGdlLCB5MjogMCB9LFxuICAgICAgICBwbGFjZW1lbnRSYW5nZTogZnVsbFJhbmdlLFxuICAgICAgICBwbGFjZW1lbnRTY2FsZTogMC41LFxuICAgICAgICBtYXhTY2FsZTogSW5maW5pdHksXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuXG4gICAgdGhpcy5ib3R0b20gPSB7XG4gICAgICAgIGFuY2hvcjogbmV3IFBvaW50KG0sIG0pLFxuICAgICAgICBib3g6IHsgeDE6IC1lZGdlLCB5MTogMCwgeDI6IGVkZ2UsIHkyOiBlZGdlIH0sXG4gICAgICAgIHBsYWNlbWVudFJhbmdlOiBmdWxsUmFuZ2UsXG4gICAgICAgIHBsYWNlbWVudFNjYWxlOiAwLjUsXG4gICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH07XG5cbiAgICB0aGlzLnJpZ2h0ID0ge1xuICAgICAgICBhbmNob3I6IG5ldyBQb2ludChtLCBtKSxcbiAgICAgICAgYm94OiB7IHgxOiAwLCB5MTogLWVkZ2UsIHgyOiBlZGdlLCB5MjogZWRnZSB9LFxuICAgICAgICBwbGFjZW1lbnRSYW5nZTogZnVsbFJhbmdlLFxuICAgICAgICBwbGFjZW1lbnRTY2FsZTogMC41LFxuICAgICAgICBtYXhTY2FsZTogSW5maW5pdHksXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuXG59XG5cbkNvbGxpc2lvbi5wcm90b3R5cGUuZ2V0UGxhY2VtZW50U2NhbGUgPSBmdW5jdGlvbihnbHlwaHMsIG1pblBsYWNlbWVudFNjYWxlLCBhdm9pZEVkZ2VzKSB7XG5cbiAgICB2YXIgbGVmdCA9IHRoaXMubGVmdDtcbiAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0O1xuICAgIHZhciB0b3AgPSB0aGlzLnRvcDtcbiAgICB2YXIgYm90dG9tID0gdGhpcy5ib3R0b207XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGdseXBocy5sZW5ndGg7IGsrKykge1xuXG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1trXTtcbiAgICAgICAgdmFyIGJveCA9IGdseXBoLmJveDtcbiAgICAgICAgdmFyIGJib3ggPSBnbHlwaC5oQm94IHx8IGJveDtcbiAgICAgICAgdmFyIGFuY2hvciA9IGdseXBoLmFuY2hvcjtcbiAgICAgICAgdmFyIHBhZCA9IGdseXBoLnBhZGRpbmc7XG5cbiAgICAgICAgdmFyIG1pblNjYWxlID0gTWF0aC5tYXgobWluUGxhY2VtZW50U2NhbGUsIGdseXBoLm1pblNjYWxlKTtcbiAgICAgICAgdmFyIG1heFNjYWxlID0gZ2x5cGgubWF4U2NhbGUgfHwgSW5maW5pdHk7XG5cbiAgICAgICAgaWYgKG1pblNjYWxlID49IG1heFNjYWxlKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBzY2FsZWQgYm91bmRpbmcgYm94IG9mIHRoZSB1bnJvdGF0ZWQgZ2x5cGhcbiAgICAgICAgdmFyIHNlYXJjaEJveCA9IHRoaXMuZ2V0Qm94KGFuY2hvciwgYmJveCwgbWluU2NhbGUsIG1heFNjYWxlKTtcblxuICAgICAgICB2YXIgYmxvY2tpbmcgPSB0aGlzLmhUcmVlLnNlYXJjaChzZWFyY2hCb3gpLmNvbmNhdCh0aGlzLmNUcmVlLnNlYXJjaChzZWFyY2hCb3gpKTtcblxuICAgICAgICBpZiAoYXZvaWRFZGdlcykge1xuICAgICAgICAgICAgaWYgKHNlYXJjaEJveFswXSA8IDApIGJsb2NraW5nLnB1c2gobGVmdCk7XG4gICAgICAgICAgICBpZiAoc2VhcmNoQm94WzFdIDwgMCkgYmxvY2tpbmcucHVzaCh0b3ApO1xuICAgICAgICAgICAgaWYgKHNlYXJjaEJveFsyXSA+PSA0MDk2KSBibG9ja2luZy5wdXNoKHJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hCb3hbM10gPj0gNDA5NikgYmxvY2tpbmcucHVzaChib3R0b20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJsb2NraW5nLmxlbmd0aCkge1xuXG4gICAgICAgICAgICB2YXIgbmEgPSBhbmNob3I7IC8vIG5ldyBhbmNob3JcbiAgICAgICAgICAgIHZhciBuYiA9IGJveDsgLy8gbmV3IGJveFxuXG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGJsb2NraW5nLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9hID0gYmxvY2tpbmdbbF0uYW5jaG9yOyAvLyBvbGQgYW5jaG9yXG4gICAgICAgICAgICAgICAgdmFyIG9iID0gYmxvY2tpbmdbbF0uYm94OyAvLyBvbGQgYm94XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhbmNob3JzIGFyZSBpZGVudGljYWwsIHdlJ3JlIGdvaW5nIHRvIHNraXAgdGhlIGxhYmVsLlxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHRoaXMgaXNuJ3QgcmlnaHQgYmVjYXVzZSB0aGVyZSBjYW4gYmUgZ2x5cGhzIHdpdGhcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2FtZSBhbmNob3IgYnV0IGRpZmZlcmluZyBib3ggb2Zmc2V0cy5cbiAgICAgICAgICAgICAgICBpZiAobmEuZXF1YWxzKG9hKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0b2RvOiB1bmhhcmRjb2RlIHRoZSA4ID0gdGlsZUV4dGVudC90aWxlU2l6ZVxuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nID0gTWF0aC5tYXgocGFkLCBibG9ja2luZ1tsXS5wYWRkaW5nKSAqIDg7XG5cbiAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBhbGdvcml0aG06XG4gICAgICAgICAgICAgICAgdmFyIHMxID0gKG9iLngxIC0gbmIueDIgLSBwYWRkaW5nKSAvIChuYS54IC0gb2EueCk7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIGxlZnQgb2Ygb2xkIGJveFxuICAgICAgICAgICAgICAgIHZhciBzMiA9IChvYi54MiAtIG5iLngxICsgcGFkZGluZykgLyAobmEueCAtIG9hLngpOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSByaWdodCBvZiBvbGQgYm94XG4gICAgICAgICAgICAgICAgdmFyIHMzID0gKG9iLnkxIC0gbmIueTIgLSBwYWRkaW5nKSAvIChuYS55IC0gb2EueSk7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIHRvcCBvZiBvbGQgYm94XG4gICAgICAgICAgICAgICAgdmFyIHM0ID0gKG9iLnkyIC0gbmIueTEgKyBwYWRkaW5nKSAvIChuYS55IC0gb2EueSk7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIGJvdHRvbSBvZiBvbGQgYm94XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oczEpIHx8IGlzTmFOKHMyKSkgczEgPSBzMiA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHMzKSB8fCBpc05hTihzNCkpIHMzID0gczQgPSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvbkZyZWVTY2FsZSA9IE1hdGgubWluKE1hdGgubWF4KHMxLCBzMiksIE1hdGgubWF4KHMzLCBzNCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgbGFiZWwncyBtaW4gc2NhbGUgaWYgdGhlIGdseXBoIHdhcyByZXN0cmljdGVkIGJ5IGEgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxpc2lvbkZyZWVTY2FsZSA+IG1pblBsYWNlbWVudFNjYWxlICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA+IG1pblNjYWxlICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA8IG1heFNjYWxlICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA8IGJsb2NraW5nW2xdLm1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblBsYWNlbWVudFNjYWxlID0gY29sbGlzaW9uRnJlZVNjYWxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA+IHRoaXMubWF4UGxhY2VtZW50U2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluUGxhY2VtZW50U2NhbGU7XG59O1xuXG5Db2xsaXNpb24ucHJvdG90eXBlLmdldFBsYWNlbWVudFJhbmdlID0gZnVuY3Rpb24oZ2x5cGhzLCBwbGFjZW1lbnRTY2FsZSwgaG9yaXpvbnRhbCkge1xuXG4gICAgdmFyIHBsYWNlbWVudFJhbmdlID0gWzIqTWF0aC5QSSwgMF07XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGdseXBocy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNba107XG4gICAgICAgIHZhciBiYm94ID0gZ2x5cGguaEJveCB8fCBnbHlwaC5ib3g7XG4gICAgICAgIHZhciBhbmNob3IgPSBnbHlwaC5hbmNob3I7XG5cbiAgICAgICAgdmFyIG1pblBsYWNlZFggPSBhbmNob3IueCArIGJib3gueDEgLyBwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgdmFyIG1pblBsYWNlZFkgPSBhbmNob3IueSArIGJib3gueTEgLyBwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgdmFyIG1heFBsYWNlZFggPSBhbmNob3IueCArIGJib3gueDIgLyBwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgdmFyIG1heFBsYWNlZFkgPSBhbmNob3IueSArIGJib3gueTIgLyBwbGFjZW1lbnRTY2FsZTtcblxuICAgICAgICB2YXIgc2VhcmNoQm94ID0gW21pblBsYWNlZFgsIG1pblBsYWNlZFksIG1heFBsYWNlZFgsIG1heFBsYWNlZFldO1xuXG4gICAgICAgIHZhciBibG9ja2luZyA9IHRoaXMuaFRyZWUuc2VhcmNoKHNlYXJjaEJveCk7XG5cbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGJsb2NraW5nID0gYmxvY2tpbmcuY29uY2F0KHRoaXMuY1RyZWUuc2VhcmNoKHNlYXJjaEJveCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBibG9ja2luZy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIGIgPSBibG9ja2luZ1tsXTtcbiAgICAgICAgICAgIHZhciBiYm94MiA9IGIuaEJveCB8fCBiLmJveDtcblxuICAgICAgICAgICAgdmFyIHgxLCB4MiwgeTEsIHkyLCBpbnRlcnNlY3RYLCBpbnRlcnNlY3RZO1xuXG4gICAgICAgICAgICAvLyBBZGp1c3QgYW5kIGNvbXBhcmUgYmJveGVzIHRvIHNlZSBpZiB0aGUgZ2x5cGhzIG1pZ2h0IGludGVyc2VjdFxuICAgICAgICAgICAgaWYgKHBsYWNlbWVudFNjYWxlID4gYi5wbGFjZW1lbnRTY2FsZSkge1xuICAgICAgICAgICAgICAgIHgxID0gYi5hbmNob3IueCArIGJib3gyLngxIC8gcGxhY2VtZW50U2NhbGU7XG4gICAgICAgICAgICAgICAgeTEgPSBiLmFuY2hvci55ICsgYmJveDIueTEgLyBwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICB4MiA9IGIuYW5jaG9yLnggKyBiYm94Mi54MiAvIHBsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgICAgIHkyID0gYi5hbmNob3IueSArIGJib3gyLnkyIC8gcGxhY2VtZW50U2NhbGU7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0WCA9IHgxIDwgbWF4UGxhY2VkWCAmJiB4MiA+IG1pblBsYWNlZFg7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0WSA9IHkxIDwgbWF4UGxhY2VkWSAmJiB5MiA+IG1pblBsYWNlZFk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHgxID0gYW5jaG9yLnggKyBiYm94LngxIC8gYi5wbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICB5MSA9IGFuY2hvci55ICsgYmJveC55MSAvIGIucGxhY2VtZW50U2NhbGU7XG4gICAgICAgICAgICAgICAgeDIgPSBhbmNob3IueCArIGJib3gueDIgLyBiLnBsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgICAgIHkyID0gYW5jaG9yLnkgKyBiYm94LnkyIC8gYi5wbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RYID0geDEgPCBiWzJdICYmIHgyID4gYlswXTtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RZID0geTEgPCBiWzNdICYmIHkyID4gYlsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhleSBjYW4ndCBpbnRlcnNlY3QsIHNraXAgbW9yZSBleHBlbnNpdmUgcm90YXRpb24gY2FsY3VsYXRpb25cbiAgICAgICAgICAgIGlmICghKGludGVyc2VjdFggJiYgaW50ZXJzZWN0WSkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLm1heChwbGFjZW1lbnRTY2FsZSwgYi5wbGFjZW1lbnRTY2FsZSk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSByb3RhdGlvblJhbmdlLnJvdGF0aW9uUmFuZ2UoZ2x5cGgsIGIsIHNjYWxlKTtcblxuICAgICAgICAgICAgcGxhY2VtZW50UmFuZ2VbMF0gPSBNYXRoLm1pbihwbGFjZW1lbnRSYW5nZVswXSwgcmFuZ2VbMF0pO1xuICAgICAgICAgICAgcGxhY2VtZW50UmFuZ2VbMV0gPSBNYXRoLm1heChwbGFjZW1lbnRSYW5nZVsxXSwgcmFuZ2VbMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlbWVudFJhbmdlO1xuXG59O1xuXG4vLyBJbnNlcnQgZ2x5cGggcGxhY2VtZW50cyBpbnRvIHJ0cmVlLlxuQ29sbGlzaW9uLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihnbHlwaHMsIGFuY2hvciwgcGxhY2VtZW50U2NhbGUsIHBsYWNlbWVudFJhbmdlLCBob3Jpem9udGFsKSB7XG5cbiAgICB2YXIgYWxsQm91bmRzID0gW107XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGdseXBocy5sZW5ndGg7IGsrKykge1xuXG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1trXTtcbiAgICAgICAgdmFyIGJib3ggPSBnbHlwaC5oQm94IHx8IGdseXBoLmJveDtcblxuICAgICAgICB2YXIgbWluU2NhbGUgPSBNYXRoLm1heChwbGFjZW1lbnRTY2FsZSwgZ2x5cGgubWluU2NhbGUpO1xuICAgICAgICB2YXIgbWF4U2NhbGUgPSBnbHlwaC5tYXhTY2FsZSB8fCBJbmZpbml0eTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3goYW5jaG9yLCBiYm94LCBtaW5TY2FsZSwgbWF4U2NhbGUpO1xuXG4gICAgICAgIGJvdW5kcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICAgIGJvdW5kcy5ib3ggPSBnbHlwaC5ib3g7XG4gICAgICAgIGlmIChnbHlwaC5oQm94KSBib3VuZHMuaEJveCA9IGJib3g7XG4gICAgICAgIGJvdW5kcy5wbGFjZW1lbnRSYW5nZSA9IHBsYWNlbWVudFJhbmdlO1xuICAgICAgICBib3VuZHMucGxhY2VtZW50U2NhbGUgPSBtaW5TY2FsZTtcbiAgICAgICAgYm91bmRzLm1heFNjYWxlID0gbWF4U2NhbGU7XG4gICAgICAgIGJvdW5kcy5wYWRkaW5nID0gZ2x5cGgucGFkZGluZztcblxuICAgICAgICBhbGxCb3VuZHMucHVzaChib3VuZHMpO1xuICAgIH1cblxuICAgIChob3Jpem9udGFsID8gdGhpcy5oVHJlZSA6IHRoaXMuY1RyZWUpLmxvYWQoYWxsQm91bmRzKTtcbn07XG5cbkNvbGxpc2lvbi5wcm90b3R5cGUuZ2V0Qm94ID0gZnVuY3Rpb24oYW5jaG9yLCBiYm94LCBtaW5TY2FsZSwgbWF4U2NhbGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBhbmNob3IueCArIE1hdGgubWluKGJib3gueDEgLyBtaW5TY2FsZSwgYmJveC54MSAvIG1heFNjYWxlKSxcbiAgICAgICAgYW5jaG9yLnkgKyBNYXRoLm1pbihiYm94LnkxIC8gbWluU2NhbGUsIGJib3gueTEgLyBtYXhTY2FsZSksXG4gICAgICAgIGFuY2hvci54ICsgTWF0aC5tYXgoYmJveC54MiAvIG1pblNjYWxlLCBiYm94LngyIC8gbWF4U2NhbGUpLFxuICAgICAgICBhbmNob3IueSArIE1hdGgubWF4KGJib3gueTIgLyBtaW5TY2FsZSwgYmJveC55MiAvIG1heFNjYWxlKV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmluUGFjayA9IHJlcXVpcmUoJy4vYmlucGFjay5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBoQXRsYXM7XG5mdW5jdGlvbiBHbHlwaEF0bGFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmJpbiA9IG5ldyBCaW5QYWNrKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuaW5kZXggPSB7fTtcbiAgICB0aGlzLmlkcyA9IHt9O1xuICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbn1cblxuR2x5cGhBdGxhcy5wcm90b3R5cGUgPSB7XG4gICAgZ2V0IGRlYnVnKCkge1xuICAgICAgICByZXR1cm4gJ2NhbnZhcycgaW4gdGhpcztcbiAgICB9LFxuICAgIHNldCBkZWJ1Zyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY3R4O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FudmFzO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuZ2V0R2x5cGhzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdseXBocyA9IHt9LFxuICAgICAgICBzcGxpdCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaWQ7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcbiAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcbiAgICAgICAgbmFtZSA9IHNwbGl0WzBdO1xuICAgICAgICBpZCA9IHNwbGl0WzFdO1xuXG4gICAgICAgIGlmICghZ2x5cGhzW25hbWVdKSBnbHlwaHNbbmFtZV0gPSBbXTtcbiAgICAgICAgZ2x5cGhzW25hbWVdLnB1c2goaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5nZXRSZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWN0cyA9IHt9LFxuICAgICAgICBzcGxpdCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaWQ7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcbiAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcbiAgICAgICAgbmFtZSA9IHNwbGl0WzBdO1xuICAgICAgICBpZCA9IHNwbGl0WzFdO1xuXG4gICAgICAgIGlmICghcmVjdHNbbmFtZV0pIHJlY3RzW25hbWVdID0ge307XG4gICAgICAgIHJlY3RzW25hbWVdW2lkXSA9IHRoaXMuaW5kZXhba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdHM7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5yZW1vdmVHbHlwaHMgPSBmdW5jdGlvbihpZCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmlkcykge1xuXG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmlkc1trZXldO1xuXG4gICAgICAgIHZhciBwb3MgPSBpZHMuaW5kZXhPZihpZCk7XG4gICAgICAgIGlmIChwb3MgPj0gMCkgaWRzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICB0aGlzLmlkc1trZXldID0gaWRzO1xuXG4gICAgICAgIGlmICghaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmluZGV4W2tleV07XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHJlY3QuaDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkxID0gdGhpcy53aWR0aCAqIChyZWN0LnkgKyB5KSArIHJlY3QueDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHJlY3QudzsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFt5MSArIHhdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmJpbi5yZWxlYXNlKHJlY3QpO1xuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbmRleFtrZXldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaWRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHRoaXMudXBkYXRlVGV4dHVyZSh0aGlzLmdsKTtcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmFkZEdseXBoID0gZnVuY3Rpb24oaWQsIG5hbWUsIGdseXBoLCBidWZmZXIpIHtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignbWlzc2luZyBnbHlwaCcsIGNvZGUsIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGtleSA9IG5hbWUgKyBcIiNcIiArIGdseXBoLmlkO1xuXG4gICAgLy8gVGhlIGdseXBoIGlzIGFscmVhZHkgaW4gdGhpcyB0ZXh0dXJlLlxuICAgIGlmICh0aGlzLmluZGV4W2tleV0pIHtcbiAgICAgICAgaWYgKHRoaXMuaWRzW2tleV0uaW5kZXhPZihpZCkgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmlkc1trZXldLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4W2tleV07XG4gICAgfVxuXG4gICAgLy8gVGhlIGdseXBoIGJpdG1hcCBoYXMgemVybyB3aWR0aC5cbiAgICBpZiAoIWdseXBoLmJpdG1hcCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyZWRfd2lkdGggPSBnbHlwaC53aWR0aCArIGJ1ZmZlciAqIDI7XG4gICAgdmFyIGJ1ZmZlcmVkX2hlaWdodCA9IGdseXBoLmhlaWdodCArIGJ1ZmZlciAqIDI7XG5cbiAgICAvLyBBZGQgYSAxcHggYm9yZGVyIGFyb3VuZCBldmVyeSBpbWFnZS5cbiAgICB2YXIgcGFja193aWR0aCA9IGJ1ZmZlcmVkX3dpZHRoO1xuICAgIHZhciBwYWNrX2hlaWdodCA9IGJ1ZmZlcmVkX2hlaWdodDtcblxuICAgIC8vIEluY3JlYXNlIHRvIG5leHQgbnVtYmVyIGRpdmlzaWJsZSBieSA0LCBidXQgYXQgbGVhc3QgMS5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiBzY2FsZSBkb3duIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBwYWNrIHRoZW1cbiAgICAvLyBpbnRvIDIgYnl0ZXMgcmF0aGVyIHRoYW4gNCBieXRlcy5cbiAgICBwYWNrX3dpZHRoICs9ICg0IC0gcGFja193aWR0aCAlIDQpO1xuICAgIHBhY2tfaGVpZ2h0ICs9ICg0IC0gcGFja19oZWlnaHQgJSA0KTtcblxuICAgIHZhciByZWN0ID0gdGhpcy5iaW4uYWxsb2NhdGUocGFja193aWR0aCwgcGFja19oZWlnaHQpO1xuICAgIGlmIChyZWN0LnggPCAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZ2x5cGggYml0bWFwIG92ZXJmbG93Jyk7XG4gICAgICAgIHJldHVybiB7IGdseXBoOiBnbHlwaCwgcmVjdDogbnVsbCB9O1xuICAgIH1cblxuICAgIC8vIEFkZCBsZWZ0IGFuZCB0b3AgZ2x5cGggb2Zmc2V0cyB0byByZWN0LlxuICAgIHJlY3QubCA9IGdseXBoLmxlZnQ7XG4gICAgcmVjdC50ID0gZ2x5cGgudG9wO1xuXG4gICAgdGhpcy5pbmRleFtrZXldID0gcmVjdDtcbiAgICB0aGlzLmlkc1trZXldID0gW2lkXTtcblxuICAgIHZhciB0YXJnZXQgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHNvdXJjZSA9IGdseXBoLmJpdG1hcDtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGJ1ZmZlcmVkX2hlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciB5MSA9IHRoaXMud2lkdGggKiAocmVjdC55ICsgeSkgKyByZWN0Lng7XG4gICAgICAgIHZhciB5MiA9IGJ1ZmZlcmVkX3dpZHRoICogeTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBidWZmZXJlZF93aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICB0YXJnZXRbeTEgKyB4XSA9IHNvdXJjZVt5MiArIHhdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLkFMUEhBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLmJpbmQoZ2wpO1xuICAgIGlmICh0aGlzLmRpcnR5KSB7XG5cbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG5cbiAgICAgICAgLy8gREVCVUdcbiAgICAgICAgaWYgKHRoaXMuY3R4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyssIGogKz0gNCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaisxXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaisyXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaiszXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3R4LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcblxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5iaW4uZnJlZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmVlID0gdGhpcy5iaW4uZnJlZVtrXTtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KGZyZWUueCwgZnJlZS55LCBmcmVlLncsIGZyZWUuaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRU5EIERFQlVHXG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveC5qcycpLm5vcm1hbGl6ZUdseXBoc1VSTDtcbnZhciBnZXRBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheC5qcycpLmdldEFycmF5QnVmZmVyO1xudmFyIEdseXBocyA9IHJlcXVpcmUoJy4uL3V0aWwvZ2x5cGhzLmpzJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFNvdXJjZTtcblxuZnVuY3Rpb24gR2x5cGhTb3VyY2UodXJsLCBnbHlwaEF0bGFzKSB7XG4gICAgdGhpcy51cmwgPSB1cmwgJiYgbm9ybWFsaXplVVJMKHVybCk7XG4gICAgdGhpcy5nbHlwaEF0bGFzID0gZ2x5cGhBdGxhcztcbiAgICB0aGlzLnN0YWNrcyA9IHt9O1xuICAgIHRoaXMubG9hZGluZyA9IHt9O1xufVxuXG5HbHlwaFNvdXJjZS5wcm90b3R5cGUuZ2V0UmVjdHMgPSBmdW5jdGlvbihmb250c3RhY2ssIGdseXBoSURzLCB0aWxlSUQsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAodGhpcy5zdGFja3NbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB0aGlzLnN0YWNrc1tmb250c3RhY2tdID0ge307XG5cbiAgICB2YXIgcmVjdHMgPSB7fTtcbiAgICB2YXIgZ2x5cGhzID0ge307XG4gICAgdmFyIHJlc3VsdCA9IHsgcmVjdHM6IHJlY3RzLCBnbHlwaHM6IGdseXBocyB9O1xuXG4gICAgdmFyIHN0YWNrID0gdGhpcy5zdGFja3NbZm9udHN0YWNrXTtcbiAgICB2YXIgZ2x5cGhBdGxhcyA9IHRoaXMuZ2x5cGhBdGxhcztcblxuICAgIHZhciBtaXNzaW5nID0ge307XG4gICAgdmFyIHJlbWFpbmluZyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBnbHlwaElEID0gZ2x5cGhJRHNbaV07XG4gICAgICAgIHZhciByYW5nZSA9IE1hdGguZmxvb3IoZ2x5cGhJRCAvIDI1Nik7XG5cbiAgICAgICAgaWYgKHN0YWNrW3JhbmdlXSkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2tbcmFuZ2VdLmdseXBoc1tnbHlwaElEXTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSAzO1xuICAgICAgICAgICAgcmVjdHNbZ2x5cGhJRF0gPSBnbHlwaEF0bGFzLmFkZEdseXBoKHRpbGVJRCwgZm9udHN0YWNrLCBnbHlwaCwgYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChnbHlwaCkgZ2x5cGhzW2dseXBoSURdID0gc2ltcGxlR2x5cGgoZ2x5cGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1pc3NpbmdbcmFuZ2VdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nW3JhbmdlXSA9IFtdO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlzc2luZ1tyYW5nZV0ucHVzaChnbHlwaElEKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVtYWluaW5nKSBjYWxsYmFjayh1bmRlZmluZWQsIHJlc3VsdCk7XG5cbiAgICB2YXIgZ2x5cGhTb3VyY2UgPSB0aGlzO1xuICAgIGZvciAodmFyIHIgaW4gbWlzc2luZykge1xuICAgICAgICB0aGlzLmxvYWRSYW5nZShmb250c3RhY2ssIHIsIG9uUmFuZ2VMb2FkZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmFuZ2VMb2FkZWQoZXJyLCByYW5nZSwgZGF0YSkge1xuICAgICAgICAvLyBUT0RPIG5vdCBiZSBzaWxlbnQgYWJvdXQgZXJyb3JzXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBnbHlwaFNvdXJjZS5zdGFja3NbZm9udHN0YWNrXVtyYW5nZV0gPSBkYXRhLnN0YWNrc1tmb250c3RhY2tdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXNzaW5nW3JhbmdlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaElEID0gbWlzc2luZ1tyYW5nZV1baV07XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2suZ2x5cGhzW2dseXBoSURdO1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSAzO1xuICAgICAgICAgICAgICAgIHJlY3RzW2dseXBoSURdID0gZ2x5cGhBdGxhcy5hZGRHbHlwaCh0aWxlSUQsIGZvbnRzdGFjaywgZ2x5cGgsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoKSBnbHlwaHNbZ2x5cGhJRF0gPSBzaW1wbGVHbHlwaChnbHlwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nLS07XG4gICAgICAgIGlmICghcmVtYWluaW5nKSBjYWxsYmFjayh1bmRlZmluZWQsIHJlc3VsdCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc2ltcGxlR2x5cGgoZ2x5cGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZHZhbmNlOiBnbHlwaC5hZHZhbmNlLFxuICAgICAgICBsZWZ0OiBnbHlwaC5sZWZ0LFxuICAgICAgICB0b3A6IGdseXBoLnRvcFxuICAgIH07XG59XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5sb2FkUmFuZ2UgPSBmdW5jdGlvbihmb250c3RhY2ssIHJhbmdlLCBjYWxsYmFjaykge1xuXG4gICAgaWYgKHJhbmdlICogMjU2ID49IDY1MjgwKSByZXR1cm4gY2FsbGJhY2soJ2d5cGhzID4gNjUyODAgbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgaWYgKHRoaXMubG9hZGluZ1tmb250c3RhY2tdID09PSB1bmRlZmluZWQpIHRoaXMubG9hZGluZ1tmb250c3RhY2tdID0ge307XG4gICAgdmFyIGxvYWRpbmcgPSB0aGlzLmxvYWRpbmdbZm9udHN0YWNrXTtcblxuICAgIGlmIChsb2FkaW5nW3JhbmdlXSkge1xuICAgICAgICBsb2FkaW5nW3JhbmdlXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkaW5nW3JhbmdlXSA9IFtjYWxsYmFja107XG5cbiAgICAgICAgdmFyIHJhbmdlTmFtZSA9IChyYW5nZSAqIDI1NikgKyAnLScgKyAocmFuZ2UgKiAyNTYgKyAyNTUpO1xuICAgICAgICB2YXIgdXJsID0gZ2x5cGhVcmwoZm9udHN0YWNrLCByYW5nZU5hbWUsIHRoaXMudXJsKTtcblxuICAgICAgICBnZXRBcnJheUJ1ZmZlcih1cmwsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGdseXBocyA9ICFlcnIgJiYgbmV3IEdseXBocyhuZXcgUHJvdG9idWYobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9hZGluZ1tyYW5nZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nW3JhbmdlXVtpXShlcnIsIHJhbmdlLCBnbHlwaHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGxvYWRpbmdbcmFuZ2VdO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnbHlwaFVybChmb250c3RhY2ssIHJhbmdlLCB1cmwsIHN1YmRvbWFpbnMpIHtcbiAgICBzdWJkb21haW5zID0gc3ViZG9tYWlucyB8fCAnYWJjJztcblxuICAgIHJldHVybiB1cmxcbiAgICAgICAgLnJlcGxhY2UoJ3tzfScsIHN1YmRvbWFpbnNbZm9udHN0YWNrLmxlbmd0aCAlIHN1YmRvbWFpbnMubGVuZ3RoXSlcbiAgICAgICAgLnJlcGxhY2UoJ3tmb250c3RhY2t9JywgZm9udHN0YWNrKVxuICAgICAgICAucmVwbGFjZSgne3JhbmdlfScsIHJhbmdlKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcbiAgICBBbmNob3IgPSByZXF1aXJlKCcuLi9zeW1ib2wvYW5jaG9yLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJwb2xhdGU7XG5cbnZhciBtaW5TY2FsZSA9IDAuNTtcbnZhciBtaW5TY2FsZUFycmF5cyA9IHtcbiAgICAxOiBbbWluU2NhbGVdLFxuICAgIDI6IFttaW5TY2FsZSwgMl0sXG4gICAgNDogW21pblNjYWxlLCA0LCAyLCA0XSxcbiAgICA4OiBbbWluU2NhbGUsIDgsIDQsIDgsIDIsIDgsIDQsIDhdXG59O1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHZlcnRpY2VzLCBzcGFjaW5nLCBtaW5TY2FsZSwgbWF4U2NhbGUsIHRpbGVQaXhlbFJhdGlvLCBzdGFydCkge1xuXG4gICAgaWYgKG1pblNjYWxlID09PSB1bmRlZmluZWQpIG1pblNjYWxlID0gMDtcblxuICAgIG1heFNjYWxlID0gTWF0aC5yb3VuZChNYXRoLm1heChNYXRoLm1pbig4LCBtYXhTY2FsZSAvIDIpLCAxKSk7XG4gICAgc3BhY2luZyAqPSB0aWxlUGl4ZWxSYXRpbyAvIG1heFNjYWxlO1xuICAgIHZhciBtaW5TY2FsZXMgPSBtaW5TY2FsZUFycmF5c1ttYXhTY2FsZV07XG4gICAgdmFyIGxlbiA9IG1pblNjYWxlcy5sZW5ndGg7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSAwLFxuICAgICAgICBtYXJrZWREaXN0YW5jZSA9IDAsXG4gICAgICAgIGFkZGVkID0gc3RhcnQgfHwgMDtcblxuICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGEgPSB2ZXJ0aWNlc1tpXSxcbiAgICAgICAgICAgIGIgPSB2ZXJ0aWNlc1tpICsgMV07XG5cbiAgICAgICAgdmFyIHNlZ21lbnREaXN0ID0gYS5kaXN0KGIpLFxuICAgICAgICAgICAgYW5nbGUgPSBiLmFuZ2xlVG8oYSk7XG5cbiAgICAgICAgd2hpbGUgKG1hcmtlZERpc3RhbmNlICsgc3BhY2luZyA8IGRpc3RhbmNlICsgc2VnbWVudERpc3QpIHtcbiAgICAgICAgICAgIG1hcmtlZERpc3RhbmNlICs9IHNwYWNpbmc7XG5cbiAgICAgICAgICAgIHZhciB0ID0gKG1hcmtlZERpc3RhbmNlIC0gZGlzdGFuY2UpIC8gc2VnbWVudERpc3QsXG4gICAgICAgICAgICAgICAgeCA9IHV0aWwuaW50ZXJwKGEueCwgYi54LCB0KSxcbiAgICAgICAgICAgICAgICB5ID0gdXRpbC5pbnRlcnAoYS55LCBiLnksIHQpLFxuICAgICAgICAgICAgICAgIHMgPSBtaW5TY2FsZXNbYWRkZWQgJSBsZW5dO1xuXG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPCA0MDk2ICYmIHkgPj0gMCAmJiB5IDwgNDA5Nikge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBBbmNob3IoeCwgeSwgYW5nbGUsIHMsIGkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlICs9IHNlZ21lbnREaXN0O1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldEljb246IGdldEljb24sXG4gICAgZ2V0R2x5cGhzOiBnZXRHbHlwaHNcbn07XG5cbnZhciBtaW5TY2FsZSA9IDAuNTsgLy8gdW5kZXJzY2FsZSBieSAxIHpvb20gbGV2ZWxcblxuZnVuY3Rpb24gZ2V0SWNvbihhbmNob3IsIGltYWdlLCBib3hTY2FsZSwgbGluZSwgcHJvcHMpIHtcblxuICAgIHZhciB4ID0gaW1hZ2Uud2lkdGggLyAyIC8gaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgeSA9IGltYWdlLmhlaWdodCAvIDIgLyBpbWFnZS5waXhlbFJhdGlvO1xuXG4gICAgdmFyIGR4ID0gcHJvcHNbJ2ljb24tb2Zmc2V0J11bMF07XG4gICAgdmFyIGR5ID0gcHJvcHNbJ2ljb24tb2Zmc2V0J11bMV07XG4gICAgdmFyIHgxID0gKGR4IC0geCk7XG4gICAgdmFyIHgyID0gKGR4ICsgeCk7XG4gICAgdmFyIHkxID0gKGR5IC0geSk7XG4gICAgdmFyIHkyID0gKGR5ICsgeSk7XG5cbiAgICB2YXIgdGwgPSBuZXcgUG9pbnQoeDEsIHkxKTtcbiAgICB2YXIgdHIgPSBuZXcgUG9pbnQoeDIsIHkxKTtcbiAgICB2YXIgYnIgPSBuZXcgUG9pbnQoeDIsIHkyKTtcbiAgICB2YXIgYmwgPSBuZXcgUG9pbnQoeDEsIHkyKTtcblxuICAgIHZhciBhbmdsZSA9IHByb3BzWydpY29uLXJvdGF0ZSddICogTWF0aC5QSSAvIDE4MDtcbiAgICBpZiAoYW5jaG9yLnNlZ21lbnQgIT09IHVuZGVmaW5lZCAmJiBwcm9wc1snaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSAhPT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgICB2YXIgbmV4dCA9IGxpbmVbYW5jaG9yLnNlZ21lbnRdO1xuICAgICAgICBhbmdsZSArPSAtTWF0aC5hdGFuMihuZXh0LnggLSBhbmNob3IueCwgbmV4dC55IC0gYW5jaG9yLnkpICsgTWF0aC5QSSAvIDI7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBtYXRyaXggPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICBibCA9IGJsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XG5cbiAgICAgICAgeDEgPSBNYXRoLm1pbih0bC54LCB0ci54LCBibC54LCBici54KTtcbiAgICAgICAgeDIgPSBNYXRoLm1heCh0bC54LCB0ci54LCBibC54LCBici54KTtcbiAgICAgICAgeTEgPSBNYXRoLm1pbih0bC55LCB0ci55LCBibC55LCBici55KTtcbiAgICAgICAgeTIgPSBNYXRoLm1heCh0bC55LCB0ci55LCBibC55LCBici55KTtcbiAgICB9XG4gICAgdmFyIGJveCA9IHtcbiAgICAgICAgeDE6IHgxICogYm94U2NhbGUsXG4gICAgICAgIHgyOiB4MiAqIGJveFNjYWxlLFxuICAgICAgICB5MTogeTEgKiBib3hTY2FsZSxcbiAgICAgICAgeTI6IHkyICogYm94U2NhbGVcbiAgICB9O1xuXG4gICAgdmFyIGljb25Cb3ggPSB7XG4gICAgICAgIGJveDogYm94LFxuICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgICAgbWluU2NhbGU6IG1pblNjYWxlLFxuICAgICAgICBtYXhTY2FsZTogSW5maW5pdHksXG4gICAgICAgIHBhZGRpbmc6IHByb3BzWydpY29uLXBhZGRpbmcnXVxuICAgIH07XG5cbiAgICB2YXIgaWNvbiA9IHtcbiAgICAgICAgdGw6IHRsLFxuICAgICAgICB0cjogdHIsXG4gICAgICAgIGJyOiBicixcbiAgICAgICAgYmw6IGJsLFxuICAgICAgICB0ZXg6IGltYWdlLFxuICAgICAgICBhbmdsZTogMCxcbiAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgIG1pblNjYWxlOiBtaW5TY2FsZSxcbiAgICAgICAgbWF4U2NhbGU6IEluZmluaXR5XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNoYXBlczogW2ljb25dLFxuICAgICAgICBib3hlczogW2ljb25Cb3hdLFxuICAgICAgICBtaW5TY2FsZTogYW5jaG9yLnNjYWxlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0R2x5cGhzKGFuY2hvciwgb3JpZ2luLCBzaGFwaW5nLCBmYWNlcywgYm94U2NhbGUsIGhvcml6b250YWwsIGxpbmUsIHByb3BzKSB7XG5cbiAgICB2YXIgbWF4QW5nbGVEZWx0YSA9IHByb3BzWyd0ZXh0LW1heC1hbmdsZSddICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgcm90YXRlID0gcHJvcHNbJ3RleHQtcm90YXRlJ10gKiBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBwYWRkaW5nID0gcHJvcHNbJ3RleHQtcGFkZGluZyddO1xuICAgIHZhciBhbG9uZ0xpbmUgPSBwcm9wc1sndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSAhPT0gJ3ZpZXdwb3J0JztcbiAgICB2YXIga2VlcFVwcmlnaHQgPSBwcm9wc1sndGV4dC1rZWVwLXVwcmlnaHQnXTtcblxuICAgIHZhciBnbHlwaHMgPSBbXSxcbiAgICAgICAgYm94ZXMgPSBbXTtcblxuICAgIHZhciBidWZmZXIgPSAzO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaGFwaW5nLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBpbmdba107XG4gICAgICAgIHZhciBmb250c3RhY2sgPSBmYWNlc1tzaGFwZS5mb250c3RhY2tdO1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250c3RhY2suZ2x5cGhzW3NoYXBlLmdseXBoXTtcbiAgICAgICAgdmFyIHJlY3QgPSBmb250c3RhY2sucmVjdHNbc2hhcGUuZ2x5cGhdO1xuXG4gICAgICAgIGlmICghZ2x5cGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICghKHJlY3QgJiYgcmVjdC53ID4gMCAmJiByZWN0LmggPiAwKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIHggPSAob3JpZ2luLnggKyBzaGFwZS54ICsgZ2x5cGgubGVmdCAtIGJ1ZmZlciArIHJlY3QudyAvIDIpICogYm94U2NhbGU7XG5cbiAgICAgICAgdmFyIGdseXBoSW5zdGFuY2VzO1xuICAgICAgICBpZiAoYW5jaG9yLnNlZ21lbnQgIT09IHVuZGVmaW5lZCAmJiBhbG9uZ0xpbmUpIHtcbiAgICAgICAgICAgIGdseXBoSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIHgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCAxLCBtYXhBbmdsZURlbHRhKTtcbiAgICAgICAgICAgIGlmIChrZWVwVXByaWdodCkgZ2V0U2VnbWVudEdseXBocyhnbHlwaEluc3RhbmNlcywgYW5jaG9yLCB4LCBsaW5lLCBhbmNob3Iuc2VnbWVudCwgLTEsIG1heEFuZ2xlRGVsdGEpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaEluc3RhbmNlcyA9IFt7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtaW5TY2FsZTogbWluU2NhbGVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgxID0gb3JpZ2luLnggKyBzaGFwZS54ICsgZ2x5cGgubGVmdCAtIGJ1ZmZlcixcbiAgICAgICAgICAgIHkxID0gb3JpZ2luLnkgKyBzaGFwZS55IC0gZ2x5cGgudG9wIC0gYnVmZmVyLFxuICAgICAgICAgICAgeDIgPSB4MSArIHJlY3QudyxcbiAgICAgICAgICAgIHkyID0geTEgKyByZWN0LmgsXG5cbiAgICAgICAgICAgIG90bCA9IG5ldyBQb2ludCh4MSwgeTEpLFxuICAgICAgICAgICAgb3RyID0gbmV3IFBvaW50KHgyLCB5MSksXG4gICAgICAgICAgICBvYmwgPSBuZXcgUG9pbnQoeDEsIHkyKSxcbiAgICAgICAgICAgIG9iciA9IG5ldyBQb2ludCh4MiwgeTIpO1xuXG4gICAgICAgIHZhciBvYm94ID0ge1xuICAgICAgICAgICAgICAgIHgxOiBib3hTY2FsZSAqIHgxLFxuICAgICAgICAgICAgICAgIHkxOiBib3hTY2FsZSAqIHkxLFxuICAgICAgICAgICAgICAgIHgyOiBib3hTY2FsZSAqIHgyLFxuICAgICAgICAgICAgICAgIHkyOiBib3hTY2FsZSAqIHkyXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZ2x5cGhJbnN0YW5jZXNbaV0sXG5cbiAgICAgICAgICAgICAgICB0bCA9IG90bCxcbiAgICAgICAgICAgICAgICB0ciA9IG90cixcbiAgICAgICAgICAgICAgICBibCA9IG9ibCxcbiAgICAgICAgICAgICAgICBiciA9IG9icixcbiAgICAgICAgICAgICAgICBib3ggPSBvYm94LFxuXG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgdG8gLTkwLys5MCBkZWdyZWVzXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBpbnN0YW5jZS5hbmdsZSArIHJvdGF0ZTtcblxuICAgICAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuXG4gICAgICAgICAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdHIgPSB0ci5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYmwgPSBibC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbGFiZWwgZnJvbSBleHRlbmRpbmcgcGFzdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICB2YXIgZ2x5cGhNaW5TY2FsZSA9IE1hdGgubWF4KGluc3RhbmNlLm1pblNjYWxlLCBhbmNob3Iuc2NhbGUpO1xuXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgZ2x5cGggZm9yIGxhdGVyIGluc2VydGlvbi5cbiAgICAgICAgICAgIGdseXBocy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0bDogdGwsXG4gICAgICAgICAgICAgICAgdHI6IHRyLFxuICAgICAgICAgICAgICAgIGJsOiBibCxcbiAgICAgICAgICAgICAgICBicjogYnIsXG4gICAgICAgICAgICAgICAgdGV4OiByZWN0LFxuICAgICAgICAgICAgICAgIGFuZ2xlOiAoYW5jaG9yLmFuZ2xlICsgcm90YXRlICsgaW5zdGFuY2Uub2Zmc2V0ICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSxcbiAgICAgICAgICAgICAgICBhbmNob3I6IGluc3RhbmNlLmFuY2hvcixcbiAgICAgICAgICAgICAgICBtaW5TY2FsZTogZ2x5cGhNaW5TY2FsZSxcbiAgICAgICAgICAgICAgICBtYXhTY2FsZTogaW5zdGFuY2UubWF4U2NhbGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLm9mZnNldCkgeyAvLyBub3QgYSBmbGlwcGVkIGdseXBoXG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcm90YXRlZCBnbHlwaCdzIGJvdW5kaW5nIGJveCBvZmZzZXRzIGZyb20gdGhlIGFuY2hvciBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgYm94ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IGJveFNjYWxlICogTWF0aC5taW4odGwueCwgdHIueCwgYmwueCwgYnIueCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5MTogYm94U2NhbGUgKiBNYXRoLm1pbih0bC55LCB0ci55LCBibC55LCBici55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBib3hTY2FsZSAqIE1hdGgubWF4KHRsLngsIHRyLngsIGJsLngsIGJyLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IGJveFNjYWxlICogTWF0aC5tYXgodGwueSwgdHIueSwgYmwueSwgYnIueSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm94ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGJveDogYm94LFxuICAgICAgICAgICAgICAgICAgICBhbmNob3I6IGluc3RhbmNlLmFuY2hvcixcbiAgICAgICAgICAgICAgICAgICAgbWluU2NhbGU6IGdseXBoTWluU2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIG1heFNjYWxlOiBpbnN0YW5jZS5tYXhTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyBhdm9pZCBjcmVhdGluZyB0aGUgYm94ZXMgaW4gdGhlIGZpcnN0IHBsYWNlP1xuICAgIGlmIChob3Jpem9udGFsKSBib3hlcyA9IFtnZXRNZXJnZWRCb3hlcyhib3hlcywgYW5jaG9yKV07XG5cbiAgICB2YXIgbWluUGxhY2VtZW50U2NhbGUgPSBhbmNob3Iuc2NhbGU7XG4gICAgdmFyIG1pbkdseXBoU2NhbGUgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IGJveGVzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIG1pbkdseXBoU2NhbGUgPSBNYXRoLm1pbihtaW5HbHlwaFNjYWxlLCBib3hlc1ttXS5taW5TY2FsZSk7XG4gICAgfVxuICAgIG1pbkdseXBoU2NhbGUgPSBNYXRoLm1heChtaW5QbGFjZW1lbnRTY2FsZSwgbWluU2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm94ZXM6IGJveGVzLFxuICAgICAgICBzaGFwZXM6IGdseXBocyxcbiAgICAgICAgbWluU2NhbGU6IG1pbkdseXBoU2NhbGVcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTZWdtZW50R2x5cGhzKGdseXBocywgYW5jaG9yLCBvZmZzZXQsIGxpbmUsIHNlZ21lbnQsIGRpcmVjdGlvbiwgbWF4QW5nbGVEZWx0YSkge1xuICAgIHZhciB1cHNpZGVEb3duID0gZGlyZWN0aW9uIDwgMDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSAgZGlyZWN0aW9uICo9IC0xO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA+IDApIHNlZ21lbnQrKztcblxuICAgIHZhciBuZXdBbmNob3IgPSBhbmNob3I7XG4gICAgdmFyIGVuZCA9IGxpbmVbc2VnbWVudF07XG4gICAgdmFyIHByZXZzY2FsZSA9IEluZmluaXR5O1xuICAgIHZhciBwcmV2QW5nbGU7XG5cbiAgICBvZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuXG4gICAgdmFyIHBsYWNlbWVudFNjYWxlID0gYW5jaG9yLnNjYWxlO1xuXG4gICAgc2VnbWVudF9sb29wOlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkaXN0ID0gbmV3QW5jaG9yLmRpc3QoZW5kKTtcbiAgICAgICAgdmFyIHNjYWxlID0gb2Zmc2V0L2Rpc3Q7XG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKGVuZC54IC0gbmV3QW5jaG9yLngsIGVuZC55IC0gbmV3QW5jaG9yLnkpICsgZGlyZWN0aW9uICogTWF0aC5QSSAvIDI7XG4gICAgICAgIGlmICh1cHNpZGVEb3duKSBhbmdsZSArPSBNYXRoLlBJO1xuXG4gICAgICAgIC8vIERvbid0IHBsYWNlIGFyb3VuZCBzaGFycCBjb3JuZXJzXG4gICAgICAgIHZhciBhbmdsZURpZmYgPSAoYW5nbGUgLSBwcmV2QW5nbGUpICUgKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgaWYgKHByZXZBbmdsZSAmJiBNYXRoLmFicyhhbmdsZURpZmYpID4gbWF4QW5nbGVEZWx0YSkge1xuICAgICAgICAgICAgYW5jaG9yLnNjYWxlID0gcHJldnNjYWxlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaHMucHVzaCh7XG4gICAgICAgICAgICBhbmNob3I6IG5ld0FuY2hvcixcbiAgICAgICAgICAgIG9mZnNldDogdXBzaWRlRG93biA/IE1hdGguUEkgOiAwLFxuICAgICAgICAgICAgbWluU2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgbWF4U2NhbGU6IHByZXZzY2FsZSxcbiAgICAgICAgICAgIGFuZ2xlOiAoYW5nbGUgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzY2FsZSA8PSBwbGFjZW1lbnRTY2FsZSkgYnJlYWs7XG5cbiAgICAgICAgbmV3QW5jaG9yID0gZW5kO1xuXG4gICAgICAgIC8vIHNraXAgZHVwbGljYXRlIG5vZGVzXG4gICAgICAgIHdoaWxlIChuZXdBbmNob3IuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgKz0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgZW5kID0gbGluZVtzZWdtZW50XTtcblxuICAgICAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgICAgICBhbmNob3Iuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgICAgICBicmVhayBzZWdtZW50X2xvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdCA9IGVuZC5zdWIobmV3QW5jaG9yKS5fdW5pdCgpO1xuICAgICAgICBuZXdBbmNob3IgPSBuZXdBbmNob3Iuc3ViKHVuaXQuX211bHQoZGlzdCkpO1xuXG4gICAgICAgIHByZXZzY2FsZSA9IHNjYWxlO1xuICAgICAgICBwcmV2QW5nbGUgPSBhbmdsZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlZEJveGVzKGdseXBocywgYW5jaG9yKSB7XG4gICAgICAvLyBDb2xsaXNpb24gY2hlY2tzIGJldHdlZW4gcm90YXRpbmcgYW5kIGZpeGVkIGxhYmVscyBhcmUgcmVsYXRpdmVseSBleHBlbnNpdmUsXG4gICAgICAvLyBzbyB3ZSB1c2Ugb25lIGJveCBwZXIgbGFiZWwsIG5vdCBwZXIgZ2x5cGggZm9yIGhvcml6b250YWwgbGFiZWxzLlxuXG4gICAgdmFyIG1lcmdlZGdseXBocyA9IHtcbiAgICAgICAgYm94OiB7IHgxOiBJbmZpbml0eSwgeTE6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH0sXG4gICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICBtaW5TY2FsZTogMCxcbiAgICAgICAgcGFkZGluZzogLUluZmluaXR5XG4gICAgfTtcblxuICAgIHZhciBib3ggPSBtZXJnZWRnbHlwaHMuYm94O1xuXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBnbHlwaHMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgdmFyIGdib3ggPSBnbHlwaHNbbV0uYm94O1xuICAgICAgICBib3gueDEgPSBNYXRoLm1pbihib3gueDEsIGdib3gueDEpO1xuICAgICAgICBib3gueTEgPSBNYXRoLm1pbihib3gueTEsIGdib3gueTEpO1xuICAgICAgICBib3gueDIgPSBNYXRoLm1heChib3gueDIsIGdib3gueDIpO1xuICAgICAgICBib3gueTIgPSBNYXRoLm1heChib3gueTIsIGdib3gueTIpO1xuICAgICAgICBtZXJnZWRnbHlwaHMubWluU2NhbGUgPSBNYXRoLm1heChtZXJnZWRnbHlwaHMubWluU2NhbGUsIGdseXBoc1ttXS5taW5TY2FsZSk7XG4gICAgICAgIG1lcmdlZGdseXBocy5wYWRkaW5nID0gTWF0aC5tYXgobWVyZ2VkZ2x5cGhzLnBhZGRpbmcsIGdseXBoc1ttXS5wYWRkaW5nKTtcbiAgICB9XG4gICAgLy8gZm9yIGFsbCBob3Jpem9udGFsIGxhYmVscywgY2FsY3VsYXRlIGJib3ggY292ZXJpbmcgYWxsIHJvdGF0ZWQgcG9zaXRpb25zXG4gICAgdmFyIHgxMiA9IGJveC54MSAqIGJveC54MSxcbiAgICAgICAgeTEyID0gYm94LnkxICogYm94LnkxLFxuICAgICAgICB4MjIgPSBib3gueDIgKiBib3gueDIsXG4gICAgICAgIHkyMiA9IGJveC55MiAqIGJveC55MixcbiAgICAgICAgZGlhZyA9IE1hdGguc3FydChNYXRoLm1heCh4MTIgKyB5MTIsIHgxMiArIHkyMiwgeDIyICsgeTEyLCB4MjIgKyB5MjIpKTtcblxuICAgIG1lcmdlZGdseXBocy5oQm94ID0ge1xuICAgICAgICB4MTogLWRpYWcsXG4gICAgICAgIHkxOiAtZGlhZyxcbiAgICAgICAgeDI6IGRpYWcsXG4gICAgICAgIHkyOiBkaWFnXG4gICAgfTtcblxuICAgIHJldHVybiBtZXJnZWRnbHlwaHM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXNvbHZlVG9rZW5zID0gcmVxdWlyZSgnLi4vdXRpbC90b2tlbi5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVUZXh0O1xuXG4vLyBGb3IgYW4gYXJyYXkgb2YgZmVhdHVyZXMgZGV0ZXJtaW5lIHdoYXQgZ2x5cGggcmFuZ2VzIG5lZWQgdG8gYmUgbG9hZGVkXG4vLyBhbmQgYXBwbHkgYW55IHRleHQgcHJlcHJvY2Vzc2luZy4gVGhlIHJlbWFpbmluZyB1c2VycyBvZiB0ZXh0IHNob3VsZFxuLy8gdXNlIHRoZSBgdGV4dEZlYXR1cmVzYCBrZXkgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiBhY2Nlc3Npbmdcbi8vIGZlYXR1cmUgdGV4dCBkaXJlY3RseS5cbmZ1bmN0aW9uIHJlc29sdmVUZXh0KGZlYXR1cmVzLCBpbmZvLCBnbHlwaHMpIHtcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gW107XG4gICAgdmFyIGNvZGVwb2ludHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBmbCA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGZsOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHQgPSByZXNvbHZlVG9rZW5zKGZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGluZm9bJ3RleHQtZmllbGQnXSk7XG4gICAgICAgIHZhciBoYXN0ZXh0ID0gZmFsc2U7XG4gICAgICAgIGlmICghdGV4dCkgY29udGludWU7XG4gICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGluZm9bJ3RleHQtdHJhbnNmb3JtJ107XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gPT09ICd1cHBlcmNhc2UnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybSA9PT0gJ2xvd2VyY2FzZScpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSB0ZXh0Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPD0gNjU1MzMpIHtcbiAgICAgICAgICAgICAgICBjb2RlcG9pbnRzLnB1c2godGV4dC5jaGFyQ29kZUF0KGopKTtcbiAgICAgICAgICAgICAgICBoYXN0ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFjayBpbmRleGVzIG9mIGZlYXR1cmVzIHdpdGggdGV4dC5cbiAgICAgICAgaWYgKGhhc3RleHQpIHtcbiAgICAgICAgICAgIHRleHRGZWF0dXJlc1tpXSA9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBnZXQgYSBsaXN0IG9mIHVuaXF1ZSBjb2RlcG9pbnRzIHdlIGFyZSBtaXNzaW5nXG4gICAgY29kZXBvaW50cyA9IHVuaXEoY29kZXBvaW50cywgZ2x5cGhzKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRleHRGZWF0dXJlczogdGV4dEZlYXR1cmVzLFxuICAgICAgICBjb2RlcG9pbnRzOiBjb2RlcG9pbnRzXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdW5pcShpZHMsIGFscmVhZHlIYXZlKSB7XG4gICAgdmFyIHUgPSBbXTtcbiAgICB2YXIgbGFzdDtcbiAgICBpZHMuc29ydChzb3J0TnVtYmVycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlkc1tpXSAhPT0gbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGlmICghYWxyZWFkeUhhdmVbbGFzdF0pIHUucHVzaChpZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuXG5mdW5jdGlvbiBzb3J0TnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByb3RhdGlvblJhbmdlOiByb3RhdGlvblJhbmdlLFxuICAgIG1lcmdlQ29sbGlzaW9uczogbWVyZ2VDb2xsaXNpb25zLFxuXG4gICAgcm90YXRpbmdGaXhlZENvbGxpc2lvbnM6IHJvdGF0aW5nRml4ZWRDb2xsaXNpb25zLFxuICAgIHJvdGF0aW5nUm90YXRpbmdDb2xsaXNpb25zOiByb3RhdGluZ1JvdGF0aW5nQ29sbGlzaW9ucyxcblxuICAgIGNvcm5lckJveENvbGxpc2lvbnM6IGNvcm5lckJveENvbGxpc2lvbnMsXG4gICAgY2lyY2xlRWRnZUNvbGxpc2lvbnM6IGNpcmNsZUVkZ2VDb2xsaXNpb25zLFxuXG4gICAgZ2V0Q29ybmVyczogZ2V0Q29ybmVycyxcbn07XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIHJhbmdlIGEgYm94IGNvbmZsaWN0cyB3aXRoIGEgc2Vjb25kIGJveFxuICovXG5mdW5jdGlvbiByb3RhdGlvblJhbmdlKGluc2VydGluZywgYmxvY2tlciwgc2NhbGUpIHtcblxuICAgIHZhciBjb2xsaXNpb25zLCBib3g7XG5cbiAgICB2YXIgYSA9IGluc2VydGluZztcbiAgICB2YXIgYiA9IGJsb2NrZXI7XG5cbiAgICAvLyBJbnN0ZWFkIG9mIHNjYWxpbmcgdGhlIGJveGVzLCB3ZSBtb3ZlIHRoZSBhbmNob3JzXG4gICAgdmFyIHJlbGF0aXZlQW5jaG9yID0gbmV3IFBvaW50KFxuICAgICAgICAoYi5hbmNob3IueCAtIGEuYW5jaG9yLngpICogc2NhbGUsXG4gICAgICAgIChiLmFuY2hvci55IC0gYS5hbmNob3IueSkgKiBzY2FsZSk7XG5cbiAgICAvLyBHZW5lcmF0ZSBhIGxpc3Qgb2YgY29sbGlzaW9uIGludGVydmFsXG4gICAgaWYgKGEuaEJveCAmJiBiLmhCb3gpIHtcbiAgICAgICAgY29sbGlzaW9ucyA9IHJvdGF0aW5nUm90YXRpbmdDb2xsaXNpb25zKGEuYm94LCBiLmJveCwgcmVsYXRpdmVBbmNob3IpO1xuXG4gICAgfSBlbHNlIGlmIChhLmhCb3gpIHtcbiAgICAgICAgYm94ID0ge1xuICAgICAgICAgICAgeDE6IGIuYm94LngxICsgcmVsYXRpdmVBbmNob3IueCxcbiAgICAgICAgICAgIHkxOiBiLmJveC55MSArIHJlbGF0aXZlQW5jaG9yLnksXG4gICAgICAgICAgICB4MjogYi5ib3gueDIgKyByZWxhdGl2ZUFuY2hvci54LFxuICAgICAgICAgICAgeTI6IGIuYm94LnkyICsgcmVsYXRpdmVBbmNob3IueVxuICAgICAgICB9O1xuICAgICAgICBjb2xsaXNpb25zID0gcm90YXRpbmdGaXhlZENvbGxpc2lvbnMoYS5ib3gsIGJveCk7XG5cblxuICAgIH0gZWxzZSBpZiAoYi5oQm94KSB7XG4gICAgICAgIGJveCA9IHtcbiAgICAgICAgICAgIHgxOiBhLmJveC54MSAtIHJlbGF0aXZlQW5jaG9yLngsXG4gICAgICAgICAgICB5MTogYS5ib3gueTEgLSByZWxhdGl2ZUFuY2hvci55LFxuICAgICAgICAgICAgeDI6IGEuYm94LngyIC0gcmVsYXRpdmVBbmNob3IueCxcbiAgICAgICAgICAgIHkyOiBhLmJveC55MiAtIHJlbGF0aXZlQW5jaG9yLnlcbiAgICAgICAgfTtcbiAgICAgICAgY29sbGlzaW9ucyA9IHJvdGF0aW5nRml4ZWRDb2xsaXNpb25zKGIuYm94LCBib3gpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29sbGlzaW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8vIEZpbmQgYW5kIHJldHVybiB0aGUgY29udGlub3VzIGFyZSBhcm91bmQgMCB3aGVyZSB0aGVyZSBhcmUgbm8gY29sbGlzaW9uc1xuICAgIHJldHVybiBtZXJnZUNvbGxpc2lvbnMoY29sbGlzaW9ucywgYmxvY2tlci5wbGFjZW1lbnRSYW5nZSk7XG59XG5cbi8qXG4gKiBDb21iaW5lIGFuIGFycmF5IG9mIGNvbGxpc2lvbiByYW5nZXMgdG8gZm9ybSBhIGNvbnRpbnVvdXNcbiAqIHJhbmdlIHRoYXQgaW5jbHVkZXMgMC4gQ29sbGlzaW9ucyB3aXRoaW4gdGhlIGlnbm9yZVJhbmdlIGFyZSBpZ25vcmVkXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29sbGlzaW9ucyhjb2xsaXNpb25zLCBpZ25vcmVSYW5nZSkge1xuXG4gICAgLy8gZmluZCBjb250aW51b3VzIGludGVydmFsIGluY2x1ZGluZyAwIHRoYXQgZG9lc24ndCBoYXZlIGFueSBjb2xsaXNpb25zXG4gICAgdmFyIG1pbiA9IDIgKiBNYXRoLlBJO1xuICAgIHZhciBtYXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsaXNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xuXG4gICAgICAgIHZhciBlbnRyeU91dHNpZGUgPSBpZ25vcmVSYW5nZVswXSA8PSBjb2xsaXNpb25bMF0gJiYgY29sbGlzaW9uWzBdIDw9IGlnbm9yZVJhbmdlWzFdO1xuICAgICAgICB2YXIgZXhpdE91dHNpZGUgPSBpZ25vcmVSYW5nZVswXSA8PSBjb2xsaXNpb25bMV0gJiYgY29sbGlzaW9uWzFdIDw9IGlnbm9yZVJhbmdlWzFdO1xuXG4gICAgICAgIGlmIChlbnRyeU91dHNpZGUgJiYgZXhpdE91dHNpZGUpIHtcbiAgICAgICAgICAgIC8vIG5vIGNvbGxpc2lvbiwgc2luY2UgYmxvY2tlciBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgICAgfSBlbHNlIGlmIChlbnRyeU91dHNpZGUpIHtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgaWdub3JlUmFuZ2VbMV0pO1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBjb2xsaXNpb25bMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGV4aXRPdXRzaWRlKSB7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGNvbGxpc2lvblswXSk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGlnbm9yZVJhbmdlWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgY29sbGlzaW9uWzBdKTtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgY29sbGlzaW9uWzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbWluLCBtYXhdO1xufVxuXG4vKlxuICogIENhbGN1bGF0ZSBjb2xsaXNpb24gcmFuZ2VzIGZvciB0d28gcm90YXRpbmcgYm94ZXMuXG4gKi9cblxudmFyIGhvcml6b250YWwgPSBuZXcgUG9pbnQoMSwgMCk7XG5cbmZ1bmN0aW9uIHJvdGF0aW5nUm90YXRpbmdDb2xsaXNpb25zKGEsIGIsIGFuY2hvclRvQW5jaG9yKSB7XG4gICAgdmFyIGQgPSBhbmNob3JUb0FuY2hvci5tYWcoKTtcblxuICAgIHZhciBhbmdsZUJldHdlZW5BbmNob3JzID0gYW5jaG9yVG9BbmNob3IuYW5nbGVXaXRoKGhvcml6b250YWwpO1xuXG4gICAgdmFyIGMgPSBbXSxcbiAgICAgICAgY29sbGlzaW9ucyA9IFtdLFxuICAgICAgICBrO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGFuZ2xlcyBhdCB3aGljaCBjb2xsaXNpb25zIG1heSBvY2N1clxuICAgIC8vIHRvcC9ib3R0b21cbiAgICBjWzBdID0gTWF0aC5hc2luKChhLnkyIC0gYi55MSkgLyBkKTtcbiAgICBjWzFdID0gTWF0aC5hc2luKChhLnkyIC0gYi55MSkgLyBkKSArIE1hdGguUEk7XG4gICAgY1syXSA9IDIgKiBNYXRoLlBJIC0gTWF0aC5hc2luKCgtYS55MSArIGIueTIpIC8gZCk7XG4gICAgY1szXSA9IE1hdGguUEkgLSBNYXRoLmFzaW4oKC1hLnkxICsgYi55MikgLyBkKTtcblxuICAgIC8vIGxlZnQvcmlnaHRcbiAgICBjWzRdID0gMiAqIE1hdGguUEkgLSBNYXRoLmFjb3MoKGEueDIgLSBiLngxKSAvIGQpO1xuICAgIGNbNV0gPSBNYXRoLmFjb3MoKGEueDIgLSBiLngxKSAvIGQpO1xuICAgIGNbNl0gPSBNYXRoLlBJIC0gTWF0aC5hY29zKCgtYS54MSArIGIueDIpIC8gZCk7XG4gICAgY1s3XSA9IE1hdGguUEkgKyBNYXRoLmFjb3MoKC1hLngxICsgYi54MikgLyBkKTtcblxuICAgIHZhciBybCA9IGEueDIgLSBiLngxO1xuICAgIHZhciBsciA9IC1hLngxICsgYi54MjtcbiAgICB2YXIgdGIgPSBhLnkyIC0gYi55MTtcbiAgICB2YXIgYnQgPSAtYS55MSArIGIueTI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHNxdWFyZWQgb2YgdGhlIGRpYWdvbmFsIHdoaWNoIHdpbGwgYmUgdXNlZFxuICAgIC8vIHRvIGNoZWNrIGlmIHRoZSBib3hlcyBhcmUgY2xvc2UgZW5vdWdoIGZvciBjb2xsaXNpb25zIHRvIG9jY3VyIGF0IGVhY2ggYW5nbGVcbiAgICAvLyB0b2RvLCB0cmlwbGUgY2hlY2sgdGhlc2VcbiAgICB2YXIgZSA9IFtdO1xuICAgIC8vIHRvcC9ib3R0b21cbiAgICBlWzBdID0gcmwgKiBybCArIHRiICogdGI7XG4gICAgZVsxXSA9IGxyICogbHIgKyB0YiAqIHRiO1xuICAgIGVbMl0gPSBybCAqIHJsICsgYnQgKiBidDtcbiAgICBlWzNdID0gbHIgKiBsciArIGJ0ICogYnQ7XG4gICAgLy8gbGVmdC9yaWdodFxuICAgIGVbNF0gPSBybCAqIHJsICsgdGIgKiB0YjtcbiAgICBlWzVdID0gcmwgKiBybCArIGJ0ICogYnQ7XG4gICAgZVs2XSA9IGxyICogbHIgKyBidCAqIGJ0O1xuICAgIGVbN10gPSBsciAqIGxyICsgdGIgKiB0YjtcblxuXG4gICAgYyA9IGMuZmlsdGVyKGZ1bmN0aW9uKHgsIGkpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgY2xvc2UgZW5vdWdoIHRvIGNvbGxpZGVcbiAgICAgICAgcmV0dXJuICFpc05hTih4KSAmJiBkICogZCA8PSBlW2ldO1xuICAgIH0pLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIC8vIFNvIGZhciwgYW5nbGVzIGhhdmUgYmVlbiBjYWx1bGF0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIHZlY3RvciBiZXR3ZWVuIGFuY2hvcnMuXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGFuZ2xlcyB0byBhbmdsZXMgZnJvbSBub3J0aC5cbiAgICAgICAgcmV0dXJuICh4ICsgYW5nbGVCZXR3ZWVuQW5jaG9ycyArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSk7XG4gICAgfSk7XG5cbiAgICAvLyBHcm91cCB0aGUgY29sbGlzaW9uIGFuZ2xlcyBieSB0d29cbiAgICAvLyBlYWNoIGdyb3VwIHJlcHJlc2VudHMgYSByYW5nZSB3aGVyZSB0aGUgdHdvIGJveGVzIGNvbGxpZGVcbiAgICBjLnNvcnQoKTtcbiAgICBmb3IgKGsgPSAwOyBrIDwgYy5sZW5ndGg7IGsrPTIpIHtcbiAgICAgICAgY29sbGlzaW9ucy5wdXNoKFtjW2tdLCBjW2srMV1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGlzaW9ucztcblxufVxuXG4vKlxuICogIENhbGN1bGF0ZSBjb2xsaXNpb24gcmFuZ2VzIGZvciBhIHJvdGF0aW5nIGJveCBhbmQgYSBmaXhlZCBib3g7XG4gKi9cbmZ1bmN0aW9uIHJvdGF0aW5nRml4ZWRDb2xsaXNpb25zKHJvdGF0aW5nLCBmaXhlZCkge1xuXG4gICAgdmFyIGNvcm5lcnNSID0gZ2V0Q29ybmVycyhyb3RhdGluZyk7XG4gICAgdmFyIGNvcm5lcnNGID0gZ2V0Q29ybmVycyhmaXhlZCk7XG5cbiAgICAvLyBBIGNvbGxpc2lvbiBvY2N1cnMgd2hlbiwgYW5kIG9ubHkgYXQgbGVhc3Qgb25lIGNvcm5lciBmcm9tIG9uZSBvZiB0aGUgYm94ZXNcbiAgICAvLyBpcyB3aXRoaW4gdGhlIG90aGVyIGJveC4gQ2FsY3VsYXRlIHRoZXNlIHJhbmdlcyBmb3IgZWFjaCBjb3JuZXIuXG5cbiAgICB2YXIgY29sbGlzaW9ucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKysgKSB7XG4gICAgICAgIGNvcm5lckJveENvbGxpc2lvbnMoY29sbGlzaW9ucywgY29ybmVyc1JbaV0sIGNvcm5lcnNGKTtcbiAgICAgICAgY29ybmVyQm94Q29sbGlzaW9ucyhjb2xsaXNpb25zLCBjb3JuZXJzRltpXSwgY29ybmVyc1IsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsaXNpb25zO1xufVxuXG5cbi8qXG4gKiAgQ2FsY3VsYXRlIHRoZSByYW5nZXMgZm9yIHdoaWNoIHRoZSBjb3JuZXIsXG4gKiAgcm90YXRhdGVkIGFyb3VuZCB0aGUgYW5jaG9yLCBpcyB3aXRoaW4gdGhlIGJveDtcbiAqL1xuZnVuY3Rpb24gY29ybmVyQm94Q29sbGlzaW9ucyhjb2xsaXNpb25zLCBjb3JuZXIsIGJveENvcm5lcnMsIGZsaXApIHtcbiAgICB2YXIgcmFkaXVzID0gY29ybmVyLm1hZygpLFxuICAgICAgICBhbmdsZXMgPSBbXTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGF0IHdoaWNoIHRoZSBjb3JuZXJzIGludGVyc2VjdCB3aXRoIHRoZSBlZGdlc1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMzsgaSA8IDQ7IGogPSBpKyspIHtcbiAgICAgICAgY2lyY2xlRWRnZUNvbGxpc2lvbnMoYW5nbGVzLCBjb3JuZXIsIHJhZGl1cywgYm94Q29ybmVyc1tqXSwgYm94Q29ybmVyc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIC8vIFRPRE8gZml4XG4gICAgICAgIC8vIFRoaXMgY291bGQgZ2V0IGhpdCB3aGVuIGEgcG9pbnQgaW50ZXJzZWN0cyB2ZXJ5IGNsb3NlIHRvIGEgY29ybmVyXG4gICAgICAgIC8vIGFuZCBmbG9hdGluZyBwb2ludCBpc3N1ZXMgY2F1c2Ugb25seSBvbmUgb2YgdGhlIGVudHJ5IG9yIGV4aXQgdG8gYmUgY291bnRlZFxuICAgICAgICB0aHJvdygnZXhwZWN0aW5nIGFuIGV2ZW4gbnVtYmVyIG9mIGludGVyc2VjdGlvbnMnKTtcbiAgICB9XG5cbiAgICBhbmdsZXMuc29ydCgpO1xuXG4gICAgLy8gR3JvdXAgYnkgcGFpcnMsIHdoZXJlIGVhY2ggcmVwcmVzZW50cyBhIHJhbmdlIHdoZXJlIGEgY29sbGlzaW9uIG9jY3Vyc1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYW5nbGVzLmxlbmd0aDsgays9Mikge1xuICAgICAgICBjb2xsaXNpb25zW2svMl0gPSBmbGlwID9cbiAgICAgICAgICAgIFsyICogTWF0aC5QSSAtIGFuZ2xlc1trKzFdLCAyICogTWF0aC5QSSAtIGFuZ2xlc1trXV0gOiAvLyByZWZsZWN0IGFuIGFuZ2xlIGFyb3VuZCAwIGRlZ3JlZXNcbiAgICAgICAgICAgIFthbmdsZXNba10sIGFuZ2xlc1trKzFdXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGlzaW9ucztcbn1cblxuLypcbiAqIFJldHVybiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiBhIGNpcmNsZSBhbmQgYSBsaW5lIHNlZ21lbnQ7XG4gKi9cbmZ1bmN0aW9uIGNpcmNsZUVkZ2VDb2xsaXNpb25zKGFuZ2xlcywgY29ybmVyLCByYWRpdXMsIHAxLCBwMikge1xuXG4gICAgdmFyIGVkZ2VYID0gcDIueCAtIHAxLng7XG4gICAgdmFyIGVkZ2VZID0gcDIueSAtIHAxLnk7XG5cbiAgICB2YXIgYSA9IGVkZ2VYICogZWRnZVggKyBlZGdlWSAqIGVkZ2VZO1xuICAgIHZhciBiID0gKGVkZ2VYICogcDEueCArIGVkZ2VZICogcDEueSkgKiAyO1xuICAgIHZhciBjID0gcDEueCAqIHAxLnggKyBwMS55ICogcDEueSAtIHJhZGl1cyAqIHJhZGl1cztcblxuICAgIHZhciBkaXNjcmltaW5hbnQgPSBiKmIgLSA0KmEqYztcblxuICAgIC8vIGEgY29sbGlzaW9uIGV4aXN0cyBvbmx5IGlmIGxpbmUgaW50ZXJzZWN0cyBjaXJjbGUgYXQgdHdvIHBvaW50c1xuICAgIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgICAgIHZhciB4MSA9ICgtYiAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gICAgICAgIHZhciB4MiA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG5cbiAgICAgICAgLy8gb25seSBhZGQgcG9pbnRzIGlmIHdpdGhpbiBsaW5lIHNlZ21lbnRcbiAgICAgICAgLy8gaGFjayB0byBoYW5kbGUgZmxvYXRpbmcgcG9pbnQgcmVwcmVzZW50YXRpb25zIG9mIDAgYW5kIDFcbiAgICAgICAgaWYgKDAgPCB4MSAmJiB4MSA8IDEpIHtcbiAgICAgICAgICAgIGFuZ2xlcy5wdXNoKGdldEFuZ2xlKHAxLCBwMiwgeDEsIGNvcm5lcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKDAgPCB4MiAmJiB4MiA8IDEpIHtcbiAgICAgICAgICAgIGFuZ2xlcy5wdXNoKGdldEFuZ2xlKHAxLCBwMiwgeDIsIGNvcm5lcikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuZ2xlcztcbn1cblxuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBkLCBjb3JuZXIpIHtcbiAgICByZXR1cm4gKC1jb3JuZXIuYW5nbGVXaXRoU2VwKFxuICAgICAgICB1dGlsLmludGVycChwMS54LCBwMi54LCBkKSxcbiAgICAgICAgdXRpbC5pbnRlcnAocDEueSwgcDIueSwgZCkpICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29ybmVycyhhKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFBvaW50KGEueDEsIGEueTEpLFxuICAgICAgICBuZXcgUG9pbnQoYS54MSwgYS55MiksXG4gICAgICAgIG5ldyBQb2ludChhLngyLCBhLnkyKSxcbiAgICAgICAgbmV3IFBvaW50KGEueDIsIGEueTEpXG4gICAgXTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2hhcGU6IHNoYXBlXG59O1xuXG5mdW5jdGlvbiBzaGFwZSh0ZXh0LCBuYW1lLCBzdGFja3MsIG1heFdpZHRoLCBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRyYW5zbGF0ZSkge1xuICAgIHZhciBnbHlwaHMgPSBzdGFja3NbbmFtZV0uZ2x5cGhzO1xuICAgIHZhciBnbHlwaDtcblxuICAgIHZhciBzaGFwaW5nID0gW107XG5cbiAgICB2YXIgeCA9IHRyYW5zbGF0ZVswXTtcbiAgICB2YXIgeSA9IHRyYW5zbGF0ZVsxXTtcbiAgICB2YXIgaWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWQgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2lkXTtcblxuICAgICAgICBpZiAoaWQgPT09IDAgfHwgIWdseXBoKSBjb250aW51ZTtcblxuICAgICAgICBzaGFwaW5nLnB1c2goe1xuICAgICAgICAgICAgZm9udHN0YWNrOiBuYW1lLFxuICAgICAgICAgICAgZ2x5cGg6IGlkLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlICsgc3BhY2luZztcbiAgICB9XG5cbiAgICBpZiAoIXNoYXBpbmcubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBzaGFwaW5nID0gbGluZXdyYXAoc2hhcGluZywgZ2x5cGhzLCBsaW5lSGVpZ2h0LCBtYXhXaWR0aCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5KTtcblxuICAgIHJldHVybiBzaGFwaW5nO1xufVxuXG52YXIgYnJlYWthYmxlID0geyAzMjogdHJ1ZSB9OyAvLyBDdXJyZW50bHkgb25seSBicmVha3MgYXQgcmVndWxhciBzcGFjZXNcblxuZnVuY3Rpb24gbGluZXdyYXAoc2hhcGluZywgZ2x5cGhzLCBsaW5lSGVpZ2h0LCBtYXhXaWR0aCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5KSB7XG4gICAgdmFyIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xuXG4gICAgdmFyIGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lID0gMDtcbiAgICB2YXIgbGluZVN0YXJ0SW5kZXggPSAwO1xuICAgIHZhciBsaW5lID0gMDtcblxuICAgIHZhciBtYXhMaW5lTGVuZ3RoID0gMDtcblxuICAgIGlmIChtYXhXaWR0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBpbmdbaV07XG5cbiAgICAgICAgICAgIHNoYXBlLnggLT0gbGVuZ3RoQmVmb3JlQ3VycmVudExpbmU7XG4gICAgICAgICAgICBzaGFwZS55ICs9IGxpbmVIZWlnaHQgKiBsaW5lO1xuXG4gICAgICAgICAgICBpZiAoc2hhcGUueCA+IG1heFdpZHRoICYmIGxhc3RTYWZlQnJlYWsgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gc2hhcGluZ1tsYXN0U2FmZUJyZWFrICsgMV0ueDtcbiAgICAgICAgICAgICAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobGluZUxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gbGFzdFNhZmVCcmVhayArIDE7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBpbmdba10ueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzaGFwaW5nW2tdLnggLT0gbGluZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoanVzdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5TGluZShzaGFwaW5nLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBsYXN0U2FmZUJyZWFrIC0gMSwganVzdGlmeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0SW5kZXggPSBsYXN0U2FmZUJyZWFrICsgMTtcbiAgICAgICAgICAgICAgICBsYXN0U2FmZUJyZWFrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZW5ndGhCZWZvcmVDdXJyZW50TGluZSArPSBsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJyZWFrYWJsZVtzaGFwZS5nbHlwaF0pIHtcbiAgICAgICAgICAgICAgICBsYXN0U2FmZUJyZWFrID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1heExpbmVMZW5ndGggPSBtYXhMaW5lTGVuZ3RoIHx8IHNoYXBpbmdbc2hhcGluZy5sZW5ndGggLSAxXS54O1xuXG4gICAganVzdGlmeUxpbmUoc2hhcGluZywgZ2x5cGhzLCBsaW5lU3RhcnRJbmRleCwgc2hhcGluZy5sZW5ndGggLSAxLCBqdXN0aWZ5KTtcbiAgICBhbGlnbihzaGFwaW5nLCBqdXN0aWZ5LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIG1heExpbmVMZW5ndGgsIGxpbmVIZWlnaHQsIGxpbmUpO1xuICAgIHJldHVybiBzaGFwaW5nO1xufVxuXG5mdW5jdGlvbiBqdXN0aWZ5TGluZShzaGFwaW5nLCBnbHlwaHMsIHN0YXJ0LCBlbmQsIGp1c3RpZnkpIHtcbiAgICB2YXIgbGFzdEFkdmFuY2UgPSBnbHlwaHNbc2hhcGluZ1tlbmRdLmdseXBoXS5hZHZhbmNlO1xuICAgIHZhciBsaW5lSW5kZW50ID0gKHNoYXBpbmdbZW5kXS54ICsgbGFzdEFkdmFuY2UpICoganVzdGlmeTtcblxuICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICBzaGFwaW5nW2pdLnggLT0gbGluZUluZGVudDtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gYWxpZ24oc2hhcGluZywganVzdGlmeSwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBtYXhMaW5lTGVuZ3RoLCBsaW5lSGVpZ2h0LCBsaW5lKSB7XG4gICAgdmFyIHNoaWZ0WCA9IChqdXN0aWZ5IC0gaG9yaXpvbnRhbEFsaWduKSAqIG1heExpbmVMZW5ndGg7XG4gICAgdmFyIHNoaWZ0WSA9ICgtdmVydGljYWxBbGlnbiAqIChsaW5lICsgMSkgKyAwLjUpICogbGluZUhlaWdodDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhcGluZy5sZW5ndGg7IGorKykge1xuICAgICAgICBzaGFwaW5nW2pdLnggKz0gc2hpZnRYO1xuICAgICAgICBzaGFwaW5nW2pdLnkgKz0gc2hpZnRZO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wuanMnKSxcbiAgICBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbS5qcycpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGlvbjtcblxuZnVuY3Rpb24gQXR0cmlidXRpb24oKSB7fVxuXG5BdHRyaWJ1dGlvbi5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQ29udHJvbCwge1xuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtYXBib3hnbC1jdHJsLWF0dHJpYicsXG4gICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIG1hcC5jb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICBtYXAub24oJ3NvdXJjZS5hZGQnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIG1hcC5vbignc291cmNlLnJlbW92ZScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBtYXAub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVFZGl0TGluay5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF0dHJPYmogPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWFwLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9tYXAuc291cmNlc1tpZF07XG4gICAgICAgICAgICBpZiAoc291cmNlLmF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXR0ck9ialtzb3VyY2UuYXR0cmlidXRpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0cmlidXRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gYXR0ck9iaikge1xuICAgICAgICAgICAgYXR0cmlidXRpb25zLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IGF0dHJpYnV0aW9ucy5qb2luKCcgfCAnKTtcbiAgICAgICAgdGhpcy5fZWRpdExpbmsgPSB0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbWFwYm94LWltcHJvdmUtbWFwJylbMF07XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVFZGl0TGluazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9lZGl0TGluaykge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRMaW5rLmhyZWYgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXAtZmVlZGJhY2svIy8nICtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyLmxuZyArICcvJyArIGNlbnRlci5sYXQgKyAnLycgKyBNYXRoLnJvdW5kKHRoaXMuX21hcC5nZXRab29tKCkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2w7XG5cbmZ1bmN0aW9uIENvbnRyb2woKSB7fVxuXG5Db250cm9sLnByb3RvdHlwZSA9IHtcblx0YWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHRpZiAodGhpcy5vblJlbW92ZSkgdGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xuXHRcdHRoaXMuX21hcCA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sLmpzJyksXG4gICAgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20uanMnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmF2aWdhdGlvbjtcblxuZnVuY3Rpb24gTmF2aWdhdGlvbigpIHt9XG5cbk5hdmlnYXRpb24ucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybC1uYXYnO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIG1hcC5jb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuX3pvb21JbkJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUgKyAnLXpvb20taW4nLCBtYXAuem9vbUluLmJpbmQobWFwKSk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy16b29tLW91dCcsIG1hcC56b29tT3V0LmJpbmQobWFwKSk7XG4gICAgICAgIHRoaXMuX2NvbXBhc3MgPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1jb21wYXNzJywgbWFwLnJlc2V0Tm9ydGguYmluZChtYXApKTtcblxuICAgICAgICB2YXIgY29tcGFzc0NhbnZhcyA9IHRoaXMuX2NvbXBhc3NDYW52YXMgPSBET00uY3JlYXRlKCdjYW52YXMnLCBjbGFzc05hbWUgKyAnLWNvbXBhc3MtY2FudmFzJywgdGhpcy5fY29tcGFzcyk7XG4gICAgICAgIGNvbXBhc3NDYW52YXMuc3R5bGUuY3NzVGV4dCA9ICd3aWR0aDoyNnB4OyBoZWlnaHQ6MjZweDsnO1xuICAgICAgICBjb21wYXNzQ2FudmFzLndpZHRoID0gMjYgKiAyO1xuICAgICAgICBjb21wYXNzQ2FudmFzLmhlaWdodCA9IDI2ICogMjtcblxuICAgICAgICB0aGlzLl9jb21wYXNzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uQ29tcGFzc0Rvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc01vdmUgPSB0aGlzLl9vbkNvbXBhc3NNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc1VwID0gdGhpcy5fb25Db21wYXNzVXAuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jb21wYXNzQ3R4ID0gY29tcGFzc0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIG1hcC5vbigncm90YXRlJywgdGhpcy5fZHJhd05vcnRoLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kcmF3Tm9ydGgoKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzRG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICBET00uZGlzYWJsZURyYWcoKTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNvbXBhc3NNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQ29tcGFzc1VwKTtcbiAgICAgICAgdGhpcy5fcHJldlggPSBlLnNjcmVlblg7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX29uQ29tcGFzc01vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHggPSBlLnNjcmVlblgsXG4gICAgICAgICAgICBkID0geCA8IDIgPyAtNSA6IC8vIGxlZnQgZWRnZSBvZiB0aGUgc2NyZWVuLCBjb250aW51ZSByb3RhdGluZ1xuICAgICAgICAgICAgICAgIHggPiB3aW5kb3cuc2NyZWVuLndpZHRoIC0gMiA/IDUgOiAvLyByaWdodCBlZGdlXG4gICAgICAgICAgICAgICAgKHggLSB0aGlzLl9wcmV2WCkgLyA0O1xuXG4gICAgICAgIHRoaXMuX21hcC5zZXRCZWFyaW5nKHRoaXMuX21hcC5nZXRCZWFyaW5nKCkgLSBkKTtcbiAgICAgICAgdGhpcy5fcHJldlggPSBlLnNjcmVlblg7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzVXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNvbXBhc3NNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQ29tcGFzc1VwKTtcbiAgICAgICAgRE9NLmVuYWJsZURyYWcoKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24oY2xhc3NOYW1lLCBmbikge1xuICAgICAgICB2YXIgYSA9IERPTS5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGEuaHJlZiA9ICcjJztcbiAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgX2RyYXdOb3J0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYWQgPSAyMCxcbiAgICAgICAgICAgIHdpZHRoID0gOCxcbiAgICAgICAgICAgIGNlbnRlciA9IDI2LFxuICAgICAgICAgICAgYW5nbGUgPSB0aGlzLl9tYXAudHJhbnNmb3JtLmFuZ2xlICsgKE1hdGguUEkgLyAyKSxcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2NvbXBhc3NDdHg7XG5cbiAgICAgICAgdGhpcy5fY29tcGFzc0NhbnZhcy53aWR0aCA9IHRoaXMuX2NvbXBhc3NDYW52YXMud2lkdGg7XG5cbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgICAgICAgY3R4LmxpbmVUbygwLCAtd2lkdGgpO1xuICAgICAgICBjdHgubGluZVRvKC1yYWQsIDApO1xuICAgICAgICBjdHgubGluZVRvKDAsIHdpZHRoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2JiYic7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgd2lkdGgpO1xuICAgICAgICBjdHgubGluZVRvKHJhZCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgLXdpZHRoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmZmJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDQ7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgLXdpZHRoKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCB3aWR0aCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcbiAgICBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyksXG4gICAgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdGxuZy5qcycpLFxuICAgIExhdExuZ0JvdW5kcyA9IHJlcXVpcmUoJy4uL2dlby9sYXRsbmdib3VuZHMuanMnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbnV0aWwuZXh0ZW5kKGV4cG9ydHMsIHtcbiAgICBpc0Vhc2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hYm9ydEZuO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hYm9ydEZuKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydEZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWJvcnRGbjtcblxuICAgICAgICAgICAgdGhpcy5fZmluaXNoRm4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9maW5pc2hGbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2Vhc2U6IGZ1bmN0aW9uKGZyYW1lLCBmaW5pc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoRm4gPSBmaW5pc2g7XG4gICAgICAgIHRoaXMuX2Fib3J0Rm4gPSBicm93c2VyLnRpbWVkKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBmcmFtZS5jYWxsKHRoaXMsIG9wdGlvbnMuZWFzaW5nKHQpKTtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Fib3J0Rm47XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoRm4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmluaXNoRm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgPyAwIDogb3B0aW9ucy5kdXJhdGlvbiwgdGhpcyk7XG4gICAgfSxcblxuICAgIHBhbkJ5OiBmdW5jdGlvbihvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wYW5Ubyh0aGlzLnRyYW5zZm9ybS5jZW50ZXIsIHV0aWwuZXh0ZW5kKHtvZmZzZXQ6IFBvaW50LmNvbnZlcnQob2Zmc2V0KS5tdWx0KC0xKX0sIG9wdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHBhblRvOiBmdW5jdGlvbihsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgbGF0bG5nID0gTGF0TG5nLmNvbnZlcnQobGF0bG5nKTtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlLFxuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KS5yb3RhdGUoLXRyLmFuZ2xlKSxcbiAgICAgICAgICAgIGZyb20gPSB0ci5wb2ludCxcbiAgICAgICAgICAgIHRvID0gdHIucHJvamVjdChsYXRsbmcpLnN1YihvZmZzZXQpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgdHIuY2VudGVyID0gdHIudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1Yihmcm9tKS5tdWx0KGspKSk7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBab29tcyB0byBhIGNlcnRhaW4gem9vbSBsZXZlbCB3aXRoIGVhc2luZy5cbiAgICB6b29tVG86IGZ1bmN0aW9uKHpvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDBcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgb3B0aW9ucy5lYXNpbmcgPSB0aGlzLl91cGRhdGVFYXNpbmcob3B0aW9ucy5kdXJhdGlvbiwgem9vbSwgb3B0aW9ucy5lYXNpbmcpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgYXJvdW5kID0gdHIuY2VudGVyLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdHIuem9vbTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hcm91bmQpIHtcbiAgICAgICAgICAgIGFyb3VuZCA9IExhdExuZy5jb252ZXJ0KG9wdGlvbnMuYXJvdW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgYXJvdW5kID0gdHIucG9pbnRMb2NhdGlvbih0ci5jZW50ZXJQb2ludC5hZGQoUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSBvcHRpb25zLmR1cmF0aW9uID0gMDtcblxuICAgICAgICBpZiAoIXRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHRyLnNldFpvb21Bcm91bmQodXRpbC5pbnRlcnAoc3RhcnRab29tLCB6b29tLCBrKSwgYXJvdW5kKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoMzAwKTsgLy8gdGV4dCBmYWRpbmdcbiAgICAgICAgICAgIHRoaXMuX21vdmUodHJ1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5lYXNlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmR1cmF0aW9uID49IDIwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiA8IDIwMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX29uWm9vbUVuZCk7XG4gICAgICAgICAgICB0aGlzLl9vblpvb21FbmQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDIwMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgem9vbUluOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuZ2V0Wm9vbSgpICsgMSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIHpvb21PdXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgLSAxLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgcm90YXRlVG86IGZ1bmN0aW9uKGJlYXJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICBlYXNpbmc6IHV0aWwuZWFzZVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBhcm91bmQgPSB0ci5jZW50ZXI7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXJvdW5kKSB7XG4gICAgICAgICAgICBhcm91bmQgPSBMYXRMbmcuY29udmVydChvcHRpb25zLmFyb3VuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgICAgICAgIGFyb3VuZCA9IHRyLnBvaW50TG9jYXRpb24odHIuY2VudGVyUG9pbnQuYWRkKFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJvdGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHRyLnNldEJlYXJpbmdBcm91bmQodXRpbC5pbnRlcnAoc3RhcnQsIGJlYXJpbmcsIGspLCBhcm91bmQpO1xuICAgICAgICAgICAgdGhpcy5fbW92ZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXNldE5vcnRoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZVRvKDAsIHV0aWwuZXh0ZW5kKHtkdXJhdGlvbjogMTAwMH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAgICAgbWF4Wm9vbTogSW5maW5pdHlcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgYm91bmRzID0gTGF0TG5nQm91bmRzLmNvbnZlcnQoYm91bmRzKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgbncgPSB0ci5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aFdlc3QoKSksXG4gICAgICAgICAgICBzZSA9IHRyLnByb2plY3QoYm91bmRzLmdldFNvdXRoRWFzdCgpKSxcbiAgICAgICAgICAgIHNpemUgPSBzZS5zdWIobncpLFxuICAgICAgICAgICAgY2VudGVyID0gdHIudW5wcm9qZWN0KG53LmFkZChzZSkuZGl2KDIpKSxcblxuICAgICAgICAgICAgc2NhbGVYID0gKHRyLndpZHRoIC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldC54KSAqIDIpIC8gc2l6ZS54LFxuICAgICAgICAgICAgc2NhbGVZID0gKHRyLmhlaWdodCAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXQueSkgKiAyKSAvIHNpemUueSxcblxuICAgICAgICAgICAgem9vbSA9IE1hdGgubWluKHRyLnNjYWxlWm9vbSh0ci5zY2FsZSAqIE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSksIG9wdGlvbnMubWF4Wm9vbSk7XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubGluZWFyID9cbiAgICAgICAgICAgIHRoaXMuZWFzZVRvKGNlbnRlciwgem9vbSwgMCwgb3B0aW9ucykgOlxuICAgICAgICAgICAgdGhpcy5mbHlUbyhjZW50ZXIsIHpvb20sIDAsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBlYXNlVG86IGZ1bmN0aW9uKGxhdGxuZywgem9vbSwgYmVhcmluZywgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICBlYXNpbmc6IHV0aWwuZWFzZVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLnJvdGF0ZSgtdHIuYW5nbGUpLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgICBzdGFydEJlYXJpbmcgPSB0aGlzLmdldEJlYXJpbmcoKTtcblxuICAgICAgICBsYXRsbmcgPSBMYXRMbmcuY29udmVydChsYXRsbmcpO1xuICAgICAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogem9vbTtcbiAgICAgICAgYmVhcmluZyA9IGJlYXJpbmcgPT09IHVuZGVmaW5lZCA/IHN0YXJ0QmVhcmluZyA6IGJlYXJpbmc7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdHIuem9vbVNjYWxlKHpvb20gLSBzdGFydFpvb20pLFxuICAgICAgICAgICAgZnJvbSA9IHRyLnBvaW50LFxuICAgICAgICAgICAgdG8gPSBsYXRsbmcgPyB0ci5wcm9qZWN0KGxhdGxuZykuc3ViKG9mZnNldC5kaXYoc2NhbGUpKSA6IHRyLnBvaW50LFxuICAgICAgICAgICAgYXJvdW5kO1xuXG4gICAgICAgIGlmICh6b29tICE9PSBzdGFydFpvb20pIHtcbiAgICAgICAgICAgIGFyb3VuZCA9IHRyLnBvaW50TG9jYXRpb24odHIuY2VudGVyUG9pbnQuYWRkKHRvLnN1Yihmcm9tKS5kaXYoMSAtIDEgLyBzY2FsZSkpKTtcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QmVhcmluZyAhPT0gYmVhcmluZykgdGhpcy5yb3RhdGluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoem9vbSAhPT0gc3RhcnRab29tKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0Wm9vbUFyb3VuZCh1dGlsLmludGVycChzdGFydFpvb20sIHpvb20sIGspLCBhcm91bmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQoaykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJlYXJpbmcgIT09IHN0YXJ0QmVhcmluZykge1xuICAgICAgICAgICAgICAgIHRyLmJlYXJpbmcgPSB1dGlsLmludGVycChzdGFydEJlYXJpbmcsIGJlYXJpbmcsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmFuaW1hdGlvbkxvb3Auc2V0KDMwMCk7IC8vIHRleHQgZmFkaW5nXG4gICAgICAgICAgICB0aGlzLl9tb3ZlKHpvb20gIT09IHN0YXJ0Wm9vbSwgYmVhcmluZyAhPT0gc3RhcnRCZWFyaW5nKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucm90YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZmx5VG86IGZ1bmN0aW9uKGxhdGxuZywgem9vbSwgYmVhcmluZywgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIHNwZWVkOiAxLjIsXG4gICAgICAgICAgICBjdXJ2ZTogMS40MixcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIGxhdGxuZyA9IExhdExuZy5jb252ZXJ0KGxhdGxuZyk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLFxuICAgICAgICAgICAgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHN0YXJ0Wm9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgc3RhcnRCZWFyaW5nID0gdGhpcy5nZXRCZWFyaW5nKCk7XG5cbiAgICAgICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHpvb207XG4gICAgICAgIGJlYXJpbmcgPSBiZWFyaW5nID09PSB1bmRlZmluZWQgPyBzdGFydEJlYXJpbmcgOiBiZWFyaW5nO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHRyLnpvb21TY2FsZSh6b29tIC0gc3RhcnRab29tKSxcbiAgICAgICAgICAgIGZyb20gPSB0ci5wb2ludCxcbiAgICAgICAgICAgIHRvID0gdHIucHJvamVjdChsYXRsbmcpLnN1YihvZmZzZXQuZGl2KHNjYWxlKSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFZpZXcobGF0bG5nLCB6b29tLCBiZWFyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydFdvcmxkU2l6ZSA9IHRyLndvcmxkU2l6ZSxcbiAgICAgICAgICAgIHJobyA9IG9wdGlvbnMuY3VydmUsXG4gICAgICAgICAgICBWID0gb3B0aW9ucy5zcGVlZCxcblxuICAgICAgICAgICAgdzAgPSBNYXRoLm1heCh0ci53aWR0aCwgdHIuaGVpZ2h0KSxcbiAgICAgICAgICAgIHcxID0gdzAgLyBzY2FsZSxcbiAgICAgICAgICAgIHUxID0gdG8uc3ViKGZyb20pLm1hZygpLFxuICAgICAgICAgICAgcmhvMiA9IHJobyAqIHJobztcblxuICAgICAgICBmdW5jdGlvbiByKGkpIHtcbiAgICAgICAgICAgIHZhciBiID0gKHcxICogdzEgLSB3MCAqIHcwICsgKGkgPyAtMSA6IDEpICogcmhvMiAqIHJobzIgKiB1MSAqIHUxKSAvICgyICogKGkgPyB3MSA6IHcwKSAqIHJobzIgKiB1MSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cbiAgICAgICAgZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxuICAgICAgICBmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XG5cbiAgICAgICAgdmFyIHIwID0gcigwKSxcbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfSxcbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gdzAgKiAoKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMikgLyB1MTsgfSxcbiAgICAgICAgICAgIFMgPSAocigxKSAtIHIwKSAvIHJobztcblxuICAgICAgICBpZiAoTWF0aC5hYnModTEpIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh3MCAtIHcxKSA8IDAuMDAwMDAxKSByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgdmFyIGsgPSB3MSA8IHcwID8gLTEgOiAxO1xuICAgICAgICAgICAgUyA9IE1hdGguYWJzKE1hdGgubG9nKHcxIC8gdzApKSAvIHJobztcblxuICAgICAgICAgICAgdSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbihzKSB7IHJldHVybiBNYXRoLmV4cChrICogcmhvICogcyk7IH07XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gMTAwMCAqIFMgLyBWO1xuXG4gICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG4gICAgICAgIGlmIChzdGFydEJlYXJpbmcgIT0gYmVhcmluZykgdGhpcy5yb3RhdGluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGsgKiBTLFxuICAgICAgICAgICAgICAgIHVzID0gdShzKTtcblxuICAgICAgICAgICAgdHIuem9vbSA9IHN0YXJ0Wm9vbSArIHRyLnNjYWxlWm9vbSgxIC8gdyhzKSk7XG4gICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQodXMpKSwgc3RhcnRXb3JsZFNpemUpO1xuXG4gICAgICAgICAgICBpZiAoYmVhcmluZyAhPT0gc3RhcnRCZWFyaW5nKSB7XG4gICAgICAgICAgICAgICAgdHIuYmVhcmluZyA9IHV0aWwuaW50ZXJwKHN0YXJ0QmVhcmluZywgYmVhcmluZywgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoMzAwKTsgLy8gdGV4dCBmYWRpbmdcblxuICAgICAgICAgICAgdGhpcy5fbW92ZSh0cnVlLCBiZWFyaW5nICE9PSBzdGFydEJlYXJpbmcpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlRWFzaW5nOiBmdW5jdGlvbihkdXJhdGlvbiwgem9vbSwgYmV6aWVyKSB7XG4gICAgICAgIHZhciBlYXNpbmc7XG5cbiAgICAgICAgaWYgKHRoaXMuZWFzZSkge1xuICAgICAgICAgICAgdmFyIGVhc2UgPSB0aGlzLmVhc2UsXG4gICAgICAgICAgICAgICAgdCA9IChEYXRlLm5vdygpIC0gZWFzZS5zdGFydCkgLyBlYXNlLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHNwZWVkID0gZWFzZS5lYXNpbmcodCArIDAuMDEpIC0gZWFzZS5lYXNpbmcodCksXG5cbiAgICAgICAgICAgICAgICAvLyBRdWljayBoYWNrIHRvIG1ha2UgbmV3IGJlemllciB0aGF0IGlzIGNvbnRpbnVvdXMgd2l0aCBsYXN0XG4gICAgICAgICAgICAgICAgeCA9IDAuMjcgLyBNYXRoLnNxcnQoc3BlZWQgKiBzcGVlZCArIDAuMDAwMSkgKiAwLjAxLFxuICAgICAgICAgICAgICAgIHkgPSBNYXRoLnNxcnQoMC4yNyAqIDAuMjcgLSB4ICogeCk7XG5cbiAgICAgICAgICAgIGVhc2luZyA9IHV0aWwuYmV6aWVyKHgsIHksIDAuMjUsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFzaW5nID0gYmV6aWVyID8gdXRpbC5iZXppZXIuYXBwbHkodXRpbCwgYmV6aWVyKSA6IHV0aWwuZWFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3JlIGluZm9ybWF0aW9uIG9uIGN1cnJlbnQgZWFzaW5nXG4gICAgICAgIHRoaXMuZWFzZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgdG86IE1hdGgucG93KDIsIHpvb20pLFxuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZWFzaW5nO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuL2ludGVyYWN0aW9uLmpzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGVycztcblxuZnVuY3Rpb24gSGFuZGxlcnMobWFwKSB7XG5cbiAgICB2YXIgcm90YXRlRW5kO1xuXG4gICAgdmFyIGluZXJ0aWFMaW5lYXJpdHkgPSAwLjIsXG4gICAgICAgIGluZXJ0aWFFYXNpbmcgPSB1dGlsLmJlemllcigwLCAwLCBpbmVydGlhTGluZWFyaXR5LCAxKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBuZXcgSW50ZXJhY3Rpb24obWFwLmNvbnRhaW5lcilcbiAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIG1hcC5maXJlKCdjbGljaycsIGUpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2hvdmVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbWFwLmZpcmUoJ2hvdmVyJywgZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1hcC5maXJlKCdtb3Zlc3RhcnQnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1hcC5zdG9wKCk7XG4gICAgICAgICAgICBtYXAucmVzaXplKCk7XG4gICAgICAgICAgICBtYXAudXBkYXRlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbigncGFuJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbWFwLnN0b3AoKTtcbiAgICAgICAgICAgIG1hcC50cmFuc2Zvcm0ucGFuQnkoZS5vZmZzZXQpO1xuICAgICAgICAgICAgbWFwLl9tb3ZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbigncGFuZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKCFlLmluZXJ0aWEpIG1hcC5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHZlbG9jaXR5IHRvIHB4L3MgJiBhZGp1c3QgZm9yIGluY3JlYXNlZCBpbml0aWFsIGFuaW1hdGlvbiBzcGVlZCB3aGVuIGVhc2luZyBvdXRcbiAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSBlLmluZXJ0aWEubXVsdCgxMDAwICogaW5lcnRpYUxpbmVhcml0eSksXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkID0gdmVsb2NpdHkubWFnKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4U3BlZWQgPSA0MDAwOyAvLyBweC9zXG5cbiAgICAgICAgICAgICAgICBpZiAoc3BlZWQgPj0gbWF4U3BlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgPSBtYXhTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkuX3VuaXQoKS5fbXVsdChtYXhTcGVlZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRlY2VsZXJhdGlvbiA9IDgwMDAsIC8vIHB4L3NeMlxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHNwZWVkIC8gKGRlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB2ZWxvY2l0eS5tdWx0KC1kdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cbiAgICAgICAgICAgICAgICBtYXAucGFuQnkob2Zmc2V0LCB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAqIDEwMDAsXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZzogaW5lcnRpYUVhc2luZyxcbiAgICAgICAgICAgICAgICAgICAgbm9Nb3ZlU3RhcnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCd6b29tJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gU2NhbGUgYnkgc2lnbW9pZCBvZiBzY3JvbGwgd2hlZWwgZGVsdGEuXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZS5kZWx0YSAvIDEwMCkpKTtcbiAgICAgICAgICAgIGlmIChlLmRlbHRhIDwgMCAmJiBzY2FsZSAhPT0gMCkgc2NhbGUgPSAxIC8gc2NhbGU7XG5cbiAgICAgICAgICAgIHZhciBmcm9tU2NhbGUgPSBtYXAuZWFzZSAmJiBpc0Zpbml0ZShlLmRlbHRhKSA/IG1hcC5lYXNlLnRvIDogbWFwLnRyYW5zZm9ybS5zY2FsZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9ICFpc0Zpbml0ZShlLmRlbHRhKSA/IDgwMCA6IGUuc291cmNlID09ICd0cmFja3BhZCcgPyAwIDogMzAwO1xuXG4gICAgICAgICAgICBtYXAuem9vbVRvKG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKGZyb21TY2FsZSAqIHNjYWxlKSwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICBhcm91bmQ6IG1hcC51bnByb2plY3QoZS5wb2ludClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ3JvdGF0ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBtYXAudHJhbnNmb3JtLmNlbnRlclBvaW50LCAvLyBDZW50ZXIgb2Ygcm90YXRpb25cbiAgICAgICAgICAgICAgICBzdGFydFRvQ2VudGVyID0gZS5zdGFydC5zdWIoY2VudGVyKSxcbiAgICAgICAgICAgICAgICBzdGFydFRvQ2VudGVyRGlzdCA9IHN0YXJ0VG9DZW50ZXIubWFnKCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBjbGljayB3YXMgdG9vIGNsb3NlIHRvIHRoZSBjZW50ZXIsIG1vdmUgdGhlIGNlbnRlciBvZiByb3RhdGlvbiBieSAyMDAgcGl4ZWxzXG4gICAgICAgICAgICAvLyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjbGljay5cbiAgICAgICAgICAgIGlmIChzdGFydFRvQ2VudGVyRGlzdCA8IDIwMCkge1xuICAgICAgICAgICAgICAgIGNlbnRlciA9IGUuc3RhcnQuYWRkKG5ldyBQb2ludCgtMjAwLCAwKS5fcm90YXRlKHN0YXJ0VG9DZW50ZXIuYW5nbGUoKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmVhcmluZ0RpZmYgPSBlLnByZXYuc3ViKGNlbnRlcikuYW5nbGVXaXRoKGUuY3VycmVudC5zdWIoY2VudGVyKSkgLyBNYXRoLlBJICogMTgwO1xuICAgICAgICAgICAgbWFwLnRyYW5zZm9ybS5iZWFyaW5nID0gbWFwLmdldEJlYXJpbmcoKSAtIGJlYXJpbmdEaWZmO1xuXG4gICAgICAgICAgICBtYXAuX21vdmUoZmFsc2UsIHRydWUpO1xuXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJvdGF0ZUVuZCk7XG4gICAgICAgICAgICByb3RhdGVFbmQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtYXAucm90YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtYXAuX3JlcmVuZGVyKCk7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpO1xuXG5mdW5jdGlvbiBIYXNoKG1hcCkge1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5vbmhhc2guYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIG1hcC5vbignbW92ZScsIHV0aWwuZGVib3VuY2UodGhpcy51cGRhdGVIYXNoLmJpbmQodGhpcyksIDEwMCkpO1xufVxuXG5IYXNoLnByb3RvdHlwZSA9IHtcbiAgICBvbmhhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9jID0gbG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjJywgJycpLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChsb2MubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFZpZXcoWytsb2NbMV0sICtsb2NbMl1dLCArbG9jWzBdLCArKGxvY1szXSB8fCAwKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHVwZGF0ZUhhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5tYXAuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgICB6b29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgYmVhcmluZyA9IHRoaXMubWFwLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbChNYXRoLmxvZyh6b29tKSAvIE1hdGguTE4yKSksXG5cbiAgICAgICAgICAgIGhhc2ggPSAnIycgKyAoTWF0aC5yb3VuZCh6b29tICogMTAwKSAvIDEwMCkgK1xuICAgICAgICAgICAgICAgICcvJyArIGNlbnRlci5sYXQudG9GaXhlZChwcmVjaXNpb24pICtcbiAgICAgICAgICAgICAgICAnLycgKyBjZW50ZXIubG5nLnRvRml4ZWQocHJlY2lzaW9uKSArXG4gICAgICAgICAgICAgICAgKGJlYXJpbmcgPyAnLycgKyAoTWF0aC5yb3VuZChiZWFyaW5nICogMTApIC8gMTApIDogJycpO1xuXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSgnJywgJycsIGhhc2gpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkLmpzJyksXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmFjdGlvbjtcblxuZnVuY3Rpb24gSW50ZXJhY3Rpb24oZWwpIHtcbiAgICB2YXIgaW50ZXJhY3Rpb24gPSB0aGlzO1xuICAgIGlmICghZWwpIHJldHVybjtcblxuICAgIHZhciByb3RhdGluZyA9IGZhbHNlLFxuICAgICAgICBwYW5uZWQgPSBmYWxzZSxcbiAgICAgICAgZmlyc3RQb3MgPSBudWxsLFxuICAgICAgICBwb3MgPSBudWxsLFxuICAgICAgICBpbmVydGlhID0gbnVsbCxcbiAgICAgICAgbm93O1xuXG4gICAgZnVuY3Rpb24gbW91c2VQb3MoZSkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gZWwuY2xpZW50TGVmdCxcbiAgICAgICAgICAgIGUuY2xpZW50WSAtIHJlY3QudG9wIC0gZWwuY2xpZW50VG9wKTtcbiAgICB9XG5cbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHJvdGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgZmlyc3RQb3MgPSBwb3MgPSBtb3VzZVBvcyhldik7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9ubW91c2Vkb3duLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9ubW91c2V1cCwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9ubW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbmNsaWNrLCBmYWxzZSk7XG4gICAgc2Nyb2xsd2hlZWwoem9vbSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBvbmRvdWJsZWNsaWNrLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gem9vbSh0eXBlLCBkZWx0YSwgcG9pbnQpIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgnem9vbScsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdHlwZSxcbiAgICAgICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgICAgIHBvaW50OiBwb2ludFxuICAgICAgICB9KTtcbiAgICAgICAgaW5lcnRpYSA9IG51bGw7XG4gICAgICAgIG5vdyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpY2socG9pbnQpIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgnY2xpY2snLCB7cG9pbnQ6IHBvaW50fSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaG92ZXIocG9pbnQpIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgnaG92ZXInLCB7cG9pbnQ6IHBvaW50fSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFuKHBvaW50KSB7XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBwb3Muc3ViKHBvaW50KTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ3BhbicsIHtvZmZzZXQ6IG9mZnNldH0pO1xuXG4gICAgICAgICAgICAvLyBhZGQgYW4gYXZlcmFnZWQgdmVyc2lvbiBvZiB0aGlzIG1vdmVtZW50IHRvIHRoZSBpbmVydGlhIHZlY3RvclxuICAgICAgICAgICAgaWYgKGluZXJ0aWEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBpdCdzIDAgYWZ0ZXIgc29tZSBlcnJhdGljIHBhbmluZ1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9IGR1cmF0aW9uICsgbm93O1xuICAgICAgICAgICAgICAgICAgICBpbmVydGlhLnB1c2goW3RpbWUsIHBvaW50XSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmVydGlhLmxlbmd0aCA+IDIgJiYgdGltZSAtIGluZXJ0aWFbMF1bMF0gPiAxMDApIGluZXJ0aWEuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5lcnRpYSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHBvcyA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdyZXNpemUnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3RhdGUocG9pbnQpIHtcbiAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgncm90YXRlJywge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFBvcyxcbiAgICAgICAgICAgICAgICBwcmV2OiBwb3MsXG4gICAgICAgICAgICAgICAgY3VycmVudDogcG9pbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbm1vdXNlZG93bihldikge1xuICAgICAgICBmaXJzdFBvcyA9IHBvcyA9IG1vdXNlUG9zKGV2KTtcbiAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgnZG93bicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubW91c2V1cCgpIHtcbiAgICAgICAgcGFubmVkID0gcG9zICYmIGZpcnN0UG9zICYmIChwb3MueCAhPSBmaXJzdFBvcy54IHx8IHBvcy55ICE9IGZpcnN0UG9zLnkpO1xuXG4gICAgICAgIHJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHBvcyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgaW5lcnRpYS5sZW5ndGggPj0gMiAmJiBub3cgPiBEYXRlLm5vdygpIC0gMTAwKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGluZXJ0aWFbMF0sXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgPSBsYXN0WzFdLnN1YihmaXJzdFsxXSkuZGl2KGxhc3RbMF0gLSBmaXJzdFswXSk7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdwYW5lbmQnLCAge2luZXJ0aWE6IHZlbG9jaXR5fSk7XG5cbiAgICAgICAgfSBlbHNlIGludGVyYWN0aW9uLmZpcmUoJ3BhbmVuZCcpO1xuXG4gICAgICAgIGluZXJ0aWEgPSBudWxsO1xuICAgICAgICBub3cgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubW91c2Vtb3ZlKGV2KSB7XG4gICAgICAgIHZhciBwb2ludCA9IG1vdXNlUG9zKGV2KTtcblxuICAgICAgICBpZiAocm90YXRpbmcpIHsgcm90YXRlKHBvaW50KTsgfVxuICAgICAgICBlbHNlIGlmIChwb3MpIHBhbihwb2ludCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRvRWxlbWVudDtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9IGVsICYmIHRhcmdldC5wYXJlbnROb2RlKSB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gZWwpIHtcbiAgICAgICAgICAgICAgICBob3Zlcihwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNsaWNrKGV2KSB7XG4gICAgICAgIGlmICghcGFubmVkKSBjbGljayhtb3VzZVBvcyhldikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uZG91YmxlY2xpY2soZXYpIHtcbiAgICAgICAgem9vbSgnd2hlZWwnLCBJbmZpbml0eSAqIChldi5zaGlmdEtleSA/IC0xIDogMSksIG1vdXNlUG9zKGV2KSk7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsd2hlZWwoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZpcmVmb3ggPSAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIHZhciBzYWZhcmkgPSAvU2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL0Nocm9tKGl1bXxlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIHZhciB0aW1lID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IERhdGU7XG5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB3aGVlbCwgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbCwgZmFsc2UpO1xuXG4gICAgICAgIHZhciBsYXN0RXZlbnQgPSAwO1xuXG4gICAgICAgIHZhciB0eXBlID0gbnVsbDtcbiAgICAgICAgdmFyIHR5cGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgZnVuY3Rpb24gc2Nyb2xsKHZhbHVlLCBldikge1xuICAgICAgICAgICAgdmFyIHN0YW1wID0gdGltZS5ub3coKTtcbiAgICAgICAgICAgIHZhciB0aW1lRGVsdGEgPSBzdGFtcCAtIGxhc3RFdmVudDtcbiAgICAgICAgICAgIGxhc3RFdmVudCA9IHN0YW1wO1xuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBtb3VzZVBvcyhldik7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiAodmFsdWUgJSA0LjAwMDI0NDE0MDYyNSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICAgICAgICAgICAgdHlwZSA9ICd3aGVlbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSAwICYmIE1hdGguYWJzKHZhbHVlKSA8IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgdHJhY2twYWQgZXZlbnQgYmVjYXVzZSBpdCBpcyBzbyBzbWFsbC5cbiAgICAgICAgICAgICAgICB0eXBlID0gJ3RyYWNrcGFkJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZURlbHRhID4gNDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBuZXcgc2Nyb2xsIGFjdGlvbi5cbiAgICAgICAgICAgICAgICB0eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBhIHRpbWVvdXQgaW4gY2FzZSB0aGlzIHdhcyBhIHNpbmd1bGFyIGV2ZW50LCBhbmQgZGVseSBpdFxuICAgICAgICAgICAgICAgIC8vIGJ5IHVwIHRvIDQwbXMuXG4gICAgICAgICAgICAgICAgdHlwZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3doZWVsJztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHlwZSwgLWluaXRpYWxWYWx1ZSwgcG9pbnQpO1xuICAgICAgICAgICAgICAgIH0sIDQwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXBlYXRpbmcgZXZlbnQsIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSB0eXBlIG9mIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8ganVzdCB5ZXQuIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYVxuICAgICAgICAgICAgICAgIC8vIGZhc3QgdHJhY2twYWQ7IG90aGVyd2lzZSB3ZSBzd2l0Y2ggaW50byB3aGVlbCBtb2RlLlxuICAgICAgICAgICAgICAgIHR5cGUgPSAoTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgMjAwKSA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG91ciBkZWxheWVkIGV2ZW50IGlzbid0IGZpcmVkIGFnYWluLCBiZWNhdXNlIHdlXG4gICAgICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSB0aGUgcHJldmlvdXMgZXZlbnQgKHdoaWNoIHdhcyBsZXNzIHRoYW4gNDBtcyBhZ28pIGludG9cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICAgIGlmICh0eXBlVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodHlwZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgZmlyZSB0aGUgY2FsbGJhY2sgaWYgd2UgYWN0dWFsbHkga25vdyB3aGF0IHR5cGUgb2Ygc2Nyb2xsaW5nXG4gICAgICAgICAgICAvLyBkZXZpY2UgdGhlIHVzZXIgdXNlcy5cbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHlwZSwgLXZhbHVlLCBwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3aGVlbChlKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGFZID0gZS5kZWx0YVk7XG4gICAgICAgICAgICAvLyBGaXJlZm94IGRvdWJsZXMgdGhlIHZhbHVlcyBvbiByZXRpbmEgc2NyZWVucy4uLlxuICAgICAgICAgICAgaWYgKGZpcmVmb3ggJiYgZS5kZWx0YU1vZGUgPT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSBkZWx0YVkgLz0gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgaWYgKGUuZGVsdGFNb2RlID09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSBkZWx0YVkgKj0gNDA7XG4gICAgICAgICAgICBzY3JvbGwoZGVsdGFZLCBlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdXNld2hlZWwoZSkge1xuICAgICAgICAgICAgdmFyIGRlbHRhWSA9IC1lLndoZWVsRGVsdGFZO1xuICAgICAgICAgICAgaWYgKHNhZmFyaSkgZGVsdGFZID0gZGVsdGFZIC8gMztcbiAgICAgICAgICAgIHNjcm9sbChkZWx0YVksIGUpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5JbnRlcmFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50ZWQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL3V0aWwvZGlzcGF0Y2hlci5qcycpLFxuICAgIENhbnZhcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2FudmFzLmpzJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpLFxuICAgIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXIuanMnKSxcbiAgICBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4LmpzJyksXG4gICAgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZC5qcycpLFxuXG4gICAgU3R5bGUgPSByZXF1aXJlKCcuLi9zdHlsZS9zdHlsZS5qcycpLFxuICAgIEFuaW1hdGlvbkxvb3AgPSByZXF1aXJlKCcuLi9zdHlsZS9hbmltYXRpb25sb29wLmpzJyksXG4gICAgR0xQYWludGVyID0gcmVxdWlyZSgnLi4vcmVuZGVyL3BhaW50ZXIuanMnKSxcblxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL2dlby90cmFuc2Zvcm0uanMnKSxcbiAgICBIYXNoID0gcmVxdWlyZSgnLi9oYXNoLmpzJyksXG4gICAgSGFuZGxlcnMgPSByZXF1aXJlKCcuL2hhbmRsZXJzLmpzJyksXG4gICAgU291cmNlID0gcmVxdWlyZSgnLi4vc291cmNlL3NvdXJjZS5qcycpLFxuICAgIEVhc2luZ3MgPSByZXF1aXJlKCcuL2Vhc2luZ3MuanMnKSxcbiAgICBMYXRMbmcgPSByZXF1aXJlKCcuLi9nZW8vbGF0bG5nLmpzJyksXG4gICAgTGF0TG5nQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvL2xhdGxuZ2JvdW5kcy5qcycpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKSxcbiAgICBHbHlwaFNvdXJjZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9nbHlwaHNvdXJjZS5qcycpLFxuICAgIEF0dHJpYnV0aW9uID0gcmVxdWlyZSgnLi9jb250cm9sL2F0dHJpYnV0aW9uLmpzJyk7XG5cbi8vIGFsbG93IHJlZGVmaW5pbmcgTWFwIGhlcmUgKGpzaGludCB0aGlua3MgaXQncyBnbG9iYWwpXG4vLyBqc2hpbnQgLVcwNzlcblxudmFyIE1hcCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IHV0aWwuaW5oZXJpdCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbmV3IEFuaW1hdGlvbkxvb3AoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xuICAgIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaCAmJiBuZXcgSGFzaCh0aGlzKTtcblxuICAgIGlmIChvcHRpb25zLm1heEJvdW5kcykge1xuICAgICAgICB2YXIgYiA9IExhdExuZ0JvdW5kcy5jb252ZXJ0KG9wdGlvbnMubWF4Qm91bmRzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ubGF0UmFuZ2UgPSBbYi5nZXRTb3V0aCgpLCBiLmdldE5vcnRoKCldO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5sbmdSYW5nZSA9IFtiLmdldFdlc3QoKSwgYi5nZXRFYXN0KCldO1xuICAgIH1cblxuICAgIHRoaXMuX29uU3R5bGVDaGFuZ2UgPSB0aGlzLl9vblN0eWxlQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlQnVja2V0cyA9IHRoaXMuX3VwZGF0ZUJ1Y2tldHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZXR1cENvbnRhaW5lcigpO1xuICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IG9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbmV3IEhhbmRsZXJzKHRoaXMpO1xuICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKE1hdGgubWF4KG9wdGlvbnMubnVtV29ya2VycywgMSksIHRoaXMpO1xuXG4gICAgIC8vIGRvbid0IHNldCBwb3NpdGlvbiBmcm9tIG9wdGlvbnMgaWYgc2V0IHRocm91Z2ggaGFzaFxuICAgIGlmICghdGhpcy5oYXNoIHx8ICF0aGlzLmhhc2gub25oYXNoKCkpIHtcbiAgICAgICAgdGhpcy5zZXRWaWV3KG9wdGlvbnMuY2VudGVyLCBvcHRpb25zLnpvb20sIG9wdGlvbnMuYmVhcmluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VzID0ge307XG4gICAgdGhpcy5zdGFja3MgPSB7fTtcblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUob3B0aW9ucy5zdHlsZSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBhamF4LmdldEpTT04ob3B0aW9ucy5zdHlsZSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZShkYXRhKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHRoaXMuYWRkQ29udHJvbChuZXcgQXR0cmlidXRpb24oKSk7XG59O1xuXG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCBFdmVudGVkKTtcbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIEVhc2luZ3MpO1xudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwge1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgem9vbTogMCxcbiAgICAgICAgYmVhcmluZzogMCxcblxuICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICBtYXhab29tOiAyMCxcbiAgICAgICAgbnVtV29ya2VyczogYnJvd3Nlci5oYXJkd2FyZUNvbmN1cnJlbmN5IC0gMSxcblxuICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgaGFzaDogZmFsc2UsXG5cbiAgICAgICAgYXR0cmlidXRpb25Db250cm9sOiB0cnVlXG4gICAgfSxcblxuICAgIGFkZFNvdXJjZTogZnVuY3Rpb24oaWQsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNvdXJjZXNbaWRdID0gc291cmNlO1xuICAgICAgICBzb3VyY2UuaWQgPSBpZDtcbiAgICAgICAgaWYgKHNvdXJjZS5vbkFkZCkge1xuICAgICAgICAgICAgc291cmNlLm9uQWRkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UuZW5hYmxlZCkgc291cmNlLmZpcmUoJ3NvdXJjZS5hZGQnLCB7c291cmNlOiBzb3VyY2V9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZVNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlc1tpZF07XG4gICAgICAgIGlmIChzb3VyY2Uub25SZW1vdmUpIHtcbiAgICAgICAgICAgIHNvdXJjZS5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5zb3VyY2VzW2lkXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyZSgnc291cmNlLnJlbW92ZScsIHtzb3VyY2U6IHNvdXJjZX0pO1xuICAgIH0sXG5cbiAgICBhZGRDb250cm9sOiBmdW5jdGlvbihjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuYWRkVG8odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIG1hcCdzIGNlbnRlciwgem9vbSwgYW5kIGJlYXJpbmdcbiAgICBzZXRWaWV3OiBmdW5jdGlvbihjZW50ZXIsIHpvb20sIGJlYXJpbmcpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRyLnpvb20gIT09ICt6b29tLFxuICAgICAgICAgICAgYmVhcmluZ0NoYW5nZWQgPSB0ci5iZWFyaW5nICE9PSArYmVhcmluZztcblxuICAgICAgICB0ci5jZW50ZXIgPSBMYXRMbmcuY29udmVydChjZW50ZXIpO1xuICAgICAgICB0ci56b29tID0gK3pvb207XG4gICAgICAgIHRyLmJlYXJpbmcgPSArYmVhcmluZztcblxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLmZpcmUoJ21vdmVzdGFydCcpXG4gICAgICAgICAgICAuX21vdmUoem9vbUNoYW5nZWQsIGJlYXJpbmdDaGFuZ2VkKVxuICAgICAgICAgICAgLmZpcmUoJ21vdmVlbmQnKTtcbiAgICB9LFxuXG4gICAgc2V0Q2VudGVyOiBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5nZXRab29tKCksIHRoaXMuZ2V0QmVhcmluZygpKTtcbiAgICB9LFxuXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwgdGhpcy5nZXRCZWFyaW5nKCkpO1xuICAgIH0sXG5cbiAgICBzZXRCZWFyaW5nOiBmdW5jdGlvbihiZWFyaW5nKSB7XG4gICAgICAgIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB0aGlzLmdldFpvb20oKSwgYmVhcmluZyk7XG4gICAgfSxcblxuICAgIGdldENlbnRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5jZW50ZXI7IH0sXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS56b29tOyB9LFxuICAgIGdldEJlYXJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0uYmVhcmluZzsgfSxcblxuICAgIC8vIERldGVjdCB0aGUgbWFwJ3MgbmV3IHdpZHRoIGFuZCBoZWlnaHQgYW5kIHJlc2l6ZSBpdC5cbiAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwLCBoZWlnaHQgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCB8fCA0MDA7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgMzAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uX2NvbnN0cmFpbigpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUuc3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNwcml0ZS5yZXNpemUodGhpcy5wYWludGVyLmdsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFpbnRlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuICAgICAgICAgICAgLl9tb3ZlKClcbiAgICAgICAgICAgIC5maXJlKCdyZXNpemUnKVxuICAgICAgICAgICAgLmZpcmUoJ21vdmVlbmQnKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKG5ldyBQb2ludCgwLCAwKSksXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHRoaXMudHJhbnNmb3JtLnNpemUpKTtcbiAgICB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhdGlvblBvaW50KExhdExuZy5jb252ZXJ0KGxhdGxuZykpO1xuICAgIH0sXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihQb2ludC5jb252ZXJ0KHBvaW50KSk7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzQXQ6IGZ1bmN0aW9uKHBvaW50LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgbWFwID0gdGhpcztcblxuICAgICAgICBwb2ludCA9IFBvaW50LmNvbnZlcnQocG9pbnQpO1xuXG4gICAgICAgIHV0aWwuYXN5bmNFYWNoKE9iamVjdC5rZXlzKHRoaXMuc291cmNlcyksIGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG1hcC5zb3VyY2VzW2lkXTtcbiAgICAgICAgICAgIHNvdXJjZS5mZWF0dXJlc0F0KHBvaW50LCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkgZmVhdHVyZXMgPSBmZWF0dXJlcy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGZlYXR1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vblN0eWxlQ2hhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZSBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKHN0eWxlLCB0aGlzLmFuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLnN0eWxlLnN0eWxlc2hlZXQuc291cmNlcztcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRTb3VyY2UoaWQsIFNvdXJjZS5jcmVhdGUoc291cmNlc1tpZF0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2x5cGhTb3VyY2UgPSBuZXcgR2x5cGhTb3VyY2UodGhpcy5zdHlsZS5zdHlsZXNoZWV0LmdseXBocywgdGhpcy5wYWludGVyLmdseXBoQXRsYXMpO1xuXG4gICAgICAgIHRoaXMuc3R5bGUub24oJ2NoYW5nZScsIHRoaXMuX29uU3R5bGVDaGFuZ2UpO1xuXG4gICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl90aWxlc0RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl91cGRhdGVCdWNrZXRzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUdseXBocygpO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnc3R5bGUuY2hhbmdlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9tb3ZlOiBmdW5jdGlvbiAoem9vbSwgcm90YXRlKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGUoem9vbSkuZmlyZSgnbW92ZScpO1xuXG4gICAgICAgIGlmICh6b29tKSB0aGlzLmZpcmUoJ3pvb20nKTtcbiAgICAgICAgaWYgKHJvdGF0ZSkgdGhpcy5maXJlKCdyb3RhdGUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gbWFwIHNldHVwIGNvZGVcblxuICAgIF9zZXR1cENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciA9IHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLW1hcCcpO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG5ldyBDYW52YXModGhpcywgY29udGFpbmVyKTtcbiAgICB9LFxuXG4gICAgX3NldHVwUGFpbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuY2FudmFzLmdldFdlYkdMQ29udGV4dCgpO1xuXG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBXZWJHTCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gbmV3IEdMUGFpbnRlcihnbCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIH0sXG5cbiAgICBfY29udGV4dExvc3Q6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLl9mcmFtZUlkKSB7XG4gICAgICAgICAgICBicm93c2VyLmNhbmNlbEZyYW1lKHRoaXMuX2ZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb250ZXh0UmVzdG9yZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zZXR1cFBhaW50ZXIoKTtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGJhY2tzIGZyb20gd2ViIHdvcmtlcnNcblxuICAgICdkZWJ1ZyBtZXNzYWdlJzogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgJ2FsZXJ0IG1lc3NhZ2UnOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGFsZXJ0LmFwcGx5KHdpbmRvdywgZGF0YSk7XG4gICAgfSxcblxuICAgICdnZXQgc3ByaXRlIGpzb24nOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLnN0eWxlLnNwcml0ZTtcbiAgICAgICAgaWYgKHNwcml0ZS5sb2FkZWQoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBzcHJpdGU6IHNwcml0ZS5kYXRhLCByZXRpbmE6IHNwcml0ZS5yZXRpbmEgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcHJpdGUub24oJ2xvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgc3ByaXRlOiBzcHJpdGUuZGF0YSwgcmV0aW5hOiBzcHJpdGUucmV0aW5hIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2dldCBnbHlwaHMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2x5cGhTb3VyY2UuZ2V0UmVjdHMocGFyYW1zLmZvbnRzdGFjaywgcGFyYW1zLmNvZGVwb2ludHMsIHBhcmFtcy5pZCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvLyBSZW5kZXJpbmdcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24odXBkYXRlU3R5bGUpIHtcblxuICAgICAgICBpZiAoIXRoaXMuc3R5bGUpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSB0aGlzLl9zdHlsZURpcnR5IHx8IHVwZGF0ZVN0eWxlO1xuICAgICAgICB0aGlzLl90aWxlc0RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsIHdoZW4gYSAocmUtKXJlbmRlciBvZiB0aGUgbWFwIGlzIHJlcXVpcmVkLCBlLmcuIHdoZW4gdGhlIHVzZXIgcGFubmVkIG9yIHpvb21lZCxmIG9yIG5ldyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGVEaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl90aWxlc0RpcnR5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZXNbaWRdLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGlsZXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyR3JvdXBzKHRoaXMuc3R5bGUubGF5ZXJHcm91cHMpO1xuICAgICAgICB0aGlzLmZpcmUoJ3JlbmRlcicpO1xuXG4gICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5hbmltYXRpb25Mb29wLnN0b3BwZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVwYWludCB8fCAhdGhpcy5hbmltYXRpb25Mb29wLnN0b3BwZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVyZW5kZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyR3JvdXBzOiBmdW5jdGlvbihncm91cHMpIHtcbiAgICAgICAgdGhpcy5wYWludGVyLnByZXBhcmVCdWZmZXJzKCk7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgZ3JvdXAsIHNvdXJjZTtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIGdyb3Vwc1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBncm91cHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2VzW2dyb3VwLnNvdXJjZV07XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXJTdGVuY2lsKCk7XG4gICAgICAgICAgICAgICAgc291cmNlLnJlbmRlcihncm91cCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuZHJhdyh1bmRlZmluZWQsIHRoaXMuc3R5bGUsIGdyb3VwLCB7IGJhY2tncm91bmQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mcmFtZUlkKSB7XG4gICAgICAgICAgICB0aGlzLl9mcmFtZUlkID0gYnJvd3Nlci5mcmFtZSh0aGlzLnJlbmRlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uU3R5bGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVTdHlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0eWxlLnJlY2FsY3VsYXRlKHRoaXMudHJhbnNmb3JtLnpvb20pO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlR2x5cGhzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdCgnc2V0IGdseXBocycsIHRoaXMuc3R5bGUuc3R5bGVzaGVldC5nbHlwaHMpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlQnVja2V0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRyYW5zZmVyIGEgc3RyaXBwZWQgZG93biB2ZXJzaW9uIG9mIHRoZSBzdHlsZSB0byB0aGUgd29ya2Vycy4gVGhleSBvbmx5XG4gICAgICAgIC8vIG5lZWQgdGhlIGJ1Y2tldCBpbmZvcm1hdGlvbiB0byBrbm93IHdoYXQgZmVhdHVyZXMgdG8gZXh0cmFjdCBmcm9tIHRoZSB0aWxlLlxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KCdzZXQgYnVja2V0cycsIHRoaXMuc3R5bGUub3JkZXJlZEJ1Y2tldHMpO1xuXG4gICAgICAgIC8vIGNsZWFycyBhbGwgdGlsZXMgdG8gcmVjYWxjdWxhdGUgZ2VvbWV0cmllcyAoZm9yIGNoYW5nZXMgdG8gbGluZWNhcHMsIGxpbmVqb2lucywgLi4uKVxuICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMuc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzW3NdLmxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxufSk7XG5cbnV0aWwuZXh0ZW5kQWxsKE1hcC5wcm90b3R5cGUsIHtcblxuICAgIC8vIGRlYnVnIGNvZGVcbiAgICBfZGVidWc6IGZhbHNlLFxuICAgIGdldCBkZWJ1ZygpIHsgcmV0dXJuIHRoaXMuX2RlYnVnOyB9LFxuICAgIHNldCBkZWJ1Zyh2YWx1ZSkgeyB0aGlzLl9kZWJ1ZyA9IHZhbHVlOyB0aGlzLl9yZXJlbmRlcigpOyB9LFxuXG4gICAgLy8gY29udGludW91cyByZXBhaW50XG4gICAgX3JlcGFpbnQ6IGZhbHNlLFxuICAgIGdldCByZXBhaW50KCkgeyByZXR1cm4gdGhpcy5fcmVwYWludDsgfSxcbiAgICBzZXQgcmVwYWludCh2YWx1ZSkgeyB0aGlzLl9yZXBhaW50ID0gdmFsdWU7IHRoaXMuX3JlcmVuZGVyKCk7IH0sXG5cbiAgICAvLyBwb2x5Z29uIGFudGlhbGlhc2luZ1xuICAgIF9hbnRpYWxpYXNpbmc6IHRydWUsXG4gICAgZ2V0IGFudGlhbGlhc2luZygpIHsgcmV0dXJuIHRoaXMuX2FudGlhbGlhc2luZzsgfSxcbiAgICBzZXQgYW50aWFsaWFzaW5nKHZhbHVlKSB7IHRoaXMuX2FudGlhbGlhc2luZyA9IHZhbHVlOyB0aGlzLl9yZXJlbmRlcigpOyB9LFxuXG4gICAgLy8gc2hvdyB2ZXJ0aWNlc1xuICAgIF92ZXJ0aWNlczogZmFsc2UsXG4gICAgZ2V0IHZlcnRpY2VzKCkgeyByZXR1cm4gdGhpcy5fdmVydGljZXM7IH0sXG4gICAgc2V0IHZlcnRpY2VzKHZhbHVlKSB7IHRoaXMuX3ZlcnRpY2VzID0gdmFsdWU7IHRoaXMuX3JlcmVuZGVyKCk7IH0sXG5cbiAgICAvLyBzaG93IHZlcnRpY2VzXG4gICAgX2xvYWROZXdUaWxlczogdHJ1ZSxcbiAgICBnZXQgbG9hZE5ld1RpbGVzKCkgeyByZXR1cm4gdGhpcy5fbG9hZE5ld1RpbGVzOyB9LFxuICAgIHNldCBsb2FkTmV3VGlsZXModmFsdWUpIHsgdGhpcy5fbG9hZE5ld1RpbGVzID0gdmFsdWU7IHRoaXMudXBkYXRlKCk7IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdG9yO1xuXG5mdW5jdGlvbiBBY3Rvcih0YXJnZXQsIHBhcmVudCkge1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5jYWxsYmFja0lEID0gMDtcbiAgICB0aGlzLnJlY2VpdmUgPSB0aGlzLnJlY2VpdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5yZWNlaXZlLCBmYWxzZSk7XG59XG5cbkFjdG9yLnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHZhciBkYXRhID0gbWVzc2FnZS5kYXRhLFxuICAgICAgICBjYWxsYmFjaztcblxuICAgIGlmIChkYXRhLnR5cGUgPT0gJzxyZXNwb25zZT4nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbZGF0YS5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tkYXRhLmlkXTtcbiAgICAgICAgY2FsbGJhY2soZGF0YS5lcnJvciB8fCBudWxsLCBkYXRhLmRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhLCBmdW5jdGlvbiByZXNwb25zZShlcnIsIGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybigndHJ5aW5nIHRvIGNsb25lJywgZGF0YSwgYnVmZmVycywgbWVzc2FnZS50YXJnZXQpO1xuICAgICAgICAgICAgbWVzc2FnZS50YXJnZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICc8cmVzcG9uc2U+JyxcbiAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyID8gU3RyaW5nKGVycikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH0sIGJ1ZmZlcnMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudFtkYXRhLnR5cGVdKGRhdGEuZGF0YSk7XG4gICAgfVxufTtcblxuQWN0b3IucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCBjYWxsYmFjaywgYnVmZmVycykge1xuICAgIHZhciBpZCA9IG51bGw7XG4gICAgaWYgKGNhbGxiYWNrKSB0aGlzLmNhbGxiYWNrc1tpZCA9IHRoaXMuY2FsbGJhY2tJRCsrXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMudGFyZ2V0LnBvc3RNZXNzYWdlKHsgdHlwZTogdHlwZSwgaWQ6IFN0cmluZyhpZCksIGRhdGE6IGRhdGEgfSwgYnVmZmVycyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmdldEpTT04gPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICB9O1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgJiYgeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgIHRyeSB7IGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZSk7IH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG4gICAgcmV0dXJuIHhocjtcbn07XG5cbmV4cG9ydHMuZ2V0QXJyYXlCdWZmZXIgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICB9O1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgJiYgeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB4aHIucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG4gICAgcmV0dXJuIHhocjtcbn07XG5cbmV4cG9ydHMuZ2V0SW1hZ2UgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgaW1nKTtcbiAgICB9O1xuICAgIGltZy5zcmMgPSB1cmw7XG4gICAgaW1nLmdldERhdGEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEltYWdlRGF0YSh0aGlzKTsgfTtcbiAgICByZXR1cm4gaW1nO1xufTtcblxuZnVuY3Rpb24gZ2V0SW1hZ2VEYXRhKGltZykge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpLmRhdGE7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmcmFtZU5hbWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJztcbiAgICBpZiAod2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSkgcmV0dXJuICdtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnO1xuICAgIGlmICh3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gJ3dlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSc7XG4gICAgaWYgKHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSkgcmV0dXJuICdtc1JlcXVlc3RBbmltYXRpb25GcmFtZSc7XG59KSgpO1xuXG5leHBvcnRzLmZyYW1lID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gd2luZG93W2ZyYW1lTmFtZV0oZm4pO1xufTtcblxuZXhwb3J0cy5jYW5jZWxGcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgKHdpbmRvdy5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgd2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSkoaWQpO1xufTtcblxuZXhwb3J0cy50aW1lZCA9IGZ1bmN0aW9uIChmbiwgZHVyLCBjdHgpIHtcbiAgICBpZiAoIWR1cikge1xuICAgICAgICBmbi5jYWxsKGN0eCwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWJvcnQgPSBmYWxzZSxcbiAgICAgICAgc3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xuXG4gICAgZnVuY3Rpb24gdGljayhub3cpIHtcbiAgICAgICAgaWYgKGFib3J0KSByZXR1cm47XG4gICAgICAgIGlmICghd2luZG93LnBlcmZvcm1hbmNlKSBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGlmIChub3cgPj0gc3RhcnQgKyBkdXIpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAobm93IC0gc3RhcnQpIC8gZHVyKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZnJhbWUodGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBhYm9ydCA9IHRydWU7IH07XG59O1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdXBwb3J0cyA9IFtcblxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnOyB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJzsgfSxcblxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoQXJyYXkucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZpbHRlciAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUubWFwICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNvbWUgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0ICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoRnVuY3Rpb24ucHJvdG90eXBlICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSxcbiAgICAgICAgICAgICAgICAhIShPYmplY3Qua2V5cyAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuaXNTZWFsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzRnJvemVuICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5pc0V4dGVuc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnNlYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICdKU09OJyBpbiB3aW5kb3cgJiYgJ3BhcnNlJyBpbiBKU09OICYmICdzdHJpbmdpZnknIGluIEpTT047XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBpZiAoJ3N1cHBvcnRzQ29udGV4dCcgaW4gY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy5zdXBwb3J0c0NvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLnN1cHBvcnRzQ29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gISF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgKCEhY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgISFjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ1dvcmtlcicgaW4gd2luZG93OyB9XG4gICAgXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VwcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c1tpXSgpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0cy5oYXJkd2FyZUNvbmN1cnJlbmN5ID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgODtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZXZpY2VQaXhlbFJhdGlvJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xuXG5mdW5jdGlvbiBDYW52YXMocGFyZW50LCBjb250YWluZXIpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1jYW52YXMnKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgcGFyZW50Ll9jb250ZXh0TG9zdC5iaW5kKHBhcmVudCksIGZhbHNlKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHBhcmVudC5fY29udGV4dFJlc3RvcmVkLmJpbmQocGFyZW50KSwgZmFsc2UpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG59XG5cbkNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgIC8vIFJlcXVlc3QgdGhlIHJlcXVpcmVkIGNhbnZhcyBzaXplIHRha2luZyB0aGUgcGl4ZWxyYXRpbyBpbnRvIGFjY291bnQuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogd2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxSYXRpbyAqIGhlaWdodDtcblxuICAgIC8vIE1haW50YWluIHRoZSBzYW1lIGNhbnZhcyBzaXplLCBwb3RlbnRpYWxseSBkb3duc2NhbGluZyBpdCBmb3IgSGlEUEkgZGlzcGxheXNcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xufTtcblxuQ2FudmFzLnByb3RvdHlwZS5nZXRXZWJHTENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCB7XG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgICBkZXB0aDogZmFsc2VcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yLmpzJyk7XG5cbnZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG52YXIgd29ya2VyRmlsZSA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xudmFyIGFic29sdXRlID0gd29ya2VyRmlsZS5pbmRleE9mKCdodHRwJykgIT09IC0xO1xuXG5cbi8vIE1hbmFnZXMgdGhlIFdlYldvcmtlcnNcbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlcjtcbmZ1bmN0aW9uIERpc3BhdGNoZXIobGVuZ3RoLCBwYXJlbnQpIHtcbiAgICB0aGlzLmFjdG9ycyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjdG9yID0gMDtcblxuICAgIHZhciB1cmwsIGJsb2IsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzIGRvbWFpbiBpc3N1ZXMgd2UgY2FuJ3QgbG9hZCBpdCBkaXJlY3RseSB3aXRoIHRoZSB1cmwsXG4gICAgICAgIC8vIHNvIGNyZWF0ZSBhIGJsb2IgYW5kIG9iamVjdCB1cmwgYW5kIGxvYWQgdGhhdFxuICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbJ2ltcG9ydFNjcmlwdHMoXCInICsgd29ya2VyRmlsZSArICdcIik7J10sIHt0eXBlIDogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSk7XG4gICAgICAgICAgICB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IHdvcmtlckZpbGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgICB2YXIgYWN0b3IgPSBuZXcgQWN0b3Iod29ya2VyLCBwYXJlbnQpO1xuICAgICAgICBhY3Rvci5uYW1lID0gXCJXb3JrZXIgXCIgKyBpO1xuICAgICAgICB0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcbiAgICB9XG59XG5cbkRpc3BhdGNoZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWN0b3JzW2ldLnNlbmQodHlwZSwgZGF0YSk7XG4gICAgfVxufTtcblxuRGlzcGF0Y2hlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCB0YXJnZXRJRCwgYnVmZmVycykge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0SUQgIT09ICdudW1iZXInIHx8IGlzTmFOKHRhcmdldElEKSkge1xuICAgICAgICAvLyBVc2Ugcm91bmQgcm9iaW4gdG8gc2VuZCByZXF1ZXN0cyB0byB3ZWIgd29ya2Vycy5cbiAgICAgICAgdGFyZ2V0SUQgPSB0aGlzLmN1cnJlbnRBY3RvciA9ICh0aGlzLmN1cnJlbnRBY3RvciArIDEpICUgdGhpcy5hY3RvcnMubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYWN0b3JzW3RhcmdldElEXS5zZW5kKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCBidWZmZXJzKTtcbiAgICByZXR1cm4gdGFyZ2V0SUQ7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEhUVFBfVVJMOiAnaHR0cDovL2EudGlsZXMubWFwYm94LmNvbS92NCcsXG4gICAgSFRUUFNfVVJMOiAnaHR0cHM6Ly9hLnRpbGVzLm1hcGJveC5jb20vdjQnLFxuICAgIEZPUkNFX0hUVFBTOiBmYWxzZSxcbiAgICBSRVFVSVJFX0FDQ0VTU19UT0tFTjogZmFsc2Vcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBpZiAoY2xhc3NOYW1lKSBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgaWYgKGNvbnRhaW5lcikgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZWw7XG59O1xuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG52YXIgZG9jRWwgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDoge30sXG4gICAgc2VsZWN0UHJvcCA9XG4gICAgICAgICd1c2VyU2VsZWN0JyBpbiBkb2NFbCA/ICd1c2VyU2VsZWN0JyA6XG4gICAgICAgICdNb3pVc2VyU2VsZWN0JyBpbiBkb2NFbCA/ICdNb3pVc2VyU2VsZWN0JyA6XG4gICAgICAgICdXZWJraXRVc2VyU2VsZWN0JyBpbiBkb2NFbCA/ICdXZWJraXRVc2VyU2VsZWN0JyA6IG51bGwsXG4gICAgdXNlclNlbGVjdDtcblxuZXhwb3J0cy5kaXNhYmxlRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xuXG4gICAgaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xuICAgIGVsc2UgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgdXNlclNlbGVjdCA9IGRvY0VsLnN0eWxlW3NlbGVjdFByb3BdO1xuICAgICAgICBkb2NFbC5zdHlsZVtzZWxlY3RQcm9wXSA9ICdub25lJztcbiAgICB9XG59O1xuZXhwb3J0cy5lbmFibGVEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICBpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgZWxzZSBpZiAoc2VsZWN0UHJvcCkgZG9jRWwuc3R5bGVbc2VsZWN0UHJvcF0gPSB1c2VyU2VsZWN0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb246IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChmbik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9mZjogZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5zKHR5cGUpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9ldmVudHNbdHlwZV0uaW5kZXhPZihmbik7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmaXJlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5zKHR5cGUpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBkYXRhID0gdXRpbC5leHRlbmQoe30sIGRhdGEpO1xuICAgICAgICB1dGlsLmV4dGVuZChkYXRhLCB7dHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzfSk7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIGFkZGluZy9yZW1vdmluZyBsaXN0ZW5lcnMgaW5zaWRlIG90aGVyIGxpc3RlbmVycyB3b24ndCBjYXVzZSBpbmZpbml0ZSBsb29wXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbGlzdGVuczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaHM7XG5mdW5jdGlvbiBHbHlwaHMoYnVmZmVyLCBlbmQpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnN0YWNrcyA9IHt9O1xuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG5cbiAgICB2YXIgdmFsLCB0YWc7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICAgIHdoaWxlIChidWZmZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhbCA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG4gICAgICAgIHRhZyA9IHZhbCA+PiAzO1xuICAgICAgICBpZiAodGFnID09IDEpIHtcbiAgICAgICAgICAgIHZhciBmb250c3RhY2sgPSB0aGlzLnJlYWRGb250c3RhY2soKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tzW2ZvbnRzdGFjay5uYW1lXSA9IGZvbnRzdGFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2Fybignc2tpcHBpbmcgdGlsZSB0YWcgJyArIHRhZyk7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5HbHlwaHMucHJvdG90eXBlLnJlYWRGb250c3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xuICAgIHZhciBmb250c3RhY2sgPSB7IGdseXBoczoge30gfTtcblxuICAgIHZhciBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG4gICAgdmFyIHZhbCwgdGFnO1xuICAgIHZhciBlbmQgPSBidWZmZXIucG9zICsgYnl0ZXM7XG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFsID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgdGFnID0gdmFsID4+IDM7XG5cbiAgICAgICAgaWYgKHRhZyA9PSAxKSB7XG4gICAgICAgICAgICBmb250c3RhY2submFtZSA9IGJ1ZmZlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDIpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGJ1ZmZlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICBmb250c3RhY2sucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMykge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gdGhpcy5yZWFkR2x5cGgoKTtcbiAgICAgICAgICAgIGZvbnRzdGFjay5nbHlwaHNbZ2x5cGguaWRdID0gZ2x5cGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnRzdGFjaztcbn07XG5cbkdseXBocy5wcm90b3R5cGUucmVhZEdseXBoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcbiAgICB2YXIgZ2x5cGggPSB7fTtcblxuICAgIHZhciBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG4gICAgdmFyIHZhbCwgdGFnO1xuICAgIHZhciBlbmQgPSBidWZmZXIucG9zICsgYnl0ZXM7XG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFsID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgdGFnID0gdmFsID4+IDM7XG5cbiAgICAgICAgaWYgKHRhZyA9PSAxKSB7XG4gICAgICAgICAgICBnbHlwaC5pZCA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDIpIHtcbiAgICAgICAgICAgIGdseXBoLmJpdG1hcCA9IGJ1ZmZlci5yZWFkQnVmZmVyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDMpIHtcbiAgICAgICAgICAgIGdseXBoLndpZHRoID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNCkge1xuICAgICAgICAgICAgZ2x5cGguaGVpZ2h0ID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNSkge1xuICAgICAgICAgICAgZ2x5cGgubGVmdCA9IGJ1ZmZlci5yZWFkU1ZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA2KSB7XG4gICAgICAgICAgICBnbHlwaC50b3AgPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNykge1xuICAgICAgICAgICAgZ2x5cGguYWR2YW5jZSA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBjb25maWcuQUNDRVNTX1RPS0VOO1xuXG4gICAgaWYgKCFhY2Nlc3NUb2tlbiAmJiBjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBBUEkgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkIHRvIHVzZSBNYXBib3ggR0wuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwczovL3d3dy5tYXBib3guY29tL2RldmVsb3BlcnMvYXBpLyNhY2Nlc3MtdG9rZW5zJyk7XG4gICAgfVxuXG4gICAgdmFyIGh0dHBzID0gY29uZmlnLkZPUkNFX0hUVFBTIHx8XG4gICAgICAgICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdodHRwczonID09PSBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXm1hcGJveDpcXC9cXC8vLCAoaHR0cHMgPyBjb25maWcuSFRUUFNfVVJMIDogY29uZmlnLkhUVFBfVVJMKSArICcvJyk7XG4gICAgdXJsICs9IHVybC5pbmRleE9mKCc/JykgIT09IC0xID8gJyZhY2Nlc3NfdG9rZW49JyA6ICc/YWNjZXNzX3Rva2VuPSc7XG5cbiAgICBpZiAoY29uZmlnLlJFUVVJUkVfQUNDRVNTX1RPS0VOKSB7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlblswXSA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIHB1YmxpYyBhY2Nlc3MgdG9rZW4gKHBrLiopIHdpdGggTWFwYm94IEdMIEpTLCBub3QgYSBzZWNyZXQgYWNjZXNzIHRva2VuIChzay4qKS4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZSBodHRwczovL3d3dy5tYXBib3guY29tL2RldmVsb3BlcnMvYXBpLyNhY2Nlc3MtdG9rZW5zJyk7XG4gICAgICAgIH1cblxuICAgICAgICB1cmwgKz0gYWNjZXNzVG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybDtcbn1cblxubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplU291cmNlVVJMID0gZnVuY3Rpb24odXJsLCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghdXJsLm1hdGNoKC9ebWFwYm94OlxcL1xcLy8pKVxuICAgICAgICByZXR1cm4gdXJsO1xuXG4gICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCArICcuanNvbicsIGFjY2Vzc1Rva2VuKTtcblxuICAgIC8vIFRpbGVKU09OIHJlcXVlc3RzIG5lZWQgYSBzZWN1cmUgZmxhZyBhcHBlbmRlZCB0byB0aGVpciBVUkxzIHNvXG4gICAgLy8gdGhhdCB0aGUgc2VydmVyIGtub3dzIHRvIHNlbmQgU1NMLWlmaWVkIHJlc291cmNlIHJlZmVyZW5jZXMuXG4gICAgaWYgKHVybC5pbmRleE9mKCdodHRwcycpID09PSAwKVxuICAgICAgICB1cmwgKz0gJyZzZWN1cmUnO1xuXG4gICAgcmV0dXJuIHVybDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZUdseXBoc1VSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcbiAgICBpZiAoIXVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC8vKSlcbiAgICAgICAgcmV0dXJuIHVybDtcblxuICAgIHJldHVybiBub3JtYWxpemVVUkwodXJsLCBhY2Nlc3NUb2tlbik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICogQSBbbW9zdC1yZWNlbnRseS11c2VkIGNhY2hlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX2FsZ29yaXRobXMpXG4gKiB3aXRoIGhhc2ggbG9va3VwIG1hZGUgcG9zc2libGUgYnkga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyBpbiBwYXJhbGxlbCB0b1xuICogYW4gYXJyYXkgb2YgZGljdGlvbmFyeSBvZiB2YWx1ZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBNUlVDYWNoZTtcbmZ1bmN0aW9uIE1SVUNhY2hlKGxlbmd0aCwgb25SZW1vdmUpIHtcbiAgICB0aGlzLm1heCA9IGxlbmd0aDtcbiAgICB0aGlzLm9uUmVtb3ZlID0gb25SZW1vdmU7XG4gICAgdGhpcy5yZXNldCgpO1xufVxuXG4vKlxuICogQ2xlYXJzIHRoZSBjYWNoZVxuICovXG5NUlVDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxpc3QgPSB7fTtcbiAgICB0aGlzLm9yZGVyID0gW107XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiBBZGQgYSBrZXksIHZhbHVlIGNvbWJpbmF0aW9uIHRvIHRoZSBjYWNoZSwgdHJpbW1pbmcgaXRzIHNpemUgaWYgdGhpcyBwdXNoZXNcbiAqIGl0IG92ZXIgbWF4IGxlbmd0aC5cbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgZGF0YSkge1xuICAgIHRoaXMubGlzdFtrZXldID0gZGF0YTtcbiAgICB0aGlzLm9yZGVyLnB1c2goa2V5KTtcblxuICAgIGlmICh0aGlzLm9yZGVyLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIHZhciByZW1vdmVkRGF0YSA9IHRoaXMuZ2V0KHRoaXMub3JkZXJbMF0pO1xuICAgICAgICBpZiAocmVtb3ZlZERhdGEpIHRoaXMub25SZW1vdmUocmVtb3ZlZERhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSB2YWx1ZSBhdHRhY2hlZCB0byBga2V5YCBpcyBwcmVzZW50XG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMubGlzdDtcbn07XG5cbi8qXG4gKiBMaXN0IGFsbCBrZXlzIGluIHRoZSBjYWNoZVxuICovXG5NUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9yZGVyO1xufTtcblxuLypcbiAqIEdldCB0aGUgdmFsdWUgYXR0YWNoZWQgdG8gYSBzcGVjaWZpYyBrZXkuIElmIHRoZSBrZXkgaXMgbm90IGZvdW5kLFxuICogcmV0dXJucyBgbnVsbGBcbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICghdGhpcy5oYXMoa2V5KSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmxpc3Rba2V5XTtcblxuICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcbiAgICB0aGlzLm9yZGVyLnNwbGljZSh0aGlzLm9yZGVyLmluZGV4T2Yoa2V5KSwgMSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVRva2VucztcblxudmFyIHRva2VuUGF0dGVybiA9IC97KFtcXHctXSspfS87XG5cbmZ1bmN0aW9uIHJlc29sdmVUb2tlbnMocHJvcGVydGllcywgZXhwcmVzc2lvbikge1xuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIHRleHQgPSBleHByZXNzaW9uO1xuICAgIHdoaWxlICgobWF0Y2ggPSB0ZXh0Lm1hdGNoKHRva2VuUGF0dGVybikpKSB7XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHByb3BlcnRpZXNbbWF0Y2hbMV1dID09PSAndW5kZWZpbmVkJyA/ICcnIDogcHJvcGVydGllc1ttYXRjaFsxXV07XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UobWF0Y2hbMF0sIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVbml0QmV6aWVyID0gcmVxdWlyZSgndW5pdGJlemllcicpO1xuXG5leHBvcnRzLmVhc2VDdWJpY0luT3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICB2YXIgdDIgPSB0ICogdCxcbiAgICAgICAgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIDQgKiAodCA8IDAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAwLjc1KTtcbn07XG5cbmV4cG9ydHMuYmV6aWVyID0gZnVuY3Rpb24ocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGJlemllciA9IG5ldyBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIGJlemllci5zb2x2ZSh0KTtcbiAgICB9O1xufTtcblxuZXhwb3J0cy5lYXNlID0gZXhwb3J0cy5iZXppZXIoMC4yNSwgMC4xLCAwLjI1LCAxKTtcblxuZXhwb3J0cy5pbnRlcnAgPSBmdW5jdGlvbiAoYSwgYiwgdCkge1xuICAgIHJldHVybiAoYSAqICgxIC0gdCkpICsgKGIgKiB0KTtcbn07XG5cbmV4cG9ydHMucHJlbXVsdGlwbHkgPSBmdW5jdGlvbiAoYykge1xuICAgIGNbMF0gKj0gY1szXTtcbiAgICBjWzFdICo9IGNbM107XG4gICAgY1syXSAqPSBjWzNdO1xuICAgIHJldHVybiBjO1xufTtcblxuZXhwb3J0cy5hc3luY0VhY2ggPSBmdW5jdGlvbiAoYXJyYXksIGZuLCBjYWxsYmFjaykge1xuICAgIHZhciByZW1haW5pbmcgPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgZnVuY3Rpb24gY2hlY2soKSB7IGlmICgtLXJlbWFpbmluZyA9PT0gMCkgY2FsbGJhY2soKTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGZuKGFycmF5W2ldLCBjaGVjayk7XG59O1xuXG5leHBvcnRzLmtleXNEaWZmZXJlbmNlID0gZnVuY3Rpb24gKG9iaiwgb3RoZXIpIHtcbiAgICB2YXIgZGlmZmVyZW5jZSA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICghKGkgaW4gb3RoZXIpKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZlcmVuY2U7XG59O1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChkZXN0LCBzcmMpIHtcbiAgICBmb3IgKHZhciBpIGluIHNyYykge1xuICAgICAgICBkZXN0W2ldID0gc3JjW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbmV4cG9ydHMuZXh0ZW5kQWxsID0gZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdCA9IGZ1bmN0aW9uIChwYXJlbnQsIHByb3BzKSB7XG4gICAgdmFyIHBhcmVudFByb3RvID0gdHlwZW9mIHBhcmVudCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudC5wcm90b3R5cGUgOiBwYXJlbnQsXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm90byk7XG4gICAgZXhwb3J0cy5leHRlbmRBbGwocHJvdG8sIHByb3BzKTtcbiAgICByZXR1cm4gcHJvdG87XG59O1xuXG5leHBvcnRzLnBpY2sgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoayBpbiBzcmMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGlkID0gMTtcblxuZXhwb3J0cy51bmlxdWVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaWQrKztcbn07XG5cbmV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbiAoZm4sIHRpbWUsIGNvbnRleHQpIHtcbiAgICB2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcblxuICAgIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxuICAgICAgICBsb2NrID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICB3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICBhcmdzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobG9jaykge1xuICAgICAgICAgICAgLy8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXG4gICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgc2V0VGltZW91dChsYXRlciwgdGltZSk7XG4gICAgICAgICAgICBsb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gd3JhcHBlckZuO1xufTtcblxuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZuLCB0aW1lKSB7XG4gICAgdmFyIHRpbWVyLCBhcmdzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9LCB0aW1lKTtcbiAgICB9O1xufTtcbiIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMi5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vY3NzLWNvbG9yLXBhcnNlci1qc1xuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXG4gIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNSwxXSwgXCJhcXVhXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiYXF1YW1hcmluZVwiOiBbMTI3LDI1NSwyMTIsMV0sIFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1LDFdLFxuICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxuICBcImJsYWNrXCI6IFswLDAsMCwxXSwgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LDIzNSwyMDUsMV0sXG4gIFwiYmx1ZVwiOiBbMCwwLDI1NSwxXSwgXCJibHVldmlvbGV0XCI6IFsxMzgsNDMsMjI2LDFdLFxuICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcbiAgXCJjYWRldGJsdWVcIjogWzk1LDE1OCwxNjAsMV0sIFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwLDFdLFxuICBcImNob2NvbGF0ZVwiOiBbMjEwLDEwNSwzMCwxXSwgXCJjb3JhbFwiOiBbMjU1LDEyNyw4MCwxXSxcbiAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxuICBcImNyaW1zb25cIjogWzIyMCwyMCw2MCwxXSwgXCJjeWFuXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiZGFya2JsdWVcIjogWzAsMCwxMzksMV0sIFwiZGFya2N5YW5cIjogWzAsMTM5LDEzOSwxXSxcbiAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJrZ3JlZW5cIjogWzAsMTAwLDAsMV0sIFwiZGFya2dyZXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtraGFraVwiOiBbMTg5LDE4MywxMDcsMV0sIFwiZGFya21hZ2VudGFcIjogWzEzOSwwLDEzOSwxXSxcbiAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcbiAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsNTAsMjA0LDFdLCBcImRhcmtyZWRcIjogWzEzOSwwLDAsMV0sXG4gIFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjIsMV0sIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsMTg4LDE0MywxXSxcbiAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXG4gIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzksMV0sIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5LDFdLFxuICBcImRhcmt2aW9sZXRcIjogWzE0OCwwLDIxMSwxXSwgXCJkZWVwcGlua1wiOiBbMjU1LDIwLDE0NywxXSxcbiAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxuICBcImRpbWdyZXlcIjogWzEwNSwxMDUsMTA1LDFdLCBcImRvZGdlcmJsdWVcIjogWzMwLDE0NCwyNTUsMV0sXG4gIFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzQsMV0sIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwLDFdLFxuICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxuICBcImdhaW5zYm9yb1wiOiBbMjIwLDIyMCwyMjAsMV0sIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LDI0OCwyNTUsMV0sXG4gIFwiZ29sZFwiOiBbMjU1LDIxNSwwLDFdLCBcImdvbGRlbnJvZFwiOiBbMjE4LDE2NSwzMiwxXSxcbiAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcbiAgXCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0NywxXSwgXCJncmV5XCI6IFsxMjgsMTI4LDEyOCwxXSxcbiAgXCJob25leWRld1wiOiBbMjQwLDI1NSwyNDAsMV0sIFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODAsMV0sXG4gIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcbiAgXCJpdm9yeVwiOiBbMjU1LDI1NSwyNDAsMV0sIFwia2hha2lcIjogWzI0MCwyMzAsMTQwLDFdLFxuICBcImxhdmVuZGVyXCI6IFsyMzAsMjMwLDI1MCwxXSwgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NSwxXSxcbiAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxuICBcImxpZ2h0Ymx1ZVwiOiBbMTczLDIxNiwyMzAsMV0sIFwibGlnaHRjb3JhbFwiOiBbMjQwLDEyOCwxMjgsMV0sXG4gIFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NSwxXSwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLDI1MCwyMTAsMV0sXG4gIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcbiAgXCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0cGlua1wiOiBbMjU1LDE4MiwxOTMsMV0sXG4gIFwibGlnaHRzYWxtb25cIjogWzI1NSwxNjAsMTIyLDFdLCBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLDE3OCwxNzAsMV0sXG4gIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXG4gIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzLDFdLCBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsMTk2LDIyMiwxXSxcbiAgXCJsaWdodHllbGxvd1wiOiBbMjU1LDI1NSwyMjQsMV0sIFwibGltZVwiOiBbMCwyNTUsMCwxXSxcbiAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXG4gIFwibWFnZW50YVwiOiBbMjU1LDAsMjU1LDFdLCBcIm1hcm9vblwiOiBbMTI4LDAsMCwxXSxcbiAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MCwxXSwgXCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1LDFdLFxuICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxuICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwxNzksMTEzLDFdLCBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzgsMV0sXG4gIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsMjUwLDE1NCwxXSwgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLDIwOSwyMDQsMV0sXG4gIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxuICBcIm1pbnRjcmVhbVwiOiBbMjQ1LDI1NSwyNTAsMV0sIFwibWlzdHlyb3NlXCI6IFsyNTUsMjI4LDIyNSwxXSxcbiAgXCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODEsMV0sIFwibmF2YWpvd2hpdGVcIjogWzI1NSwyMjIsMTczLDFdLFxuICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXG4gIFwib2xpdmVcIjogWzEyOCwxMjgsMCwxXSwgXCJvbGl2ZWRyYWJcIjogWzEwNywxNDIsMzUsMV0sXG4gIFwib3JhbmdlXCI6IFsyNTUsMTY1LDAsMV0sIFwib3JhbmdlcmVkXCI6IFsyNTUsNjksMCwxXSxcbiAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxuICBcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTIsMV0sIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LDIzOCwyMzgsMV0sXG4gIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LDExMiwxNDcsMV0sIFwicGFwYXlhd2hpcFwiOiBbMjU1LDIzOSwyMTMsMV0sXG4gIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxuICBcInBpbmtcIjogWzI1NSwxOTIsMjAzLDFdLCBcInBsdW1cIjogWzIyMSwxNjAsMjIxLDFdLFxuICBcInBvd2RlcmJsdWVcIjogWzE3NiwyMjQsMjMwLDFdLCBcInB1cnBsZVwiOiBbMTI4LDAsMTI4LDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfZmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19pbnQoc3RyKSB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfZmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSBoICs9IDE7XG4gIGVsc2UgaWYgKGggPiAxKSBoIC09IDE7XG5cbiAgaWYgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNTU0NvbG9yKGNzc19zdHIpIHtcbiAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAgLy8gZHVwLlxuXG4gIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgMV07XG4gICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBbcGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG50cnkgeyBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yIH0gY2F0Y2goZSkgeyB9XG4iLCJ2YXIgZ2VvanNvbkFyZWEgPSByZXF1aXJlKCdnZW9qc29uLWFyZWEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXdpbmQ7XG5cbmZ1bmN0aW9uIHJld2luZChnaiwgb3V0ZXIpIHtcbiAgICBzd2l0Y2ggKChnaiAmJiBnai50eXBlKSB8fCBudWxsKSB7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGdqLmZlYXR1cmVzID0gZ2ouZmVhdHVyZXMubWFwKGN1cnJ5T3V0ZXIocmV3aW5kLCBvdXRlcikpO1xuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgICAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgICAgIGdqLmdlb21ldHJ5ID0gcmV3aW5kKGdqLmdlb21ldHJ5LCBvdXRlcik7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3QoZ2osIG91dGVyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGN1cnJ5T3V0ZXIoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbihfKSB7IHJldHVybiBhKF8sIGIpOyB9O1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0KF8sIG91dGVyKSB7XG4gICAgaWYgKF8udHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBjb3JyZWN0UmluZ3MoXy5jb29yZGluYXRlcywgb3V0ZXIpO1xuICAgIH0gZWxzZSBpZiAoXy50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBfLmNvb3JkaW5hdGVzID0gXy5jb29yZGluYXRlcy5tYXAoY3VycnlPdXRlcihjb3JyZWN0UmluZ3MsIG91dGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0UmluZ3MoXywgb3V0ZXIpIHtcbiAgICBvdXRlciA9ICEhb3V0ZXI7XG4gICAgX1swXSA9IHdpbmQoX1swXSwgIW91dGVyKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX1tpXSA9IHdpbmQoX1tpXSwgb3V0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gXztcbn1cblxuZnVuY3Rpb24gd2luZChfLCBkaXIpIHtcbiAgICByZXR1cm4gY3coXykgPT09IGRpciA/IF8gOiBfLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gY3coXykge1xuICAgIHJldHVybiBnZW9qc29uQXJlYS5yaW5nKF8pID49IDA7XG59XG4iLCJ2YXIgd2dzODQgPSByZXF1aXJlKCd3Z3M4NCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xubW9kdWxlLmV4cG9ydHMucmluZyA9IHJpbmdBcmVhO1xuXG5mdW5jdGlvbiBnZW9tZXRyeShfKSB7XG4gICAgaWYgKF8udHlwZSA9PT0gJ1BvbHlnb24nKSByZXR1cm4gcG9seWdvbkFyZWEoXy5jb29yZGluYXRlcyk7XG4gICAgZWxzZSBpZiAoXy50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICB2YXIgYXJlYSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgXy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJlYSArPSBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvbHlnb25BcmVhKGNvb3Jkcykge1xuICAgIHZhciBhcmVhID0gMDtcbiAgICBpZiAoY29vcmRzICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzWzBdKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYXBwcm94aW1hdGUgYXJlYSBvZiB0aGUgcG9seWdvbiB3ZXJlIGl0IHByb2plY3RlZCBvbnRvXG4gKiAgICAgdGhlIGVhcnRoLiAgTm90ZSB0aGF0IHRoaXMgYXJlYSB3aWxsIGJlIHBvc2l0aXZlIGlmIHJpbmcgaXMgb3JpZW50ZWRcbiAqICAgICBjbG9ja3dpc2UsIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICpcbiAqIFJlZmVyZW5jZTpcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogICAgIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqICAgICBMYWJvcmF0b3J5LCBQYXNhZGVuYSwgQ0EsIEp1bmUgMjAwNyBodHRwOi8vdHJzLW5ldy5qcGwubmFzYS5nb3YvZHNwYWNlL2hhbmRsZS8yMDE0LzQwNDA5XG4gKlxuICogUmV0dXJuczpcbiAqIHtmbG9hdH0gVGhlIGFwcHJveGltYXRlIHNpZ25lZCBnZW9kZXNpYyBhcmVhIG9mIHRoZSBwb2x5Z29uIGluIHNxdWFyZVxuICogICAgIG1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiByaW5nQXJlYShjb29yZHMpIHtcbiAgICB2YXIgYXJlYSA9IDA7XG5cbiAgICBpZiAoY29vcmRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdmFyIHAxLCBwMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBwMSA9IGNvb3Jkc1tpXTtcbiAgICAgICAgICAgIHAyID0gY29vcmRzW2kgKyAxXTtcbiAgICAgICAgICAgIGFyZWEgKz0gcmFkKHAyWzBdIC0gcDFbMF0pICogKDIgKyBNYXRoLnNpbihyYWQocDFbMV0pKSArIE1hdGguc2luKHJhZChwMlsxXSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZWEgPSBhcmVhICogd2dzODQuUkFESVVTICogd2dzODQuUkFESVVTIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuZnVuY3Rpb24gcmFkKF8pIHtcbiAgICByZXR1cm4gXyAqIE1hdGguUEkgLyAxODA7XG59XG4iLCJtb2R1bGUuZXhwb3J0cy5SQURJVVMgPSA2Mzc4MTM3O1xubW9kdWxlLmV4cG9ydHMuRkxBVFRFTklORyA9IDEvMjk4LjI1NzIyMzU2Mztcbm1vZHVsZS5leHBvcnRzLlBPTEFSX1JBRElVUyA9IDYzNTY3NTIuMzE0MjtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkdmVyc2lvblwiOiA1LFxuICBcIiRyb290XCI6IHtcbiAgICBcInZlcnNpb25cIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICA1XG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJTdHlsZXNoZWV0IHZlcnNpb24gbnVtYmVyLiBNdXN0IGJlIDUuXCJcbiAgICB9LFxuICAgIFwiY29uc3RhbnRzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbnN0YW50c1wiLFxuICAgICAgXCJkb2NcIjogXCJBbiBvYmplY3Qgb2YgY29uc3RhbnRzIHRvIGJlIHJlZmVyZW5jZWQgaW4gbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcInNvdXJjZXNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwic291cmNlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEYXRhIHNvdXJjZSBzcGVjaWZpY2F0aW9ucyBmb3IgbGF5ZXJzIHRvIHB1bGwgZnJvbS5cIlxuICAgIH0sXG4gICAgXCJsYXllcnNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxuICAgICAgXCJkb2NcIjogXCJBbiBhcnJheSBvZiBsYXllcnMuIFRoZSBvcmRlciBvZiBsYXllcnMgY29pbmNpZGVzIHdpdGggdGhlIG9yZGVyIHRoZXkgd2lsbCBiZSBkcmF3bi5cIlxuICAgIH0sXG4gICAgXCJzcHJpdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3ByaXRlXCIsXG4gICAgICBcImRvY1wiOiBcIlNwcml0ZSBkZWZpbml0aW9uLlwiXG4gICAgfSxcbiAgICBcImdseXBoc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdGVtcGxhdGUgZm9yIGxvYWRpbmcgc2lnbmVkLWRpc3RhbmNlLWZpZWxkIGdseXBoIHNldHMgaW4gUEJGIGZvcm1hdC4gVmFsaWQgdG9rZW5zIGFyZSB7Zm9udHN0YWNrfSBhbmQge3JhbmdlfS5cIlxuICAgIH0sXG4gICAgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInRyYW5zaXRpb25cIixcbiAgICAgIFwiZG9jXCI6IFwiQSBnbG9iYWwgdHJhbnNpdGlvbiBkZWZpbml0aW9uIHRvIHVzZSBhcyBhIGRlZmF1bHQgYWNyb3NzIHByb3BlcnRpZXMuXCJcbiAgICB9XG4gIH0sXG4gIFwic3ByaXRlXCI6IFt7XG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkb2NcIjogXCJBIGJhc2UgVVJMIGZvciByZXRyaWV2aW5nIHRoZSBzcHJpdGUgaW1hZ2UgYW5kIG1ldGFkYXRhLiBUaGUgZXh0ZW5zaW9ucyBgLnBuZ2AsIGAuanNvbmAgYW5kIHNjYWxlIGZhY3RvciBgQDJ4LnBuZ2Agd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkLlwiXG4gIH1dLFxuICBcImNvbnN0YW50c1wiOiB7XG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBjb25zdGFudCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgdmVyYmF0aW0gaW4gdGhlIHJlZmVyZW5jaW5nIHBsYWNlLiBUaGlzIGNhbiBiZSBhbnl0aGluZywgaW5jbHVkaW5nIG9iamVjdHMgYW5kIGFycmF5cy4gQWxsIHZhcmlhYmxlIG5hbWVzIG11c3QgYmUgcHJlZml4ZWQgd2l0aCBhbiBgQGAgc3ltYm9sLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZXNcIjoge1xuICAgIFwiKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzb3VyY2VcIixcbiAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWNhdGlvbiBvZiBhIGRhdGEgc291cmNlLiBGb3IgdmVjdG9yIGFuZCByYXN0ZXIgc291cmNlcywgZWl0aGVyIFRpbGVKU09OIG9yIGEgVVJMIHRvIGEgVGlsZUpTT04gbXVzdCBiZSBwcm92aWRlZC4gRm9yIEdlb0pTT04gYW5kIHZpZGVvIHNvdXJjZXMsIGEgVVJMIG11c3QgYmUgcHJvdmlkZWQuXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZlY3RvclwiLFxuICAgICAgICBcInJhc3RlclwiLFxuICAgICAgICBcImdlb2pzb25cIixcbiAgICAgICAgXCJ2aWRlb1wiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwidXJsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88bWFwaWQ+YC5cIlxuICAgIH0sXG4gICAgXCJ0aWxlc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgICB9LFxuICAgIFwibWluem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMjIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcbiAgICB9LFxuICAgIFwidGlsZVNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNTEyLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSAoaW4gcHgpIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiKlwiLFxuICAgICAgXCJkb2NcIjogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5ZXJcIjoge1xuICAgIFwiaWRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlVuaXF1ZSBsYXllciBuYW1lLlwiXG4gICAgfSxcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImZpbGxcIixcbiAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgIFwic3ltYm9sXCIsXG4gICAgICAgIFwicmFzdGVyXCIsXG4gICAgICAgIFwiYmFja2dyb3VuZFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJSZW5kZXJpbmcgdHlwZSBvZiB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInJlZlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiUmVmZXJlbmNlcyBhbm90aGVyIGxheWVyIHRvIGNvcHkgYHNvdXJjZWAsIGBzb3VyY2VfbGF5ZXJgLCBgZmlsdGVyYCwgYW5kIGByZW5kZXJgIHByb3BlcnRpZXMgZnJvbS4gVGhpcyBhbGxvd3MgdGhlIGxheWVycyB0byBzaGFyZSBwcm9jZXNzaW5nIGFuZCBiZSBtb3JlIGVmZmljaWVudC5cIlxuICAgIH0sXG4gICAgXCJzb3VyY2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgYSBzb3VyY2UgZGVzY3JpcHRpb24gdG8gYmUgdXNlZCBmb3IgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJzb3VyY2UtbGF5ZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBpZiB0aGUgc291cmNlIHN1cHBvcnRzIG11bHRpcGxlIGxheWVycy5cIlxuICAgIH0sXG4gICAgXCJtaW4tem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbGF5ZXIgZ2V0cyBwYXJzZWQgYW5kIGFwcGVhcnMgb24uXCJcbiAgICB9LFxuICAgIFwibWF4LXpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwiXG4gICAgfSxcbiAgICBcImludGVyYWN0aXZlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZG9jXCI6IFwiRW5hYmxlIHF1ZXJ5aW5nIG9mIGZlYXR1cmUgZGF0YSBmcm9tIHRoaXMgbGF5ZXIgZm9yIGludGVyYWN0aXZpdHkuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwicmVuZGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInJlbmRlclwiLFxuICAgICAgXCJkb2NcIjogXCJTeW1ib2xpemVyIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byB2aXN1YWxpemUgdGhpcyBsYXllci4gSWYgdW5zcGVjaWZpZWQgb3IgbnVsbCwgdGhpcyBsYXllciBpcyBub3QgdHJlYXRlZCBhcyBhIHN5bWJvbGl6ZXIgYW5kIG9ubHkgZXhpc3RzIHRvIGhhdmUgcHJvcGVydGllcyBpbmhlcml0ZWQgdG8gb3RoZXIgbGF5ZXJzIHVzaW5nIHJlZi5cIlxuICAgIH0sXG4gICAgXCJmaWx0ZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyXCIsXG4gICAgICBcImRvY1wiOiBcIkFycmF5IG9yIG9iamVjdCBvZiBmaWx0ZXJzIG9yIGV4cHJlc3Npb25zLlwiXG4gICAgfSxcbiAgICBcImxheWVyc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImxheWVyXCIsXG4gICAgICBcImRvY1wiOiBcIklmIGB0eXBlYCBpcyBgcmFzdGVyYCwgdGhlIGNoaWxkIGxheWVycyBhcmUgY29tcG9zaXRlZCB0b2dldGhlciBvbnRvIHRoZSBwcmV2aW91cyBsZXZlbCBsYXllciBsZXZlbC5cIlxuICAgIH0sXG4gICAgXCJzdHlsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjbGFzc1wiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwic3R5bGUuKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjbGFzc1wiLFxuICAgICAgXCJkb2NcIjogXCJPdmVycmlkZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLiBUaGUgY2xhc3MgbmFtZSBpcyB0aGUgcGFydCBhZnRlciB0aGUgZmlyc3QgZG90LlwiXG4gICAgfVxuICB9LFxuICBcInJlbmRlclwiOiBbXG4gICAgXCJyZW5kZXJfZmlsbFwiLFxuICAgIFwicmVuZGVyX2xpbmVcIixcbiAgICBcInJlbmRlcl9zeW1ib2xcIixcbiAgICBcInJlbmRlcl9yYXN0ZXJcIixcbiAgICBcInJlbmRlcl9iYWNrZ3JvdW5kXCJcbiAgXSxcbiAgXCJyZW5kZXJfYmFja2dyb3VuZFwiOiB7XG4gIH0sXG4gIFwicmVuZGVyX2ZpbGxcIjoge1xuICB9LFxuICBcInJlbmRlcl9saW5lXCI6IHtcbiAgICBcImxpbmUtY2FwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJidXR0XCIsXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgXCJzcXVhcmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImJ1dHRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtam9pblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiYmV2ZWxcIixcbiAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICBcIm1pdGVyXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJtaXRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuXCJcbiAgICB9LFxuICAgIFwibGluZS1taXRlci1saW1pdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJkb2NcIjogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBtaXRlciBqb2lucyB0byBiZXZlbCBqb2lucyBmb3Igc2hhcnAgYW5nbGVzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtcm91bmQtbGltaXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZG9jXCI6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgcm91bmQgam9pbnMgdG8gbWl0ZXIgam9pbnMgZm9yIHNoYWxsb3cgYW5nbGVzLlwiXG4gICAgfVxuICB9LFxuICBcInJlbmRlcl9zeW1ib2xcIjoge1xuICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgICAgXCJsaW5lXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwicG9pbnRcIixcbiAgICAgICAgXCJkb2NcIjogXCJQbGFjZW1lbnQgb2YgYSBsYWJlbCByZWxhdGl2ZSB0byBpdHMgZ2VvbWV0cnkuIGBMaW5lYCBjYW4gb25seSBiZSB1c2VkIG9uIExpbmVTdHJpbmdzIGFuZCBQb2x5Z29ucy5cIlxuICAgIH0sXG4gICAgXCJzeW1ib2wtbWluLWRpc3RhbmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDI1MCxcbiAgICAgIFwiZG9jXCI6IFwiTWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzeW1ib2wgYW5jaG9ycyAocHgpXCJcbiAgICB9LFxuICAgIFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbHMgd2lsbCBub3QgY3Jvc3MgdGlsZSBlZGdlcy4gU3ltYm9scyB0aGF0IGNyb3NzIHRpbGUgZWRnZXMgbWF5IGNhdXNlIGNvbGxpc2lvbnMgaW4gc29tZSBjYXNlcy4gVGhpcyBwcm9wZXJ0eSBzaG91bGQgYmUgc2V0IHRvIHRydWUgaWYgdGhlIGxheWVyIGRvZXMgbm90IGhhdmUgZW5vdWdoIHBhZGRpbmcgaW4gdGhlIHZlY3RvciB0aWxlIHRvIHByZXZlbnQgY29sbGlzaW9ucywgb3IgaWYgaXQgaXMgYSBwb2ludCBzeW1ib2wgbGF5ZXIgcGxhY2VkIGFmdGVyIGEgbGluZSBzeW1ib2wgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwiaWNvbi1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBpY29ucyBhbmQgdGV4dC5cIlxuICAgIH0sXG4gICAgXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiB3b24ndCBhZmZlY3QgcGxhY2VtZW50IG9mIG90aGVyIGljb25zIGFuZCB0ZXh0LlwiXG4gICAgfSxcbiAgICBcImljb24tb3B0aW9uYWxcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0ZXh0IGNhbiBiZSBzaG93biB3aXRob3V0IGl0cyBjb3JyZXNwb25kaW5nIGljb24uXCJcbiAgICB9LFxuICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiBpY29uIHdoZW4gbWFwIGlzIHJvdGF0ZWRcIlxuICAgIH0sXG4gICAgXCJpY29uLW1heC1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGFtb3VudCB0byBzY2FsZSB0aGUgaWNvbiBieS5cIlxuICAgIH0sXG4gICAgXCJpY29uLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIHN0cmluZyB3aXRoIHt0b2tlbnN9IHJlcGxhY2VkLCByZWZlcmVuY2luZyB0aGUgZGF0YSBwcm9wZXJ0eSB0byBwdWxsIGZyb20uXCJcbiAgICB9LFxuICAgIFwiaWNvbi1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyB0aGUgaWNvbiBjbG9ja3dpc2UgYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVncmVlcy5cIlxuICAgIH0sXG4gICAgXCJpY29uLXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwiZG9jXCI6IFwiUGFkZGluZyB2YWx1ZSBhcm91bmQgaWNvbiBib3VuZGluZyBib3ggdG8gYXZvaWQgaWNvbiBjb2xsaXNpb25zIChweCkuXCJcbiAgICB9LFxuICAgIFwiaWNvbi1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd25cIlxuICAgIH0sXG4gICAgXCJpY29uLW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkljb24ncyBvZmZzZXQsIGluIHBpeGVscy4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCJcbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiBpY29uIG9yIHRleHQgd2hlbiBtYXAgaXMgcm90YXRlZFwiXG4gICAgfSxcbiAgICBcInRleHQtZmllbGRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJcIixcbiAgICAgIFwiZG9jXCI6IFwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIEZlYXR1cmUgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkIHVzaW5nIHRva2VucyBsaWtlIHtmaWVsZF9uYW1lfS5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWZvbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkZvbnQgc3RhY2sgdG8gdXNlIGZvciBkaXNwbGF5aW5nIHRleHQuXCJcbiAgICB9LFxuICAgIFwidGV4dC1tYXgtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxNixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gc2l6ZSB0ZXh0IHdpbGwgYmUgZGlzcGxheWVkLlwiXG4gICAgfSxcbiAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDE1LFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nIChlbSkuXCJcbiAgICB9LFxuICAgIFwidGV4dC1saW5lLWhlaWdodFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLjIsXG4gICAgICBcImRvY1wiOiBcIlRleHQgbGVhZGluZyB2YWx1ZSBmb3IgbXVsdGktbGluZSB0ZXh0LlwiXG4gICAgfSxcbiAgICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBrZXJuaW5nIHZhbHVlIChlbSkuXCJcbiAgICB9LFxuICAgIFwidGV4dC1qdXN0aWZ5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJjZW50ZXJcIixcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwicmlnaHRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGp1c3RpZmljYXRpb24gb3B0aW9ucy5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWhvcml6b250YWwtYWxpZ25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImxlZnRcIixcbiAgICAgICAgXCJjZW50ZXJcIixcbiAgICAgICAgXCJyaWdodFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgICBcImRvY1wiOiBcIkhvcml6b250YWwgYWxpZ25tZW50IG9mIHRoZSB0ZXh0IHJlbGF0aXZlIHRvIHRoZSBhbmNob3IuXCJcbiAgICB9LFxuICAgIFwidGV4dC12ZXJ0aWNhbC1hbGlnblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidG9wXCIsXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwiYm90dG9tXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVmVydGljYWwgYWxpZ25tZW50IG9mIHRoZSB0ZXh0IHJlbGF0aXZlIHRvIHRoZSBhbmNob3IuXCJcbiAgICB9LFxuICAgIFwidGV4dC1tYXgtYW5nbGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNDUsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGFuZ2xlIGNoYW5nZSwgaW4gZGVncmVlcywgYWxsb3dlZCBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXCJcbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyB0aGUgdGV4dCBjbG9ja3dpc2UgYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVncmVlcy5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwiZG9jXCI6IFwiUGFkZGluZyB2YWx1ZSBhcm91bmQgdGV4dCBib3VuZGluZyBib3ggdG8gYXZvaWQgbGFiZWwgY29sbGlzaW9ucyAocHgpLlwiXG4gICAgfSxcbiAgICBcInRleHQta2VlcC11cHJpZ2h0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0ZXh0IG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93blwiXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNmb3JtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJub25lXCIsXG4gICAgICAgIFwidXBwZXJjYXNlXCIsXG4gICAgICAgIFwibG93ZXJjYXNlXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJub25lXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBpY29ucyBhbmQgbGFiZWxzLlwiXG4gICAgfSxcbiAgICBcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdvbid0IGFmZmVjdCBwbGFjZW1lbnQgb2Ygb3RoZXIgaWNvbnMgYW5kIGxhYmVscy5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LW9wdGlvbmFsXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgaWNvbnMgY2FuIGJlIHNob3duIHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyB0ZXh0LlwiXG4gICAgfVxuICB9LFxuICBcInJlbmRlcl9yYXN0ZXJcIjoge1xuICAgIFwicmFzdGVyLXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogMjU2LFxuICAgICAgXCJkb2NcIjogXCJUaGUgdGV4dHVyZSBpbWFnZSBzaXplIChpbiBwaXhlbHMpIHZlY3RvciBsYXllcnMgd2lsbCBiZSByYXN0ZXJpemVkIGF0LiBXaWxsIGF1dG9tYXRpY2FsbHkgYnkgc2NhbGVkIHRvIG1hdGNoIHRoZSB2aXN1YWwgdGlsZSBzaXplLlwiXG4gICAgfSxcbiAgICBcInJhc3Rlci1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImRvY1wiOiBcIkJsdXIgcmFkaXVzIHRvIGFwcGx5IHRvIHRoZSByYXN0ZXIgdGV4dHVyZSBiZWZvcmUgZGlzcGxheS5cIlxuICAgIH1cbiAgfSxcbiAgXCJmaWx0ZXJcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl9leHByZXNzaW9uXCIsXG4gICAgICBcImRvY1wiOiBcIlZhcmlvdXMgZmlsdGVyIGV4cHJlc3Npb25zLiBVbmxlc3Mgb3ZlcnJpZGRlbiBieSBwYXJlbnQsIHRoZXNlIGFyZSBpbnRlcnByZXRlZCBhcyBgQU5EYC5cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJmaWx0ZXJfZXhwcmVzc2lvblwiLFxuICAgICAgXCJkb2NcIjogXCJWYXJpb3VzIGZpbHRlciBleHByZXNzaW9ucy4gVW5sZXNzIG92ZXJyaWRkZW4gYnkgcGFyZW50LCB0aGVzZSBhcmUgaW50ZXJwcmV0ZWQgYXMgYE9SYC5cIlxuICAgIH1cbiAgXSxcbiAgXCJmaWx0ZXJfZXhwcmVzc2lvblwiOiB7XG4gICAgXCImXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlclwiLFxuICAgICAgXCJkb2NcIjogXCJBTkQgb3BlcmF0b3IuXCJcbiAgICB9LFxuICAgIFwifFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiT1Igb3BlcmF0b3IuXCJcbiAgICB9LFxuICAgIFwiXlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiWE9SIG9wZXJhdG9yLlwiXG4gICAgfSxcbiAgICBcIiFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyXCIsXG4gICAgICBcImRvY1wiOiBcIk5PUiBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCIkdHlwZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiUG9pbnRcIixcbiAgICAgICAgXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgIFwiUG9seWdvblwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJHZW9tZXRyeSB0eXBlIHRoYXQgZmVhdHVyZXMgbXVzdCBtYXRjaC5cIlxuICAgIH0sXG4gICAgXCIqXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX2NvbXBhcmlzb25cIixcbiAgICAgICAgXCJkb2NcIjogXCJBcmJpdGFyaWx5IG5hbWVkIGZlYXR1cmUgbWVtYmVyLiBBIGNvbXBhcmlzb24gb2JqZWN0IGRlZmluaW5nIGEgZmlsdGVyIGV4cHJlc3Npb24uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidHlwZVwiOiBcImZpbHRlcl92YWx1ZVwiLFxuICAgICAgICBcImRvY1wiOiBcIkFyYml0YXJpbHkgbmFtZWQgZmVhdHVyZSBtZW1iZXIuIEEgZmlsdGVyX3ZhbHVlIGltcGxpZXMgdGhlIGVxdWFsaXR5IChzdHJpbmcvbnVtYmVyL2Jvb2xlYW4pIG9yIHNldCBtZW1iZXJzaGlwIG9wZXJhdG9yIChhcnJheSkuXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIFwiZmlsdGVyX2NvbXBhcmlzb25cIjoge1xuICAgIFwiPT1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX3ZhbHVlXCIsXG4gICAgICBcImRvY1wiOiBcIkVxdWFsaXR5IG9wZXJhdG9yLlwiXG4gICAgfSxcbiAgICBcIiE9XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl92YWx1ZVwiLFxuICAgICAgXCJkb2NcIjogXCJJbmVxdWFsaXR5IG9wZXJhdG9yLlwiXG4gICAgfSxcbiAgICBcIj5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX3ZhbHVlXCIsXG4gICAgICBcImRvY1wiOiBcIkdyZWF0ZXIgdGhhbiBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCI+PVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJfdmFsdWVcIixcbiAgICAgIFwiZG9jXCI6IFwiR3JlYXRlciBvciBlcXVhbCB0aGFuIG9wZXJhdG9yLlwiXG4gICAgfSxcbiAgICBcIjxcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX3ZhbHVlXCIsXG4gICAgICBcImRvY1wiOiBcIkxlc3MgdGhhbiBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCI8PVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJfdmFsdWVcIixcbiAgICAgIFwiZG9jXCI6IFwiTGVzcyB0aGFuIG9yIGVxdWFsIG9wZXJhdG9yLlwiXG4gICAgfSxcbiAgICBcImluXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwiZmlsdGVyX3ByaW1pdGl2ZVwiLFxuICAgICAgXCJkb2NcIjogXCJTZXQgbWVtYmVyIG9wZXJhdG9yLlwiXG4gICAgfSxcbiAgICBcIiFpblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImZpbHRlcl9wcmltaXRpdmVcIixcbiAgICAgIFwiZG9jXCI6IFwiTm90IGluIHNldCBvcGVyYXRvci5cIlxuICAgIH1cbiAgfSxcbiAgXCJmaWx0ZXJfdmFsdWVcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl9wcmltaXRpdmVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJmaWx0ZXJfcHJpbWl0aXZlXCJcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyX3ByaW1pdGl2ZVwiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICB9XG4gIF0sXG4gIFwiZnVuY3Rpb25cIjoge1xuICAgIFwic3RvcHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygc3RvcHMuXCIsXG4gICAgICBcInZhbHVlXCI6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgfSxcbiAgICBcImJhc2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuXCJcbiAgICB9XG4gIH0sXG4gIFwiZnVuY3Rpb25fc3RvcFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICBcInZhbHVlXCI6IFtcIm51bWJlclwiLCBcImNvbG9yXCJdLFxuICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgXCJkb2NcIjogXCJab29tIGxldmVsIGFuZCB2YWx1ZSBwYWlyLlwiXG4gIH0sXG4gIFwiY2xhc3NcIjogW1xuICAgIFwiY2xhc3NfZmlsbFwiLFxuICAgIFwiY2xhc3NfbGluZVwiLFxuICAgIFwiY2xhc3Nfc3ltYm9sXCIsXG4gICAgXCJjbGFzc19yYXN0ZXJcIixcbiAgICBcImNsYXNzX2JhY2tncm91bmRcIlxuICBdLFxuICBcImNsYXNzX2ZpbGxcIjoge1xuICAgIFwiZmlsbC1hbnRpYWxpYXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIldoZXRoZXIgb3Igbm90IHRoZSBmaWxsIHNob3VsZCBiZSBhbnRpYWxpYXNlZC5cIlxuICAgIH0sXG4gICAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImZpbGwtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJmaWxsLW91dGxpbmUtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG91dGxpbmUgY29sb3Igb2YgdGhlIGZpbGwuIE1hdGNoZXMgdGhlIHZhbHVlIG9mIGBmaWxsLWNvbG9yYCBpZiB1bnNwZWNpZmllZC5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImZpbGwtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQsIGluIHBpeGVscy4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCJcbiAgICB9LFxuICAgIFwiZmlsbC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCJcbiAgICB9LFxuICAgIFwiZmlsbC1pbWFnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLlwiXG4gICAgfVxuICB9LFxuICBcImNsYXNzX2xpbmVcIjoge1xuICAgIFwibGluZS1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJsaW5lLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwibGluZS10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldCwgaW4gcGl4ZWxzLiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxuICAgIH0sXG4gICAgXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIlxuICAgIH0sXG4gICAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTGluZSB3aWR0aCAoaW4gcHgpXCJcbiAgICB9LFxuICAgIFwibGluZS1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiTGluZSBjYXNpbmcgd2hlcmUgYGxpbmUtb2Zmc2V0YCBpbmRpY2F0ZXMgdG90YWwgd2lkdGguIEBUT0RPIHJlbmFtZT9cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImxpbmUtYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkxpbmUgYmx1ciwgaW4gcGl4ZWxzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZGFzaGFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMSxcbiAgICAgICAgLTFcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJsaW5lLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgbGluZXMuXCJcbiAgICB9XG4gIH0sXG4gIFwiY2xhc3Nfc3ltYm9sXCI6IHtcbiAgICBcImljb24tb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwiaWNvbi1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGFtb3VudCB0byBzY2FsZSB0aGUgaWNvbiBieS4gMSBpcyBvcmlnaW5hbCBzaXplLCAzIHRyaXBsZXMgdGhlIHNpemUuXCJcbiAgICB9LFxuICAgIFwiaWNvbi1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMVxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24uIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNkZiBpY29ucy5cIlxuICAgIH0sXG4gICAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uJ3MgaGFsby4gSWNvbiBoYWxvcyBjYW4gb25seSBiZSB1c2VkIHdpdGggc2RmIGljb25zLlwiXG4gICAgfSxcbiAgICBcImljb24taGFsby13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkhvdyBmYXIgYXdheSB0aGUgaGFsbyBpcyBmcm9tIHRoZSBpY29uIG91dGxpbmUsIGluIHBpeGVscy5cIlxuICAgIH0sXG4gICAgXCJpY29uLWhhbG8tYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUsIGluIHBpeGVscy5cIlxuICAgIH0sXG4gICAgXCJpY29uLXRyYW5zbGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiQW4gaWNvbidzIG9mZnNldCwgaW4gcGl4ZWxzLiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxuICAgIH0sXG4gICAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIlxuICAgIH0sXG4gICAgXCJ0ZXh0LW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInRleHQtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxNixcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJGb250IHNpemUgaW4gcGl4ZWxzLiBJZiB1bnNwZWNpZmllZCwgdGhlIHRleHQgd2lsbCBiZSBhcyBiaWcgYXMgYWxsb3dlZCBieSB0aGUgbGF5ZXIgZGVmaW5pdGlvbi5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiSG93IGZhciBhd2F5IHRoZSBoYWxvIGlzIGZyb20gdGhlIGZvbnQgb3V0bGluZSwgaW4gcGl4ZWxzLiBNYXggdGV4dCBoYWxvIHdpZHRoIGlzIDEvNCBvZiB0aGUgZm9udC1zaXplIChweCkuXCJcbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJGYWRlIG91dCB0aGUgaGFsbyB0b3dhcmRzIHRoZSBvdXRzaWRlLCBpbiBwaXhlbHMuXCJcbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkEgbGFiZWwncyBvZmZzZXQsIGluIHBpeGVscy4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCJcbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCJcbiAgICB9XG4gIH0sXG4gIFwiY2xhc3NfcmFzdGVyXCI6IHtcbiAgICBcInJhc3Rlci1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItaHVlLXJvdGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsIGJ5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlZ3JlZXMuXCJcbiAgICB9LFxuICAgIFwicmFzdGVyLWJyaWdodG5lc3NcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLXNhdHVyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1jb250cmFzdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWZhZGUtZHVyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMzAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyBvZiB0aGUgZmFkZSB3aGVuIGEgbmV3IHRpbGUgaXMgYWRkZWQuXCJcbiAgICB9XG4gIH0sXG4gIFwiY2xhc3NfYmFja2dyb3VuZFwiOiB7XG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwiYmFja2dyb3VuZC1pbWFnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfVxuICB9LFxuICBcInRyYW5zaXRpb25cIjoge1xuICAgIFwiZHVyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMzAwLFxuICAgICAgXCJkb2NcIjogXCJUaW1lIGluIG1pbGxpc2Vjb25kcyB0aGF0IGl0IHRha2VzIGZvciB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZS5cIlxuICAgIH0sXG4gICAgXCJkZWxheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJUaW1lIGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgYSB0cmFuc2l0aW9uIGJlZ2lucy5cIlxuICAgIH1cbiAgfVxufVxuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b2J1ZjtcbmZ1bmN0aW9uIFByb3RvYnVmKGJ1Zikge1xuICAgIHRoaXMuYnVmID0gYnVmO1xuICAgIHRoaXMucG9zID0gMDtcbn1cblxuUHJvdG9idWYucHJvdG90eXBlID0ge1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmJ1Zi5sZW5ndGg7IH1cbn07XG5cblByb3RvYnVmLlZhcmludCA9IDA7XG5Qcm90b2J1Zi5JbnQ2NCA9IDE7XG5Qcm90b2J1Zi5NZXNzYWdlID0gMjtcblByb3RvYnVmLlN0cmluZyA9IDI7XG5Qcm90b2J1Zi5QYWNrZWQgPSAyO1xuUHJvdG9idWYuSW50MzIgPSA1O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYnVmID0gbnVsbDtcbn07XG5cbi8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkVUludDMyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWRVSW50NjQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQ2NExFKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWw7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUucmVhZERvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWwgPSBpZWVlNzU0LnJlYWQodGhpcy5idWYsIHRoaXMucG9zLCB0cnVlLCA1MiwgOCk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWRWYXJpbnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPOiBib3VuZHMgY2hlY2tpbmdcbiAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMuYnVmW3Bvc10gPD0gMHg3Zikge1xuICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZbcG9zXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnVmW3BvcyArIDFdIDw9IDB4N2YpIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJ1Zltwb3NdICYgMHg3ZikgfCAodGhpcy5idWZbcG9zICsgMV0gPDwgNyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1Zltwb3MgKyAyXSA8PSAweDdmKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDM7XG4gICAgICAgIHJldHVybiAodGhpcy5idWZbcG9zXSAmIDB4N2YpIHwgKHRoaXMuYnVmW3BvcyArIDFdICYgMHg3ZikgPDwgNyB8ICh0aGlzLmJ1Zltwb3MgKyAyXSkgPDwgMTQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1Zltwb3MgKyAzXSA8PSAweDdmKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiAodGhpcy5idWZbcG9zXSAmIDB4N2YpIHwgKHRoaXMuYnVmW3BvcyArIDFdICYgMHg3ZikgPDwgNyB8ICh0aGlzLmJ1Zltwb3MgKyAyXSAmIDB4N2YpIDw8IDE0IHwgKHRoaXMuYnVmW3BvcyArIDNdKSA8PCAyMTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnVmW3BvcyArIDRdIDw9IDB4N2YpIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gNTtcbiAgICAgICAgcmV0dXJuICgodGhpcy5idWZbcG9zXSAmIDB4N2YpIHwgKHRoaXMuYnVmW3BvcyArIDFdICYgMHg3ZikgPDwgNyB8ICh0aGlzLmJ1Zltwb3MgKyAyXSAmIDB4N2YpIDw8IDE0IHwgKHRoaXMuYnVmW3BvcyArIDNdKSA8PCAyMSkgKyAodGhpcy5idWZbcG9zICsgNF0gKiAyNjg0MzU0NTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2tpcChQcm90b2J1Zi5WYXJpbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiVE9ETzogSGFuZGxlIDYrIGJ5dGUgdmFyaW50c1wiKTtcbiAgICB9XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUucmVhZFNWYXJpbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVtID0gdGhpcy5yZWFkVmFyaW50KCk7XG4gICAgaWYgKG51bSA+IDIxNDc0ODM2NDcpIHRocm93IG5ldyBFcnJvcignVE9ETzogSGFuZGxlIG51bWJlcnMgPj0gMl4zMCcpO1xuICAgIC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIHJldHVybiAoKG51bSA+PiAxKSBeIC0obnVtICYgMSkpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAvLyBUT0RPOiBib3VuZHMgY2hlY2tpbmdcbiAgICB2YXIgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgIHZhciBwID0gdGhpcy5wb3M7XG4gICAgdmFyIGVuZCA9IHRoaXMucG9zICsgYnl0ZXM7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHdoaWxlIChwIDwgZW5kKSB7XG4gICAgICAgIGlmIChiW3BdIDw9IDB4N0YpIHN0ciArPSBjaHIoYltwKytdKTtcbiAgICAgICAgZWxzZSBpZiAoYltwXSA8PSAweEJGKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVRGLTggY29kZXBvaW50OiAnICsgYltwXSk7XG4gICAgICAgIGVsc2UgaWYgKGJbcF0gPD0gMHhERikgc3RyICs9IGNocigoYltwKytdICYgMHgxRikgPDwgNiB8IChiW3ArK10gJiAweDNGKSk7XG4gICAgICAgIGVsc2UgaWYgKGJbcF0gPD0gMHhFRikgc3RyICs9IGNocigoYltwKytdICYgMHgxRikgPDwgMTIgfCAoYltwKytdICYgMHgzRikgPDwgNiB8IChiW3ArK10gJiAweDNGKSk7XG4gICAgICAgIGVsc2UgaWYgKGJbcF0gPD0gMHhGNykgcCArPSA0OyAvLyBXZSBjYW4ndCBoYW5kbGUgdGhlc2UgY29kZXBvaW50cyBpbiBKUywgc28gc2tpcC5cbiAgICAgICAgZWxzZSBpZiAoYltwXSA8PSAweEZCKSBwICs9IDU7XG4gICAgICAgIGVsc2UgaWYgKGJbcF0gPD0gMHhGRCkgcCArPSA2O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVVEYtOCBjb2RlcG9pbnQ6ICcgKyBiW3BdKTtcbiAgICB9XG4gICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkVmFyaW50KCk7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmLnN1YmFycmF5KHRoaXMucG9zLCB0aGlzLnBvcyArIGJ5dGVzKTtcbiAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWRQYWNrZWQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgLy8gVE9ETzogYm91bmRzIGNoZWNraW5nXG4gICAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkVmFyaW50KCk7XG4gICAgdmFyIGVuZCA9IHRoaXMucG9zICsgYnl0ZXM7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSB7XG4gICAgICAgIGFycmF5LnB1c2godGhpc1sncmVhZCcgKyB0eXBlXSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyBUT0RPOiBib3VuZHMgY2hlY2tpbmdcbiAgICB2YXIgdHlwZSA9IHZhbCAmIDB4NztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLyogdmFyaW50ICovIGNhc2UgUHJvdG9idWYuVmFyaW50OiB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKTsgYnJlYWs7XG4gICAgICAgIC8qIDY0IGJpdCAqLyBjYXNlIFByb3RvYnVmLkludDY0OiB0aGlzLnBvcyArPSA4OyBicmVhaztcbiAgICAgICAgLyogbGVuZ3RoICovIGNhc2UgUHJvdG9idWYuTWVzc2FnZTogdmFyIGJ5dGVzID0gdGhpcy5yZWFkVmFyaW50KCk7IHRoaXMucG9zICs9IGJ5dGVzOyBicmVhaztcbiAgICAgICAgLyogMzIgYml0ICovIGNhc2UgUHJvdG9idWYuSW50MzI6IHRoaXMucG9zICs9IDQ7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbn07XG5cbi8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZyA9IGZ1bmN0aW9uKHRhZywgdHlwZSkge1xuICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWxsb2MgPSBmdW5jdGlvbihtaW4pIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG4gICAgaWYgKGxlbmd0aCAhPSB0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5idWYuY29weShidWYpO1xuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICB9XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMucG9zKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVBhY2tlZCA9IGZ1bmN0aW9uKHR5cGUsIHRhZywgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdmFyIG1lc3NhZ2UgPSBuZXcgUHJvdG9idWYoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1lc3NhZ2VbJ3dyaXRlJyArIHR5cGVdKGl0ZW1zW2ldKTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBtZXNzYWdlLmZpbmlzaCgpO1xuXG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLlBhY2tlZCk7XG4gICAgdGhpcy53cml0ZUJ1ZmZlcihkYXRhKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVVJbnQzMiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVUYWdnZWRVSW50MzIgPSBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgIHRoaXMud3JpdGVUYWcodGFnLCBQcm90b2J1Zi5JbnQzMik7XG4gICAgdGhpcy53cml0ZVVJbnQzMih2YWwpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVmFyaW50ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICB9XG5cbiAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHZhbCA8PSAweDNmZmYpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4ODAgfCAoKHZhbCA+Pj4gMCkgJiAweDdmKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDAwIHwgKCh2YWwgPj4+IDcpICYgMHg3Zik7XG4gICAgfSBlbHNlIGlmICh2YWwgPD0gMHgxZmZmZmZmKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYygzKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDgwIHwgKCh2YWwgPj4+IDApICYgMHg3Zik7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHg4MCB8ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4MDAgfCAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG4gICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDgwIHwgKCh2YWwgPj4+IDApICYgMHg3Zik7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHg4MCB8ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4ODAgfCAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHgwMCB8ICgodmFsID4+PiAyMSkgJiAweDdmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAodmFsID4gMCkge1xuICAgICAgICAgICAgdmFyIGIgPSB2YWwgJiAweDdmO1xuICAgICAgICAgICAgdmFsID0gTWF0aC5mbG9vcih2YWwgLyAxMjgpO1xuICAgICAgICAgICAgaWYgKHZhbCA+IDApIGIgfD0gMHg4MFxuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSBiO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkVmFyaW50ID0gZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuVmFyaW50KTtcbiAgICB0aGlzLndyaXRlVmFyaW50KHZhbCk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVTVmFyaW50ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKHZhbCA+PSAwKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsICogMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgKiAtMiAtIDEpO1xuICAgIH1cbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZFNWYXJpbnQgPSBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgIHRoaXMud3JpdGVUYWcodGFnLCBQcm90b2J1Zi5WYXJpbnQpO1xuICAgIHRoaXMud3JpdGVTVmFyaW50KHZhbCk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVCb29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy53cml0ZVZhcmludChCb29sZWFuKHZhbCkpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkQm9vbGVhbiA9IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgdGhpcy53cml0ZVRhZ2dlZFZhcmludCh0YWcsIEJvb2xlYW4odmFsKSk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpO1xuICAgIHRoaXMud3JpdGVWYXJpbnQoYnl0ZXMpO1xuICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgdGhpcy5idWYud3JpdGUoc3RyLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVUYWdnZWRTdHJpbmcgPSBmdW5jdGlvbih0YWcsIHN0cikge1xuICAgIHRoaXMud3JpdGVUYWcodGFnLCBQcm90b2J1Zi5TdHJpbmcpO1xuICAgIHRoaXMud3JpdGVTdHJpbmcoc3RyKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZUZsb2F0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgIHRoaXMuYnVmLndyaXRlRmxvYXRMRSh2YWwsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkRmxvYXQgPSBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgIHRoaXMud3JpdGVUYWcodGFnLCBQcm90b2J1Zi5JbnQzMik7XG4gICAgdGhpcy53cml0ZUZsb2F0KHZhbCk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVEb3VibGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkRG91YmxlID0gZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuSW50NjQpO1xuICAgIHRoaXMud3JpdGVEb3VibGUodmFsKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgdGhpcy5yZWFsbG9jKGJ5dGVzKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IGJ5dGVzO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkQnVmZmVyID0gZnVuY3Rpb24odGFnLCBidWZmZXIpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuU3RyaW5nKTtcbiAgICB0aGlzLndyaXRlQnVmZmVyKGJ1ZmZlcik7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVNZXNzYWdlID0gZnVuY3Rpb24odGFnLCBwcm90b2J1Zikge1xuICAgIHZhciBidWZmZXIgPSBwcm90b2J1Zi5maW5pc2goKTtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuTWVzc2FnZSk7XG4gICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xufVxuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIGFkZDogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHApOyAgICAgfSxcbiAgICBzdWI6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3N1YihwKTsgICAgIH0sXG4gICAgbXVsdDogICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KGspOyAgICB9LFxuICAgIGRpdjogICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2KGspOyAgICAgfSxcbiAgICByb3RhdGU6ICBmdW5jdGlvbihhKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdGF0ZShhKTsgIH0sXG4gICAgbWF0TXVsdDogZnVuY3Rpb24obSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tYXRNdWx0KG0pOyB9LFxuICAgIHVuaXQ6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl91bml0KCk7IH0sXG4gICAgcGVycDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3BlcnAoKTsgfSxcbiAgICByb3VuZDogICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTsgfSxcblxuICAgIG1hZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHAueCAmJlxuICAgICAgICAgICAgICAgdGhpcy55ID09PSBwLnk7XG4gICAgfSxcblxuICAgIGRpc3Q6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RTcXIocCkpO1xuICAgIH0sXG5cbiAgICBkaXN0U3FyOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBkeCA9IHAueCAtIHRoaXMueCxcbiAgICAgICAgICAgIGR5ID0gcC55IC0gdGhpcy55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfSxcblxuICAgIGFuZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVRvOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSAtIGIueSwgdGhpcy54IC0gYi54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVXaXRoOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuZ2xlV2l0aFNlcChiLngsIGIueSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgdGhlIGFuZ2xlIG9mIHRoZSB0d28gdmVjdG9ycywgc29sdmluZyB0aGUgZm9ybXVsYSBmb3IgdGhlIGNyb3NzIHByb2R1Y3QgYSB4IGIgPSB8YXx8YnxzaW4ozrgpIGZvciDOuC5cbiAgICBhbmdsZVdpdGhTZXA6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoXG4gICAgICAgICAgICB0aGlzLnggKiB5IC0gdGhpcy55ICogeCxcbiAgICAgICAgICAgIHRoaXMueCAqIHggKyB0aGlzLnkgKiB5KTtcbiAgICB9LFxuXG4gICAgX21hdE11bHQ6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHggPSBtWzBdICogdGhpcy54ICsgbVsxXSAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBtWzJdICogdGhpcy54ICsgbVszXSAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hZGQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54ICs9IHAueDtcbiAgICAgICAgdGhpcy55ICs9IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zdWI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54IC09IHAueDtcbiAgICAgICAgdGhpcy55IC09IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9tdWx0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAqPSBrO1xuICAgICAgICB0aGlzLnkgKj0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9kaXY6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54IC89IGs7XG4gICAgICAgIHRoaXMueSAvPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3VuaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXYodGhpcy5tYWcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcGVycDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB0aGlzLnkgPSB0aGlzLng7XG4gICAgICAgIHRoaXMueCA9IC15O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSBjb3MgKiB0aGlzLnggLSBzaW4gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gc2luICogdGhpcy54ICsgY29zICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIGNvbnN0cnVjdHMgUG9pbnQgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcblBvaW50LmNvbnZlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoYVswXSwgYVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbiAgZnVuY3Rpb24gcXVldWUocGFyYWxsZWxpc20pIHtcbiAgICB2YXIgcSxcbiAgICAgICAgdGFza3MgPSBbXSxcbiAgICAgICAgc3RhcnRlZCA9IDAsIC8vIG51bWJlciBvZiB0YXNrcyB0aGF0IGhhdmUgYmVlbiBzdGFydGVkIChhbmQgcGVyaGFwcyBmaW5pc2hlZClcbiAgICAgICAgYWN0aXZlID0gMCwgLy8gbnVtYmVyIG9mIHRhc2tzIGN1cnJlbnRseSBiZWluZyBleGVjdXRlZCAoc3RhcnRlZCBidXQgbm90IGZpbmlzaGVkKVxuICAgICAgICByZW1haW5pbmcgPSAwLCAvLyBudW1iZXIgb2YgdGFza3Mgbm90IHlldCBmaW5pc2hlZFxuICAgICAgICBwb3BwaW5nLCAvLyBpbnNpZGUgYSBzeW5jaHJvbm91cyB0YXNrIGNhbGxiYWNrP1xuICAgICAgICBlcnJvciA9IG51bGwsXG4gICAgICAgIGF3YWl0ID0gbm9vcCxcbiAgICAgICAgYWxsO1xuXG4gICAgaWYgKCFwYXJhbGxlbGlzbSkgcGFyYWxsZWxpc20gPSBJbmZpbml0eTtcblxuICAgIGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAgIHdoaWxlIChwb3BwaW5nID0gc3RhcnRlZCA8IHRhc2tzLmxlbmd0aCAmJiBhY3RpdmUgPCBwYXJhbGxlbGlzbSkge1xuICAgICAgICB2YXIgaSA9IHN0YXJ0ZWQrKyxcbiAgICAgICAgICAgIHQgPSB0YXNrc1tpXSxcbiAgICAgICAgICAgIGEgPSBzbGljZS5jYWxsKHQsIDEpO1xuICAgICAgICBhLnB1c2goY2FsbGJhY2soaSkpO1xuICAgICAgICArK2FjdGl2ZTtcbiAgICAgICAgdFswXS5hcHBseShudWxsLCBhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsYmFjayhpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSwgcikge1xuICAgICAgICAtLWFjdGl2ZTtcbiAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKGUgIT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yID0gZTsgLy8gaWdub3JlIG5ldyB0YXNrcyBhbmQgc3F1ZWxjaCBhY3RpdmUgY2FsbGJhY2tzXG4gICAgICAgICAgc3RhcnRlZCA9IHJlbWFpbmluZyA9IE5hTjsgLy8gc3RvcCBxdWV1ZWQgdGFza3MgZnJvbSBzdGFydGluZ1xuICAgICAgICAgIG5vdGlmeSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhc2tzW2ldID0gcjtcbiAgICAgICAgICBpZiAoLS1yZW1haW5pbmcpIHBvcHBpbmcgfHwgcG9wKCk7XG4gICAgICAgICAgZWxzZSBub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkgYXdhaXQoZXJyb3IpO1xuICAgICAgZWxzZSBpZiAoYWxsKSBhd2FpdChlcnJvciwgdGFza3MpO1xuICAgICAgZWxzZSBhd2FpdC5hcHBseShudWxsLCBbZXJyb3JdLmNvbmNhdCh0YXNrcykpO1xuICAgIH1cblxuICAgIHJldHVybiBxID0ge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgdGFza3MucHVzaChhcmd1bWVudHMpO1xuICAgICAgICAgICsrcmVtYWluaW5nO1xuICAgICAgICAgIHBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxO1xuICAgICAgfSxcbiAgICAgIGF3YWl0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgIGF3YWl0ID0gZjtcbiAgICAgICAgYWxsID0gZmFsc2U7XG4gICAgICAgIGlmICghcmVtYWluaW5nKSBub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYXdhaXRBbGw6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgYXdhaXQgPSBmO1xuICAgICAgICBhbGwgPSB0cnVlO1xuICAgICAgICBpZiAoIXJlbWFpbmluZykgbm90aWZ5KCk7XG4gICAgICAgIHJldHVybiBxO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICBxdWV1ZS52ZXJzaW9uID0gXCIxLjAuN1wiO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHF1ZXVlOyB9KTtcbiAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBxdWV1ZTtcbiAgZWxzZSB0aGlzLnF1ZXVlID0gcXVldWU7XG59KSgpO1xuIiwiLypcbiAoYykgMjAxMywgVmxhZGltaXIgQWdhZm9ua2luXG4gUkJ1c2gsIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBoaWdoLXBlcmZvcm1hbmNlIDJEIHNwYXRpYWwgaW5kZXhpbmcgb2YgcG9pbnRzIGFuZCByZWN0YW5nbGVzLlxuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoXG4qL1xuXG4oZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuXG4gICAgLy8ganNoaW50IG5ld2NhcDogZmFsc2UsIHZhbGlkdGhpczogdHJ1ZVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlLmJib3gpKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc3RyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgYmJveDogZW1wdHkoKSxcbiAgICAgICAgICAgIGxlYWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5vZGUuY2hpbGRyZW4uaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUuYmJveCwgYmJveCkpIHsgLy8gZ28gZG93blxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQkJveDogZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH0sXG5cbiAgICBjb21wYXJlTWluWDogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9LFxuICAgIGNvbXBhcmVNaW5ZOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfSxcblxuICAgIGZyb21KU09OOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfYnVpbGQ6IGZ1bmN0aW9uIChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMSxcbiAgICAgICAgICAgIE0gPSB0aGlzLl9tYXhFbnRyaWVzLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXG4gICAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBpdGVtcy5zbGljZShsZWZ0LCByaWdodCArIDEpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICBiYm94OiBudWxsLFxuICAgICAgICAgICAgICAgIGxlYWY6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gZWxpbWluYXRlIHJlY3Vyc2lvbj9cblxuICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBiYm94OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXG5cbiAgICAgICAgdmFyIE4yID0gTWF0aC5jZWlsKE4gLyBNKSxcbiAgICAgICAgICAgIE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcbiAgICAgICAgICAgIGksIGosIHJpZ2h0MiwgcmlnaHQzO1xuXG4gICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xuXG4gICAgICAgIGZvciAoaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkgKz0gTjEpIHtcblxuICAgICAgICAgICAgcmlnaHQyID0gTWF0aC5taW4oaSArIE4xIC0gMSwgcmlnaHQpO1xuXG4gICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgICAgICByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVN1YnRyZWU6IGZ1bmN0aW9uIChiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIGNoaWxkLCB0YXJnZXROb2RlLCBhcmVhLCBlbmxhcmdlbWVudCwgbWluQXJlYSwgbWluRW5sYXJnZW1lbnQ7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBwYXRoLmxlbmd0aCAtIDEgPT09IGxldmVsKSBicmVhaztcblxuICAgICAgICAgICAgbWluQXJlYSA9IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGNoaWxkLmJib3gpO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkLmJib3gpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpIHtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbS5iYm94IDogdG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUuYmJveCwgYmJveCk7XG5cbiAgICAgICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHdoaWxlIChsZXZlbCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0UGF0aFtsZXZlbF0uY2hpbGRyZW4ubGVuZ3RoID4gdGhpcy5fbWF4RW50cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgaW5zZXJ0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcbiAgICB9LFxuXG4gICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXG4gICAgX3NwbGl0OiBmdW5jdGlvbiAoaW5zZXJ0UGF0aCwgbGV2ZWwpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdLFxuICAgICAgICAgICAgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uc3BsaWNlKHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSkpLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChub2RlLmxlYWYpIG5ld05vZGUubGVhZiA9IHRydWU7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfSxcblxuICAgIF9zcGxpdFJvb3Q6IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW25vZGUsIG5ld05vZGVdLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCArIDFcbiAgICAgICAgfTtcbiAgICAgICAgY2FsY0JCb3godGhpcy5kYXRhLCB0aGlzLnRvQkJveCk7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTcGxpdEluZGV4OiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBpLCBiYm94MSwgYmJveDIsIG92ZXJsYXAsIGFyZWEsIG1pbk92ZXJsYXAsIG1pbkFyZWEsIGluZGV4O1xuXG4gICAgICAgIG1pbk92ZXJsYXAgPSBtaW5BcmVhID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8PSBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgICAgICBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xuICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcblxuICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcmxhcCA9PT0gbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBhcmVhXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvLyBzb3J0cyBub2RlIGNoaWxkcmVuIGJ5IHRoZSBiZXN0IGF4aXMgZm9yIHNwbGl0XG4gICAgX2Nob29zZVNwbGl0QXhpczogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgY29tcGFyZU1pblggPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5YIDogY29tcGFyZU5vZGVNaW5YLFxuICAgICAgICAgICAgY29tcGFyZU1pblkgPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5ZIDogY29tcGFyZU5vZGVNaW5ZLFxuICAgICAgICAgICAgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpLFxuICAgICAgICAgICAgeU1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblkpO1xuXG4gICAgICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYWxyZWFkeSBzb3J0ZWQgYnkgbWluWVxuICAgICAgICBpZiAoeE1hcmdpbiA8IHlNYXJnaW4pIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlTWluWCk7XG4gICAgfSxcblxuICAgIC8vIHRvdGFsIG1hcmdpbiBvZiBhbGwgcG9zc2libGUgc3BsaXQgZGlzdHJpYnV0aW9ucyB3aGVyZSBlYWNoIG5vZGUgaXMgYXQgbGVhc3QgbSBmdWxsXG4gICAgX2FsbERpc3RNYXJnaW46IGZ1bmN0aW9uIChub2RlLCBtLCBNLCBjb21wYXJlKSB7XG5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGxlZnRCQm94ID0gZGlzdEJCb3gobm9kZSwgMCwgbSwgdG9CQm94KSxcbiAgICAgICAgICAgIHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpLFxuICAgICAgICAgICAgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCksXG4gICAgICAgICAgICBpLCBjaGlsZDtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXS5iYm94LCBiYm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29uZGVuc2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdEZvcm1hdDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAvLyBkYXRhIGZvcm1hdCAobWluWCwgbWluWSwgbWF4WCwgbWF4WSBhY2Nlc3NvcnMpXG5cbiAgICAgICAgLy8gdXNlcyBldmFsLXR5cGUgZnVuY3Rpb24gY29tcGlsYXRpb24gaW5zdGVhZCBvZiBqdXN0IGFjY2VwdGluZyBhIHRvQkJveCBmdW5jdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBhbGdvcml0aG1zIGFyZSB2ZXJ5IHNlbnNpdGl2ZSB0byBzb3J0aW5nIGZ1bmN0aW9ucyBwZXJmb3JtYW5jZSxcbiAgICAgICAgLy8gc28gdGhleSBzaG91bGQgYmUgZGVhZCBzaW1wbGUgYW5kIHdpdGhvdXQgaW5uZXIgY2FsbHNcblxuICAgICAgICAvLyBqc2hpbnQgZXZpbDogdHJ1ZVxuXG4gICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcblxuICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XG4gICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcblxuICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsICdyZXR1cm4gW2EnICsgZm9ybWF0LmpvaW4oJywgYScpICsgJ107Jyk7XG4gICAgfVxufTtcblxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBub2RlLmJib3ggPSBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94KTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCkge1xuICAgIHZhciBiYm94ID0gZW1wdHkoKTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChiYm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJib3g7XG59XG5cbmZ1bmN0aW9uIGVtcHR5KCkgeyByZXR1cm4gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldOyB9XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYVswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIGFbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBhWzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgYVszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5iYm94WzBdIC0gYi5iYm94WzBdOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5iYm94WzFdIC0gYi5iYm94WzFdOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGFbMl0gLSBhWzBdKSAqIChhWzNdIC0gYVsxXSk7IH1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYSkgeyByZXR1cm4gKGFbMl0gLSBhWzBdKSArIChhWzNdIC0gYVsxXSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGJbMl0sIGFbMl0pIC0gTWF0aC5taW4oYlswXSwgYVswXSkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGJbM10sIGFbM10pIC0gTWF0aC5taW4oYlsxXSwgYVsxXSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhIChhLCBiKSB7XG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhWzBdLCBiWzBdKSxcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYVsyXSwgYlsyXSksXG4gICAgICAgIG1heFkgPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA8PSBiWzBdICYmXG4gICAgICAgICAgIGFbMV0gPD0gYlsxXSAmJlxuICAgICAgICAgICBiWzJdIDw9IGFbMl0gJiZcbiAgICAgICAgICAgYlszXSA8PSBhWzNdO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzIChhLCBiKSB7XG4gICAgcmV0dXJuIGJbMF0gPD0gYVsyXSAmJlxuICAgICAgICAgICBiWzFdIDw9IGFbM10gJiZcbiAgICAgICAgICAgYlsyXSA+PSBhWzBdICYmXG4gICAgICAgICAgIGJbM10gPj0gYVsxXTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXG4gICAgICAgIG1pZDtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBtaWQsIGNvbXBhcmUpO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcbiAgICB9XG59XG5cbi8vIHNvcnQgYXJyYXkgYmV0d2VlbiBsZWZ0IGFuZCByaWdodCAoaW5jbHVzaXZlKSBzbyB0aGF0IHRoZSBzbWFsbGVzdCBrIGVsZW1lbnRzIGNvbWUgZmlyc3QgKHVub3JkZXJlZClcbmZ1bmN0aW9uIHNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBrLCBjb21wYXJlKSB7XG4gICAgdmFyIG4sIGksIHosIHMsIHNkLCBuZXdMZWZ0LCBuZXdSaWdodCwgdCwgajtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICBpID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChpIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBpICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBpKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHNlbGVjdChhcnIsIG5ld0xlZnQsIG5ld1JpZ2h0LCBrLCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQgPSBhcnJba107XG4gICAgICAgIGkgPSBsZWZ0O1xuICAgICAgICBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cblxuLy8gZXhwb3J0IGFzIEFNRC9Db21tb25KUyBtb2R1bGUgb3IgZ2xvYmFsIHZhcmlhYmxlXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiByYnVzaDsgfSk7XG5lbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcbmVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgc2VsZi5yYnVzaCA9IHJidXNoO1xuZWxzZSB3aW5kb3cucmJ1c2ggPSByYnVzaDtcblxufSkoKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDggQXBwbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgQVBQTEUgSU5DLiBgYEFTIElTJycgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIEFQUExFIElOQy4gT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXG4gKiBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBXZWJraXRcbiAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmhcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXRCZXppZXI7XG5cbmZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS5cbiAgICB0aGlzLmN4ID0gMy4wICogcDF4O1xuICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG4gICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4O1xuXG4gICAgdGhpcy5jeSA9IDMuMCAqIHAxeTtcbiAgICB0aGlzLmJ5ID0gMy4wICogKHAyeSAtIHAxeSkgLSB0aGlzLmN5O1xuICAgIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcblxuICAgIHRoaXMucDF4ID0gcDF4O1xuICAgIHRoaXMucDF5ID0gcDJ5O1xuICAgIHRoaXMucDJ4ID0gcDJ4O1xuICAgIHRoaXMucDJ5ID0gcDJ5O1xufVxuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVkgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoMy4wICogdGhpcy5heCAqIHQgKyAyLjAgKiB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgaWYgKHR5cGVvZiBlcHNpbG9uID09PSAndW5kZWZpbmVkJykgZXBzaWxvbiA9IDFlLTY7XG5cbiAgICB2YXIgdDAsIHQxLCB0MiwgeDIsIGk7XG5cbiAgICAvLyBGaXJzdCB0cnkgYSBmZXcgaXRlcmF0aW9ucyBvZiBOZXd0b24ncyBtZXRob2QgLS0gbm9ybWFsbHkgdmVyeSBmYXN0LlxuICAgIGZvciAodDIgPSB4LCBpID0gMDsgaSA8IDg7IGkrKykge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpIC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICB2YXIgZDIgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgMWUtNikgYnJlYWs7XG5cbiAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS5cbiAgICB0MCA9IDAuMDtcbiAgICB0MSA9IDEuMDtcbiAgICB0MiA9IHg7XG5cbiAgICBpZiAodDIgPCB0MCkgcmV0dXJuIHQwO1xuICAgIGlmICh0MiA+IHQxKSByZXR1cm4gdDE7XG5cbiAgICB3aGlsZSAodDAgPCB0MSkge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICBpZiAoeCA+IHgyKSB7XG4gICAgICAgICAgICB0MCA9IHQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHQyID0gKHQxIC0gdDApICogMC41ICsgdDA7XG4gICAgfVxuXG4gICAgLy8gRmFpbHVyZS5cbiAgICByZXR1cm4gdDI7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVsYXllci5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlbGF5ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlKGJ1ZmZlciwgZW5kKSB7XG5cbiAgICB0aGlzLmxheWVycyA9IHt9O1xuICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblxuICAgIGVuZCA9IGVuZCB8fCBidWZmZXIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGJ1ZmZlci5yZWFkVmFyaW50KCksXG4gICAgICAgICAgICB0YWcgPSB2YWwgPj4gMztcblxuICAgICAgICBpZiAodGFnID09IDMpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMucmVhZExheWVyKCk7XG4gICAgICAgICAgICBpZiAobGF5ZXIubGVuZ3RoKSB0aGlzLmxheWVyc1tsYXllci5uYW1lXSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuVmVjdG9yVGlsZS5wcm90b3R5cGUucmVhZExheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcixcbiAgICAgICAgYnl0ZXMgPSBidWZmZXIucmVhZFZhcmludCgpLFxuICAgICAgICBlbmQgPSBidWZmZXIucG9zICsgYnl0ZXMsXG4gICAgICAgIGxheWVyID0gbmV3IFZlY3RvclRpbGVMYXllcihidWZmZXIsIGVuZCk7XG5cbiAgICBidWZmZXIucG9zID0gZW5kO1xuXG4gICAgcmV0dXJuIGxheWVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlRmVhdHVyZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZUZlYXR1cmUoYnVmZmVyLCBlbmQsIGV4dGVudCwga2V5cywgdmFsdWVzKSB7XG5cbiAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcblxuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuICAgIHRoaXMudHlwZSA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gLTE7XG5cbiAgICBlbmQgPSBlbmQgfHwgYnVmZmVyLmxlbmd0aDtcblxuICAgIHdoaWxlIChidWZmZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpLFxuICAgICAgICAgICAgdGFnID0gdmFsID4+IDM7XG5cbiAgICAgICAgaWYgKHRhZyA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9pZCA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMikge1xuICAgICAgICAgICAgdmFyIHRhZ0VuZCA9IGJ1ZmZlci5wb3MgKyBidWZmZXIucmVhZFZhcmludCgpO1xuXG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IHRhZ0VuZCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2J1ZmZlci5yZWFkVmFyaW50KCldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tidWZmZXIucmVhZFZhcmludCgpXTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNCkge1xuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBidWZmZXIucG9zO1xuICAgICAgICAgICAgYnVmZmVyLnNraXAodmFsKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xuICAgIGJ1ZmZlci5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCksXG4gICAgICAgIGVuZCA9IGJ1ZmZlci5wb3MgKyBieXRlcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBsaW5lcyA9IFtdLFxuICAgICAgICBsaW5lO1xuXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRfbGVuZ3RoID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZF9sZW5ndGggJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRfbGVuZ3RoID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gYnVmZmVyLnJlYWRTVmFyaW50KCk7XG5cbiAgICAgICAgICAgIGlmIChjbWQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlVG9cbiAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUucHVzaChuZXcgUG9pbnQoeCwgeSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gNykge1xuICAgICAgICAgICAgLy8gY2xvc2VQb2x5Z29uXG4gICAgICAgICAgICBsaW5lLnB1c2gobGluZVswXS5jbG9uZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb21tYW5kICcgKyBjbWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG59O1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG4gICAgYnVmZmVyLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgZW5kID0gYnVmZmVyLnBvcyArIGJ5dGVzLFxuXG4gICAgICAgIGNtZCA9IDEsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gMCxcbiAgICAgICAgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgeDIgPSAtSW5maW5pdHksXG4gICAgICAgIHkxID0gSW5maW5pdHksXG4gICAgICAgIHkyID0gLUluZmluaXR5O1xuXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRfbGVuZ3RoID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZF9sZW5ndGggJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRfbGVuZ3RoID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gYnVmZmVyLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICBpZiAoeCA8IHgxKSB4MSA9IHg7XG4gICAgICAgICAgICBpZiAoeCA+IHgyKSB4MiA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IHkxKSB5MSA9IHk7XG4gICAgICAgICAgICBpZiAoeSA+IHkyKSB5MiA9IHk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgIT09IDcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb21tYW5kICcgKyBjbWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZUxheWVyO1xuZnVuY3Rpb24gVmVjdG9yVGlsZUxheWVyKGJ1ZmZlciwgZW5kKSB7XG4gICAgLy8gUHVibGljXG4gICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gNDA5NjtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICB0aGlzLl9mZWF0dXJlcyA9IFtdO1xuXG4gICAgdmFyIHZhbCwgdGFnO1xuXG4gICAgZW5kID0gZW5kIHx8IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB0YWcgPSB2YWwgPj4gMztcblxuICAgICAgICBpZiAodGFnID09PSAxNSkge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGJ1ZmZlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09PSA1KSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVudCA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMucHVzaChidWZmZXIucG9zKTtcbiAgICAgICAgICAgIGJ1ZmZlci5za2lwKHZhbCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChidWZmZXIucmVhZFN0cmluZygpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHRoaXMucmVhZEZlYXR1cmVWYWx1ZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlci5za2lwKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblZlY3RvclRpbGVMYXllci5wcm90b3R5cGUucmVhZEZlYXR1cmVWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLl9idWZmZXIsXG4gICAgICAgIHZhbHVlID0gbnVsbCxcbiAgICAgICAgYnl0ZXMgPSBidWZmZXIucmVhZFZhcmludCgpLFxuICAgICAgICBlbmQgPSBidWZmZXIucG9zICsgYnl0ZXMsXG4gICAgICAgIHZhbCwgdGFnO1xuXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFsID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgdGFnID0gdmFsID4+IDM7XG5cbiAgICAgICAgaWYgKHRhZyA9PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVhZCBmbG9hdCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSAzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlci5yZWFkRG91YmxlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFkIHVpbnQnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNikge1xuICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNykge1xuICAgICAgICAgICAgdmFsdWUgPSBCb29sZWFuKGJ1ZmZlci5yZWFkVmFyaW50KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIHJldHVybiBmZWF0dXJlIGBpYCBmcm9tIHRoaXMgbGF5ZXIgYXMgYSBgVmVjdG9yVGlsZUZlYXR1cmVgXG5WZWN0b3JUaWxlTGF5ZXIucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbihpKSB7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2ZlYXR1cmUgaW5kZXggb3V0IG9mIGJvdW5kcycpO1xuXG4gICAgdGhpcy5fYnVmZmVyLnBvcyA9IHRoaXMuX2ZlYXR1cmVzW2ldO1xuICAgIHZhciBlbmQgPSB0aGlzLl9idWZmZXIucmVhZFZhcmludCgpICsgdGhpcy5fYnVmZmVyLnBvcztcblxuICAgIHJldHVybiBuZXcgVmVjdG9yVGlsZUZlYXR1cmUodGhpcy5fYnVmZmVyLCBlbmQsIHRoaXMuZXh0ZW50LCB0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMpO1xufTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgZWxzZVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0W2ldXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihhKSAmJiBCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQpID8gc2VsZi5sZW5ndGggOiBOdW1iZXIoZW5kKVxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgWkVSTyAgID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KCkpXG4iXX0=
